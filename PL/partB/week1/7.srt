WEBVTT

1
00:00:00.000 --> 00:00:05.085
[MUSIC]

2
00:00:05.085 --> 00:00:08.360
In this segment, I want to
introduce Racket's local bindings.

3
00:00:08.360 --> 00:00:11.250
This is what in ML,
we use let-expressions for.

4
00:00:11.250 --> 00:00:15.170
Racket also has let-expressions, but
it actually has a variety of them.

5
00:00:15.170 --> 00:00:17.270
And that'll let us
understand some interesting,

6
00:00:17.270 --> 00:00:20.750
different semantics between
the different kinds of let-expressions.

7
00:00:20.750 --> 00:00:24.698
But before we get that let me
show you an initial example,

8
00:00:24.698 --> 00:00:28.079
it's one of the same
examples I showed you in ML.

9
00:00:28.079 --> 00:00:32.184
Let's compute the maximum number in
a list, we'll assume we're past the list,

10
00:00:32.184 --> 00:00:34.640
and assume that lost only has numbers.

11
00:00:34.640 --> 00:00:37.316
Let's use cond which we now know.

12
00:00:37.316 --> 00:00:40.240
And let's ask first,
if we have an empty list.

13
00:00:40.240 --> 00:00:42.420
There's no such thing as
the maximum of an empty list.

14
00:00:42.420 --> 00:00:48.196
So there is a built in feature in racket
called error, that we can pass a string.

15
00:00:48.196 --> 00:00:53.860
And if this evaluates execution will stop
with this error, so that seems reasonable.

16
00:00:53.860 --> 00:00:56.545
Otherwise, if we have the one
element list, how do you check for

17
00:00:56.545 --> 00:00:57.407
a one element list?

18
00:00:57.407 --> 00:01:00.940
You check if the cdr is empty,
that makes sense.

19
00:01:00.940 --> 00:01:05.379
Then let's just return the car because
the largest element of one element list is

20
00:01:05.379 --> 00:01:06.625
that element itself.

21
00:01:06.625 --> 00:01:12.800
Otherwise, we know we better not make
multiple recursive calls on the same list.

22
00:01:12.800 --> 00:01:16.420
We saw an exponential blow up when
we did this sort of thing in ML.

23
00:01:16.420 --> 00:01:19.390
So let's create a local variable to hold

24
00:01:21.050 --> 00:01:24.930
the max of the cdr and
then we will compete with that here.

25
00:01:24.930 --> 00:01:28.540
Now before I go on, let me show you
since I just introduced syntax,

26
00:01:28.540 --> 00:01:31.310
let is the new special
form I'm showing you.

27
00:01:31.310 --> 00:01:35.007
Then you have the starting right
preferences and that will eventually be

28
00:01:35.007 --> 00:01:38.170
matched by this close preferences and
then you have the body.

29
00:01:38.170 --> 00:01:40.183
And then you close the let, okay?

30
00:01:40.183 --> 00:01:44.020
And what goes here on the dot, dot,
dot is one or more variable bindings.

31
00:01:44.020 --> 00:01:49.298
Each one goes in parenthesis as
a matter of style use square brackets,

32
00:01:49.298 --> 00:01:54.048
and then it's x1 expression 1,
x2 expression 2 and so on.

33
00:01:54.048 --> 00:01:56.480
You can have as many of these as you want.

34
00:01:56.480 --> 00:02:01.345
So this is just like in ML having
a number of val bindings in the same

35
00:02:01.345 --> 00:02:02.620
let-expression.

36
00:02:02.620 --> 00:02:07.436
And so in this particular case,
I didn't need en of them, right?

37
00:02:07.436 --> 00:02:11.590
I only needed one, and so
I'll just put that back up here.

38
00:02:11.590 --> 00:02:14.335
And so when you have one,
it's often easy to forget,

39
00:02:14.335 --> 00:02:17.030
you need this extra pair
of a parenthesis around it.

40
00:02:17.030 --> 00:02:19.571
But you do need those extra ones,
otherwise,

41
00:02:19.571 --> 00:02:21.602
it just won't work syntactically.

42
00:02:21.602 --> 00:02:25.025
So now I have the place
where I bound my variables.

43
00:02:25.025 --> 00:02:28.680
There was one here tlans, and
now I just need the body.

44
00:02:28.680 --> 00:02:30.150
And my body will just be,

45
00:02:30.150 --> 00:02:34.440
if the tlans is greater than the first
element on the list, the car of xs.

46
00:02:34.440 --> 00:02:39.146
Then return the tlans,
otherwise return the head of the list and

47
00:02:39.146 --> 00:02:42.470
that should work as
a definition of max list.

48
00:02:42.470 --> 00:02:47.330
So this is just an example of showing
you this let-expression, right?

49
00:02:47.330 --> 00:02:51.530
Where the body is this if, and
then the list of bindings is here.

50
00:02:51.530 --> 00:02:54.680
And this one had one binding in it,
which is right there.

51
00:02:54.680 --> 00:02:57.520
So that's our example of a let expression,
but now let me

52
00:02:57.520 --> 00:03:01.910
do the rest of this in the slides and show
you we have actually more to understand.

53
00:03:02.970 --> 00:03:06.920
So it turns out racket has four different
ways to define local variables.

54
00:03:06.920 --> 00:03:10.170
Let, let*, letrec, and local defines.

55
00:03:10.170 --> 00:03:14.250
And these varieties is actually good,
they have different semantics.

56
00:03:14.250 --> 00:03:15.990
And so with that different semantics,

57
00:03:15.990 --> 00:03:21.100
we can use the best one that's most
convenient for the code we're writing.

58
00:03:21.100 --> 00:03:24.604
And which helps communicate to
the person reading our code,

59
00:03:24.604 --> 00:03:27.362
which of the different
semantics we mean here.

60
00:03:27.362 --> 00:03:30.811
And is most convenient for
that computation we're doing, okay?

61
00:03:30.811 --> 00:03:33.738
So this will help us learn
things about scope and

62
00:03:33.738 --> 00:03:37.469
environments better by seeing
the two actually can get three

63
00:03:37.469 --> 00:03:42.200
different reasonable definitions to
the meaning of the let-expression.

64
00:03:42.200 --> 00:03:44.790
Let versus let* versus letrec.

65
00:03:44.790 --> 00:03:48.710
So I'll just go through of these in order,
we'll start with the let.

66
00:03:48.710 --> 00:03:52.330
We know that a let-expression can
bind any number of local variables.

67
00:03:52.330 --> 00:03:58.692
I showed that to you in Dr. Racket,
but the expressions are all evaluated

68
00:03:58.692 --> 00:04:04.037
in the environment from before
the let-expression, okay?

69
00:04:04.037 --> 00:04:08.926
So given a let-expression, we of course
the body of the let-expression uses

70
00:04:08.926 --> 00:04:10.861
all the variables we defined.

71
00:04:10.861 --> 00:04:13.591
But it turns out
the expressions that initialized

72
00:04:13.591 --> 00:04:16.670
those variables do not use
the earlier variables.

73
00:04:16.670 --> 00:04:21.950
They are all evaluated in the environment
from before the let-expression.

74
00:04:21.950 --> 00:04:24.740
This is not how ML let-expressions work.

75
00:04:24.740 --> 00:04:27.890
Different languages have
different semantics for things.

76
00:04:27.890 --> 00:04:29.959
Let's look at the example
here on the slide,

77
00:04:29.959 --> 00:04:32.580
this is a function that takes
in a number x and doubles it.

78
00:04:32.580 --> 00:04:36.790
Just does it in a silly way to
emphasize the semantics that I want to.

79
00:04:36.790 --> 00:04:41.380
So here when I say let x be x + 3,

80
00:04:41.380 --> 00:04:45.550
this x on the right hand side is going to
be the x from before the let-expression,

81
00:04:45.550 --> 00:04:47.190
the parameter to the function.

82
00:04:47.190 --> 00:04:49.356
So this is parameter + 3.

83
00:04:49.356 --> 00:04:53.625
y with + x 2,
this x will also be the parameter.

84
00:04:53.625 --> 00:04:55.405
This is not how ML works.

85
00:04:55.405 --> 00:04:59.860
So since it is also the parameter,
y is parameter + 2.

86
00:04:59.860 --> 00:05:05.518
So if I take these together,
I end up with 2 times the parameter + 5.

87
00:05:05.518 --> 00:05:08.122
So if I subtract 5 back out,
I get twice the parameter and

88
00:05:08.122 --> 00:05:10.900
that's why it's a silly double function.

89
00:05:10.900 --> 00:05:12.580
So why do you want this semantics?

90
00:05:12.580 --> 00:05:19.110
Well, if you're not reusing variable names
here, the way this x is shadowing that.

91
00:05:19.110 --> 00:05:23.890
This doesn't really matter and so
if you're not doing any shadowing,

92
00:05:23.890 --> 00:05:27.460
it's best style in racket to just use let.

93
00:05:27.460 --> 00:05:30.490
But it's also convenient in
certain other situations.

94
00:05:30.490 --> 00:05:33.350
Like if you wanted to have
some body where x was y and

95
00:05:33.350 --> 00:05:36.090
y was x, you can write it like this.

96
00:05:36.090 --> 00:05:39.070
And under ML semantics this does not work.

97
00:05:39.070 --> 00:05:44.470
That x would be bound to the outer y, and
then y would also be bound to the outer y.

98
00:05:44.470 --> 00:05:48.937
Because under ML semantics the second
x would be bound to the first one.

99
00:05:48.937 --> 00:05:54.657
But under Racket's let, let x be y and
y be x would properly change the bindings

100
00:05:54.657 --> 00:06:00.222
of x and y to each other for the body
of the let-expression, so that's let.

101
00:06:00.222 --> 00:06:02.185
Now, let me show you let*.

102
00:06:02.185 --> 00:06:07.184
So syntactically let* works exactly like
let, it just has one more character,

103
00:06:07.184 --> 00:06:09.030
it has a * after the t, okay?

104
00:06:09.030 --> 00:06:12.940
And this is ML's let, okay?

105
00:06:12.940 --> 00:06:16.780
The expressions are all evaluated
in the environment produced from

106
00:06:16.780 --> 00:06:17.870
the previous bindings.

107
00:06:18.870 --> 00:06:20.240
If we didn't have this,

108
00:06:20.240 --> 00:06:23.520
we would have to nest our lets
when we wanted this behavior.

109
00:06:23.520 --> 00:06:26.820
So here's our example,
you're probably comfortable with this one,

110
00:06:26.820 --> 00:06:30.010
only because we used ML first in
our study of programming languages.

111
00:06:31.530 --> 00:06:36.964
Here, when I say + x 3, that will be the x
that is the parameter to the function.

112
00:06:36.964 --> 00:06:37.612
And now for

113
00:06:37.612 --> 00:06:43.120
y, when I say + x 2, I use the environment
created by all the earlier bindings.

114
00:06:43.120 --> 00:06:49.920
So I will use the shadowed x, so y will
in fact be bound to the parameter + 5.

115
00:06:49.920 --> 00:06:54.870
So if I have parameter + 3, and parameter
+ 5, when I add those together and

116
00:06:54.870 --> 00:06:58.933
subtract 8, I end up doubling
the argument, so that is let*.

117
00:06:58.933 --> 00:07:02.670
It's much more like ML's let-expression,
okay?

118
00:07:02.670 --> 00:07:05.794
Another one, so that's let and let*.

119
00:07:05.794 --> 00:07:09.650
Now we do letrec syntactically
it's just like the others,

120
00:07:09.650 --> 00:07:14.840
except instead of running let or
let*, we write L-E-T-R-E-C, letrec.

121
00:07:14.840 --> 00:07:19.316
This is for, the rec is short for
recursion and the expressions

122
00:07:19.316 --> 00:07:23.975
are evaluated in an environment
that includes all the bindings.

123
00:07:23.975 --> 00:07:26.639
The earlier ones and the later ones.

124
00:07:28.360 --> 00:07:32.870
It's more like MLs and for
finding mutually recursive things.

125
00:07:32.870 --> 00:07:35.480
So here's an example,
it's a little more complicated actually

126
00:07:35.480 --> 00:07:39.850
triples its argument instead of doubling,
we're getting into fancier stuff, right?

127
00:07:39.850 --> 00:07:43.441
So I have three local variables,
y, f, and w.

128
00:07:43.441 --> 00:07:45.430
And if you look at f, it's a function.

129
00:07:46.480 --> 00:07:52.981
Then when you call it, uses it's
argument z, but also uses y, w, and x.

130
00:07:52.981 --> 00:07:56.539
And x because we don't have
any shadowing anywhere here,

131
00:07:56.539 --> 00:07:58.944
will be the parameter to the function.

132
00:07:58.944 --> 00:08:03.389
y will be the earlier binding which
we could have also gotten with let*.

133
00:08:03.389 --> 00:08:08.070
We could not have done that with let,
and w will be the later binding.

134
00:08:08.070 --> 00:08:12.743
And this is what you have to use letrec
for, it will not work with let or

135
00:08:12.743 --> 00:08:13.640
with let*.

136
00:08:13.640 --> 00:08:16.715
So when we call f-9, z will -9,

137
00:08:16.715 --> 00:08:21.848
y will be the parameter + 2,
w will be the parameter + 7.

138
00:08:21.848 --> 00:08:24.981
And x will be the parameter as we
put it all together you end up

139
00:08:24.981 --> 00:08:27.200
tripling your argument.

140
00:08:27.200 --> 00:08:28.950
So why does the language have letrec?

141
00:08:28.950 --> 00:08:30.520
Well you need this sort of thing for

142
00:08:30.520 --> 00:08:34.330
mutually recursive functions,
f calls g, g calls f.

143
00:08:34.330 --> 00:08:42.500
All defined within a define like this,
but we have to be careful here.

144
00:08:42.500 --> 00:08:46.841
I recommend only using letrec for when
you have mutually recursive functions.

145
00:08:46.841 --> 00:08:49.800
It's generally not so useful otherwise.

146
00:08:49.800 --> 00:08:53.280
Because the expressions
are still evaluated in order.

147
00:08:53.280 --> 00:08:54.966
You have to be really careful here.

148
00:08:54.966 --> 00:09:01.527
What if y,
instead of saying + x 2 had said + w 2?

149
00:09:01.527 --> 00:09:05.490
Well w is in the environment,
that's the rule of letrec.

150
00:09:05.490 --> 00:09:08.642
But we have not evaluated it yet
because at runtime,

151
00:09:08.642 --> 00:09:12.879
when we evaluate these bindings,
we do still evaluate them in order.

152
00:09:12.879 --> 00:09:16.450
So Racket would not like this very much.

153
00:09:16.450 --> 00:09:22.762
It turns out not to raise an error instead
when it hits that x, sorry, that w.

154
00:09:22.762 --> 00:09:26.288
It will return some funny
undefined thing and then we will

155
00:09:26.288 --> 00:09:31.290
get an error because we call plus on
undefined, that causes an error, okay?

156
00:09:31.290 --> 00:09:34.570
So this would be bad style,
it would surely be a bug.

157
00:09:34.570 --> 00:09:39.270
The reason why it works for
f is because the use of w,

158
00:09:39.270 --> 00:09:44.150
the forward reference, the use of the
later binding is inside a function body.

159
00:09:44.150 --> 00:09:47.918
And we know that when we evaluate
this expression, this Lambda,

160
00:09:47.918 --> 00:09:50.187
we don't evaluate the function body.

161
00:09:50.187 --> 00:09:53.400
We don't evaluate function
bodies untill we call them.

162
00:09:53.400 --> 00:09:56.294
So we evaluate y we get parameter + 2,

163
00:09:56.294 --> 00:10:01.315
we evaluate f we create a closure,
we evaluate w we parameter + 7.

164
00:10:01.315 --> 00:10:04.360
And now when we call
that closure we created,

165
00:10:04.360 --> 00:10:09.984
w has been nicely initialized we'll look
it up and there will be no problem, okay?

166
00:10:09.984 --> 00:10:11.190
So that is is letrec.

167
00:10:13.100 --> 00:10:17.290
Here's an example where letrec is actually
needed, is actually properly used.

168
00:10:17.290 --> 00:10:19.610
I'll let you puzzle through
this code on your own.

169
00:10:19.610 --> 00:10:24.930
It's actually taking an argument and
returning true if it's,

170
00:10:24.930 --> 00:10:28.387
sorry, if it's taken the number mod2.

171
00:10:28.387 --> 00:10:32.583
So if it's an even number it returns 0,
if it's an odd number it returns 1.

172
00:10:32.583 --> 00:10:34.593
It only works for non negative numbers and

173
00:10:34.593 --> 00:10:37.905
it does it via these very silly
mutually recursive functions.

174
00:10:37.905 --> 00:10:39.575
But my point is to use letrec, so

175
00:10:39.575 --> 00:10:43.385
that even is bound to a Lambda
that in its body called odd.

176
00:10:43.385 --> 00:10:47.775
And odd is bound to a Lambda in its body
called even, so forward reference and

177
00:10:47.775 --> 00:10:48.870
backward reference.

178
00:10:48.870 --> 00:10:50.590
I am using the Greek letter Lambda here,

179
00:10:50.590 --> 00:10:53.690
just on the slide rather than
writing out the word Lambda.

180
00:10:53.690 --> 00:10:57.354
It turns out you can do that in Dr.
Racket, but I prefer you write it out.

181
00:10:57.354 --> 00:10:59.972
So that when you submit
your homework assignments,

182
00:10:59.972 --> 00:11:03.910
we don't have unicode characters that
don't always print well everywhere.

183
00:11:03.910 --> 00:11:06.700
But if you really want to use Lambda,
I suppose we will survive.

184
00:11:08.095 --> 00:11:13.275
And here's another example
of not using later bindings,

185
00:11:13.275 --> 00:11:20.369
because you get this undefined issue that
we talked about on the previous line.

186
00:11:20.369 --> 00:11:22.590
So that's my discussion of letrec.

187
00:11:22.590 --> 00:11:25.880
I told you there's one other
way to define local variables.

188
00:11:25.880 --> 00:11:31.060
So in certain positions in your function
body, you can actually use define.

189
00:11:31.060 --> 00:11:32.687
So for example right here,

190
00:11:32.687 --> 00:11:36.241
I'm defining another version
of this silly mod function.

191
00:11:36.241 --> 00:11:39.344
My function body is the everything but
the first line,

192
00:11:39.344 --> 00:11:43.590
the function body is the second,
the third line and the fourth line.

193
00:11:43.590 --> 00:11:47.070
You can actually in here write define,
and then have bindings.

194
00:11:47.070 --> 00:11:49.290
And you can have any number of these and

195
00:11:49.290 --> 00:11:51.830
those will be local
variables to your function.

196
00:11:51.830 --> 00:11:55.097
And the semantics is the same as letrec.

197
00:11:55.097 --> 00:11:59.918
Exactly everything I told you about
letrec is true for local defines as well.

198
00:11:59.918 --> 00:12:05.113
It's just a different syntax as long
as we are using all the constructs

199
00:12:05.113 --> 00:12:09.796
we will use in this course and
I prefer to use let*r and letrec.

200
00:12:09.796 --> 00:12:11.890
It's the more traditional style.

201
00:12:11.890 --> 00:12:16.490
It emphasizes the different semantics,
but I should be honest with you.

202
00:12:16.490 --> 00:12:20.987
The biggest users and designers of
the Racket language now say that local

203
00:12:20.987 --> 00:12:24.525
defines as the preferred style
that you should use let and

204
00:12:24.525 --> 00:12:27.010
lets* when you want those semantics.

205
00:12:27.010 --> 00:12:30.792
But if the semantics doesn't matter,
meaning the result would be the same for

206
00:12:30.792 --> 00:12:31.373
all three.

207
00:12:31.373 --> 00:12:36.350
Or if you actually need letrec, then
they'd prefer this local define syntax.

208
00:12:36.350 --> 00:12:38.670
And so on your homework,
I will let you choose.

209
00:12:38.670 --> 00:12:41.210
If you want to use local defines, you can.

210
00:12:41.210 --> 00:12:46.952
But I find it easier to think about
the traditional expressions let,

211
00:12:46.952 --> 00:12:49.380
let* and letrec, okay?

212
00:12:49.380 --> 00:12:51.080
So that's our introduction to scope.

213
00:12:51.080 --> 00:12:55.452
Remember not only do you need to know
the differences between these concerts,

214
00:12:55.452 --> 00:12:59.120
to read Racket code and
to write Racket code in good style.

215
00:12:59.120 --> 00:13:03.069
But it's wonderful that we have
a language that lets us think about three

216
00:13:03.069 --> 00:13:06.385
different definitions for
how let expression should work.

217
00:13:06.385 --> 00:13:11.542
Because each of them is more convenient
and most useful in different situations.