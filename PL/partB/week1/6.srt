WEBVTT

1
00:00:00.012 --> 00:00:03.936
[MUSIC]. 
In this segment, I want to introduce the 

2
00:00:03.936 --> 00:00:08.889
cond construct into racket. 
it's useful in place of nested 

3
00:00:08.889 --> 00:00:12.624
if/then/else expressions. 
It's better style. 

4
00:00:12.624 --> 00:00:18.147
And it's not very hard to learn. 
I just put it off to get us started with 

5
00:00:18.147 --> 00:00:21.896
the bigger ideas in Racket. 
But you do want to use this. 

6
00:00:21.896 --> 00:00:26.115
Whenever you have a bunch of nested ifs 
where your else branch, your false branch 

7
00:00:26.115 --> 00:00:28.695
is another if. 
And then the else branch of that is 

8
00:00:28.695 --> 00:00:31.086
another if. 
Cond is definitely better style. 

9
00:00:31.086 --> 00:00:34.692
You can think of cond as just syntactic 
sugar for nested if/then/else 

10
00:00:34.692 --> 00:00:37.564
expressions. 
Or if you prefer to think of if/then/else 

11
00:00:37.564 --> 00:00:41.037
as syntactic sugar for a cond with just 2 
branches, that's fine too. 

12
00:00:42.102 --> 00:00:45.702
So here's how cond works. 
It's just a special form, COND. 

13
00:00:45.702 --> 00:00:49.792
So of course, it has a parenthesis at the 
beginning, and at the end. 

14
00:00:49.792 --> 00:00:54.647
We then have, in parentheses, n pairs of 
expressions, right? So I have a bracket, 

15
00:00:54.647 --> 00:00:58.562
because that's the convention. 
Semantically, it doesn't matter. 

16
00:00:58.562 --> 00:01:02.437
Just, syntactically, it's better styled 
at the bracket. 

17
00:01:02.437 --> 00:01:05.067
matter. 
You can use round parentheses if you 

18
00:01:05.067 --> 00:01:06.682
want. 
Then, 1 expression. 

19
00:01:06.682 --> 00:01:11.054
Then another expression and that branch, 
another one, another one. 

20
00:01:11.054 --> 00:01:15.785
The way this works is all these first 
ones are tests and all the second ones 

21
00:01:15.785 --> 00:01:20.348
are what to do if that test is true. 
So if the first one is true Then do the 

22
00:01:20.348 --> 00:01:22.940
second one. 
Else, if this is true, do this one. 

23
00:01:22.940 --> 00:01:25.911
Else, if this one. 
And you stop, and your result is the 

24
00:01:25.911 --> 00:01:30.373
first branch, where the thing on the left 
was true, and then you evaluate the thing 

25
00:01:30.373 --> 00:01:34.388
on the right, and that's your answer. 
Now, as a matter of style, it's very 

26
00:01:34.388 --> 00:01:38.800
important that your last branch typically 
be just true, which we write in Racket, 

27
00:01:38.800 --> 00:01:40.475
#t. 
This is your default case. 

28
00:01:40.475 --> 00:01:44.676
This is saying, in any other case, I want 
to evaluate this last expression, and 

29
00:01:44.676 --> 00:01:46.233
that's my. 
My answer. 

30
00:01:46.233 --> 00:01:50.857
If you do not do this and your last test 
expression also evaluates the false then 

31
00:01:50.857 --> 00:01:55.595
cond will return some strange void object 
which is a bad idea in Racket, it will 

32
00:01:55.595 --> 00:01:59.977
not produce an error here but probably 
it's going to return some result that 

33
00:01:59.977 --> 00:02:04.637
someone else doesn't want to use. 
And you'll end up confusing yourself. 

34
00:02:04.637 --> 00:02:08.626
So always make your last branch have as 
it's test a true, okay. 

35
00:02:08.626 --> 00:02:13.300
So let's go over here to DrRacket, here 
is the sum functions that I wrote in the 

36
00:02:13.300 --> 00:02:16.681
previous segment. 
So this first, this First one works on a 

37
00:02:16.681 --> 00:02:20.950
list of numbers that could have nested 
within them other lists of numbers and so 

38
00:02:20.950 --> 00:02:24.443
on, as deep as you want. 
And it's an error tab, anything in there 

39
00:02:24.443 --> 00:02:28.172
that's not a list or a number. 
And then the second version that if 

40
00:02:28.172 --> 00:02:32.155
there's some non-list or non-number 
nested somewhere on the list, we just 

41
00:02:32.155 --> 00:02:35.162
skip over it. 
[UNKNOWN] And we can rewrite each of 

42
00:02:35.162 --> 00:02:39.886
these just using cond, and so I'm going 
to do that just in a different file here 

43
00:02:39.886 --> 00:02:42.899
there we go. 
And, this will not be very difficult so 

44
00:02:42.899 --> 00:02:46.755
I'll call these sum 3 and sum 4 to 
continue what we were doing in the 

45
00:02:46.755 --> 00:02:51.123
previous section and I can have a cond 
which of course can have any number of 

46
00:02:51.123 --> 00:02:56.364
branches I want and the first branch will 
be that if the input X's is the No list, 

47
00:02:56.364 --> 00:03:04.276
the empty list, the results should be 0. 
Otherwise if the 1st element is a number, 

48
00:03:04.276 --> 00:03:11.905
so number of car of x's, then add the car 
of x's to the recursive sum of the cdr of 

49
00:03:11.905 --> 00:03:14.314
x's. 
That will end that branch. 

50
00:03:14.314 --> 00:03:19.553
Notice you can type round parentheses and 
if they match square brackets, Dr. 

51
00:03:19.553 --> 00:03:22.868
Racket will turn it into a square bracket 
for us. 

52
00:03:22.868 --> 00:03:28.207
And in any other case for this version, 
so for #t, I'll go ahead and assume that 

53
00:03:28.207 --> 00:03:32.786
the first element of xs is itself a list. 
So I know how to sum a list. 

54
00:03:32.786 --> 00:03:36.182
I call sum3, and then I need to sum3 the 
cdr of xs. 

55
00:03:36.182 --> 00:03:40.700
Codes that, and this should all be 
correct if we compare it to our other 

56
00:03:40.700 --> 00:03:45.289
version, I'm going to flip that over 
here, you'll see that we have the same 

57
00:03:45.289 --> 00:03:48.834
three cases. 
If it's null 0, the first number first 

58
00:03:48.834 --> 00:03:51.812
thing to list as a number, do this 
addition. 

59
00:03:51.812 --> 00:03:57.077
Otherwise do this addition but you'll 
probably agree with me that it's easier 

60
00:03:57.077 --> 00:04:02.366
to read laid out as this [UNKNOWN] we can 
see that three tests null, number and 

61
00:04:02.366 --> 00:04:07.782
true quite easily and then what to do in 
each case by the expression that follows 

62
00:04:07.782 --> 00:04:12.182
that test, k, so that's sum three now let 
me quickly do sum four. 

63
00:04:12.182 --> 00:04:17.557
It's the same idea. 
I'll have a con and if the list is empty 

64
00:04:17.557 --> 00:04:24.839
then return 0, if the first thing in the 
list is a number then, sorry, number car 

65
00:04:24.839 --> 00:04:28.480
of xs. 
And in fact it's exactly the same as 

66
00:04:28.480 --> 00:04:34.114
before, car of xs, sum4 For now cdr of 
x's, alright? Otherwise I have another 

67
00:04:34.114 --> 00:04:39.409
test in this version where I ask, well is 
x's a list? Because if it is, then I want 

68
00:04:39.409 --> 00:04:44.214
to do what I used to do just by the 
default assumption but this time I check 

69
00:04:44.214 --> 00:04:48.287
that it was the list. 
So you can see the difference between the 

70
00:04:48.287 --> 00:04:51.332
2 versions quite easily and in any other 
case. 

71
00:04:51.332 --> 00:04:57.565
Skip the car of xs and just cdr of xs and 
if you look back this is exactly like 

72
00:04:57.565 --> 00:05:01.960
some 2 just laid out nicely with the cond 
construct. 

73
00:05:01.960 --> 00:05:06.728
So that's our example. 
Now what I want to do is go back to the 

74
00:05:06.728 --> 00:05:10.345
slides and talk about one other issue, 
okay. 

75
00:05:10.345 --> 00:05:14.608
as before o sorry here's where I want to 
to go, okay. 

76
00:05:14.608 --> 00:05:19.297
So for both if and cond. 
I just didn't tell you this for if and 

77
00:05:19.297 --> 00:05:23.549
now I'm telling you for both. 
The test expression, that first 

78
00:05:23.549 --> 00:05:27.439
expression does not have to be true or 
false, #t or #f. 

79
00:05:27.439 --> 00:05:32.380
It turns out, it can be anything. 
It's never an error and it's fine. 

80
00:05:32.380 --> 00:05:37.537
So what is the semantic? The schemantics 
in Racket is that anything other than 

81
00:05:37.537 --> 00:05:41.224
false, counts as true. 
So, the only way to take the false 

82
00:05:41.224 --> 00:05:45.634
brancgh is if you have #f. 
But, to take the true branch you so not 

83
00:05:45.634 --> 00:05:49.152
need #t. 
You just need anything that is not #f. 

84
00:05:49.152 --> 00:05:53.988
This is very common in dyanamically type 
languages, some dynamicaaly type 

85
00:05:53.988 --> 00:05:58.808
languagees make other things false. 
Things like the empty list or the empty 

86
00:05:58.808 --> 00:06:02.031
string, or things like this. 
That's not true in Racket. 

87
00:06:02.031 --> 00:06:05.783
In Racket there's exactly one thing 
that's false, and that's #f. 

88
00:06:05.783 --> 00:06:09.850
Everything else counts as true. 
Now this makes no sense in a statically 

89
00:06:09.850 --> 00:06:13.047
typed language. 
In a statically typed language We would 

90
00:06:13.047 --> 00:06:17.252
insist that a conditional expression take 
something of type Buhl[UNKNOWN] for it's 

91
00:06:17.252 --> 00:06:20.087
first argument. 
Since everything has exactly one type, 

92
00:06:20.087 --> 00:06:23.517
there is no point in allowing anything to 
be in that first position. 

93
00:06:23.517 --> 00:06:26.379
But a language like Racket, you can You 
can do this. 

94
00:06:26.379 --> 00:06:29.022
Now, a lot of people consider this bad 
style. 

95
00:06:29.022 --> 00:06:31.960
A lot of people consider this convenient 
and okay. 

96
00:06:31.960 --> 00:06:36.264
And some people are kind of in between 
and say it depends on the situation. 

97
00:06:36.264 --> 00:06:41.152
I'm not a huge fan of this construct, but 
since it reinforces the idea That Racket 

98
00:06:41.152 --> 00:06:45.237
supports dynamic typing, I though I would 
show it to you. 

99
00:06:45.237 --> 00:06:51.177
So let's do couple quick examples here. 
so first of all let me just click run and 

100
00:06:51.177 --> 00:06:56.737
do something at the repel here. 
So what if I said if 34 then 14, l's 15. 

101
00:06:56.737 --> 00:07:00.552
Well since 34 is not false it must be 
true and I get 14. 

102
00:07:00.552 --> 00:07:05.358
Okay? So it's just that simple and I 
could say if empty list. 

103
00:07:05.358 --> 00:07:08.172
14 else 15, and I would get 14, and so 
on. 

104
00:07:08.172 --> 00:07:13.188
But if I saw hash false, then I get 15. 
So now, let me just paste in a quick 

105
00:07:13.188 --> 00:07:18.437
example of where this is useful, and I 
want to take the time to type it all out. 

106
00:07:18.437 --> 00:07:24.529
and you don't need this, okay? You could, 
you know, get by in, in Racket without 

107
00:07:24.529 --> 00:07:25.972
this feature. 
Woop. 

108
00:07:25.972 --> 00:07:30.606
There we go. 
So what this function does is it cou, it 

109
00:07:30.606 --> 00:07:37.278
takes in a list, just a list no nested 
list or anything, and counts how many 

110
00:07:37.278 --> 00:07:41.862
falses are in it. 
Okay? So let me just run this. 

111
00:07:41.862 --> 00:07:47.227
So we can see it in action. 
And so if I count falses of the list 34, 

112
00:07:47.227 --> 00:07:52.303
true, and hi, I should get 0. 
But if I add in here a couple falses, 

113
00:07:52.303 --> 00:07:58.102
maybe one at the beginning, one there, 
and how about a couple at the end. 

114
00:07:58.102 --> 00:08:01.814
Then I get 4. 
That's all it does, it counts how many 

115
00:08:01.814 --> 00:08:06.157
false's there are. 
Use cond, which we introduced here, and 

116
00:08:06.157 --> 00:08:10.657
we say that if the list is empty then 
there are 0 false's in it. 

117
00:08:10.657 --> 00:08:15.125
If the car of x's is not false, well here 
is one way to do that. 

118
00:08:15.125 --> 00:08:20.610
Right? If car of x's is anything other 
than false Then this test will be true. 

119
00:08:20.610 --> 00:08:24.009
And so we'll recursively count the falses 
in the cdr. 

120
00:08:24.009 --> 00:08:28.790
And in any other case, the only case 
that's left, it that the first thing in 

121
00:08:28.790 --> 00:08:32.477
the list was false. 
And then we would add 1 to count falses 

122
00:08:32.477 --> 00:08:36.903
of cdr of xes, okay? So that is an 
example of using this feature that 

123
00:08:36.903 --> 00:08:41.826
everything that is not #f is true. 
The only thing that is false is #f. But 

124
00:08:41.826 --> 00:08:46.371
the main idea in this segment was using 
cond for better style, and now we can use 

125
00:08:46.371 --> 00:08:50.753
it in all of our homework problems in 
Racket programming, rather than nested 

126
00:08:50.753 --> 00:08:51.585
if/then/else. 