WEBVTT

1
00:00:00.000 --> 00:00:04.195
[MUSIC]

2
00:00:04.195 --> 00:00:09.310
We continue our introduction to Racket
by learning about Racket lists.

3
00:00:09.310 --> 00:00:13.870
This will go quickly because Racket
lists work a lot like MLs lists.

4
00:00:13.870 --> 00:00:18.070
In particular,
the way we used ML lists in section one

5
00:00:18.070 --> 00:00:21.520
where we used the functions to
access the pieces of a list.

6
00:00:21.520 --> 00:00:25.059
So let me just go over the primitives and
then I'll write some examples, and

7
00:00:25.059 --> 00:00:28.897
again because it works a lot like an ML,
I suspect this will not be too surprising.

8
00:00:28.897 --> 00:00:33.310
In fact, it will be reassuring to see some
of the same ideas in a different language.

9
00:00:33.310 --> 00:00:37.390
The way we write the empty
list is with the word null.

10
00:00:37.390 --> 00:00:42.230
In ML, we would have written bracket
bracket, the empty list we write null.

11
00:00:42.230 --> 00:00:42.950
It's fine.

12
00:00:42.950 --> 00:00:45.830
By the way if you have seen scheme,
this is different.

13
00:00:45.830 --> 00:00:50.420
In scheme, you often wrote it parenthesis
parenthesis, that will not work in Racket.

14
00:00:50.420 --> 00:00:53.120
We will use null to write the empty list.

15
00:00:53.120 --> 00:00:56.605
If you want to build a list,
use the function cons.

16
00:00:56.605 --> 00:01:00.281
It won't surprise us the name Racket,
that's going to come first before

17
00:01:00.281 --> 00:01:04.290
the two arguments just like plus
comes before the arguments to plus.

18
00:01:04.290 --> 00:01:09.000
This is what in ML, we wrote with colon,
colon between the two arguments.

19
00:01:09.000 --> 00:01:14.250
So cons will take an element in a list and
create a list one element longer.

20
00:01:14.250 --> 00:01:18.970
If you have a list, and you want to get
the head, use this built in function car.

21
00:01:18.970 --> 00:01:23.764
And if you want to get the tail, use this
built-in function cdr, spelled C-D-R,

22
00:01:23.764 --> 00:01:25.040
pronounced cdr.

23
00:01:25.040 --> 00:01:27.950
This is what in ML was
the head function hd.

24
00:01:27.950 --> 00:01:30.070
And the tail function tl.

25
00:01:30.070 --> 00:01:33.590
And finally, to see if a list is empty or
not, we can use null?

26
00:01:34.790 --> 00:01:38.316
which we often just pronounced null or
if you prefer null.

27
00:01:38.316 --> 00:01:43.480
And this is what in ML was
the null function, N-U-L-L.

28
00:01:43.480 --> 00:01:47.900
So perhaps little confusing that we
write the empty list N-U-L-L and

29
00:01:47.900 --> 00:01:50.860
asked if a list is empty with the null?

30
00:01:50.860 --> 00:01:55.000
function, but every language has
it's different names for things.

31
00:01:55.000 --> 00:01:57.820
Just a couple of more things on
the slide that you see here.

32
00:01:57.820 --> 00:02:02.060
If you wanted to build a long list,
you don't have to say cons of three,

33
00:02:02.060 --> 00:02:04.300
of cons of four, of cons of five.

34
00:02:04.300 --> 00:02:08.550
There's a provided function list
that takes a bunch of arguments and

35
00:02:08.550 --> 00:02:10.610
makes a list out of these arguments.

36
00:02:10.610 --> 00:02:14.900
So if you pass at en expressions,
it evaluates those en expressions and

37
00:02:14.900 --> 00:02:17.280
makes a list of length en.

38
00:02:17.280 --> 00:02:21.030
We had similar built in,
in fact syntactic sugar and ML for

39
00:02:21.030 --> 00:02:22.630
when we wanted to do this.

40
00:02:22.630 --> 00:02:25.520
And finally, I should talk
about these names car and cdr.

41
00:02:25.520 --> 00:02:28.345
Why on earth would you
have the function for

42
00:02:28.345 --> 00:02:33.303
accessing the first part of a list we
called car and the rest of the list cdr?

43
00:02:33.303 --> 00:02:34.956
Don't try to figure this
out in terms of English.

44
00:02:34.956 --> 00:02:38.076
It's a historical accident
going back several decades, and

45
00:02:38.076 --> 00:02:41.976
some of the original machines that this
sort of language was implemented on,

46
00:02:41.976 --> 00:02:46.910
these things should not be called this but
it's too late we're stuck with them.

47
00:02:46.910 --> 00:02:51.275
Okay, so that's everything we need but it
will make a lot more sense after we just

48
00:02:51.275 --> 00:02:54.220
write a few functions,
simple things like were it used to.

49
00:02:54.220 --> 00:02:55.690
So lets first right a function.

50
00:02:55.690 --> 00:03:01.170
I have a comment here,
sum all the numbers in a list, okay?

51
00:03:01.170 --> 00:03:08.000
So remember, I could define a variable
sum and then lambda taken a list xs.

52
00:03:08.000 --> 00:03:13.450
I prefer instead the syntactic sugar
version of doing exactly the same thing,

53
00:03:13.450 --> 00:03:16.570
so I added that parenthesis and
then the arguments.

54
00:03:16.570 --> 00:03:20.410
This is a one argument function, and now
at this point we are very comfortable at

55
00:03:20.410 --> 00:03:22.970
the recursive solution to this function.

56
00:03:22.970 --> 00:03:27.130
If the list is empty, so
I'm calling the null?

57
00:03:27.130 --> 00:03:31.178
function with my argument, then 0,
it's the second argument to if.

58
00:03:31.178 --> 00:03:34.017
The 3rd argument to if
will be a function car,

59
00:03:34.017 --> 00:03:39.275
call the function plus with the result
of calling the function car on xs.

60
00:03:39.275 --> 00:03:43.010
I.e., the head of the list with calling

61
00:03:43.010 --> 00:03:47.399
sum recursively with the cdr of the list,
okay?

62
00:03:47.399 --> 00:03:50.607
So that's the end of the called a cdr,
the end of the call to sum,

63
00:03:50.607 --> 00:03:54.210
the end of the call to plus, the end
of the if, and the end of the define.

64
00:03:54.210 --> 00:03:56.550
If you're not use the languages like this,

65
00:03:56.550 --> 00:03:59.620
you might find it funny that I
ended with so many parentheses.

66
00:03:59.620 --> 00:04:01.610
It's incredibly natural,
you get used to it.

67
00:04:01.610 --> 00:04:05.140
It's exactly that I have to
finish all these calls and

68
00:04:05.140 --> 00:04:08.660
then I have a perfectly
good syntactic function.

69
00:04:08.660 --> 00:04:11.189
And I could go ahead and run this, and

70
00:04:11.189 --> 00:04:16.180
try sum of how about the list with
3 4 5 6, and I would get 18, okay?

71
00:04:17.770 --> 00:04:18.700
No problem.

72
00:04:18.700 --> 00:04:22.210
By the way, we'll talk about this much,
much more, but

73
00:04:22.210 --> 00:04:24.230
if you do something like this,

74
00:04:24.230 --> 00:04:28.340
this would quote on quote compile because
there's no type checker to stop us.

75
00:04:28.340 --> 00:04:30.170
But we'll get an error and

76
00:04:30.170 --> 00:04:33.870
DrRacket even tries to tell us where
this error occur in the code, and

77
00:04:33.870 --> 00:04:38.890
it's says that plus expects a number and
you gave it a string hi, okay?

78
00:04:38.890 --> 00:04:40.990
So that's our first example
of a list function.

79
00:04:40.990 --> 00:04:42.540
Let's do a couple more.

80
00:04:42.540 --> 00:04:45.410
You know my favorite which is append.

81
00:04:45.410 --> 00:04:48.920
It turns out append is built into Racket.

82
00:04:48.920 --> 00:04:53.026
We could shadow it but I find shadowing
confusing ,so how about I call it

83
00:04:53.026 --> 00:04:55.780
my-append taking into lists xs and ys.

84
00:04:55.780 --> 00:04:59.260
By the way in the previous segment and
this one, you'll notice I sometimes

85
00:04:59.260 --> 00:05:03.680
have hyphens in my variable names or
here in my function name.

86
00:05:03.680 --> 00:05:07.780
That's perfectly allowed in Racket, it's
just a syntactic thing to get used to.

87
00:05:07.780 --> 00:05:11.770
In many languages, we prefer to
write it like this or like this.

88
00:05:11.770 --> 00:05:15.750
All of these work, it's just a bit
more of the convention in Racket

89
00:05:15.750 --> 00:05:20.130
to separate the words of our variables and
function names with a hyphen.

90
00:05:20.130 --> 00:05:23.260
Every language is entitled
to its own conventions.

91
00:05:23.260 --> 00:05:28.040
Okay, my-append is a function
that takes two lists, xs and ys.

92
00:05:28.040 --> 00:05:33.440
If xs is empty, return ys otherwise cons,

93
00:05:33.440 --> 00:05:38.540
the first element of xs, on to the result

94
00:05:38.540 --> 00:05:43.040
of appending the rest of xs on to ys.

95
00:05:43.040 --> 00:05:45.710
It was beautiful in ML,
it's beautiful in Racket.

96
00:05:45.710 --> 00:05:48.310
Let me show you those
closed parentheses again,

97
00:05:48.310 --> 00:05:50.760
finish the recursive called my-append.

98
00:05:50.760 --> 00:05:55.200
There were call to cons,
the conditional, and the define.

99
00:05:55.200 --> 00:05:58.030
This will work great, so that's append.

100
00:05:58.030 --> 00:06:00.320
And let's do one more, how about map?

101
00:06:00.320 --> 00:06:03.960
So we see something with a higher
order function, works just fine.

102
00:06:03.960 --> 00:06:07.380
Again, this one is built in,
so how about I call it my-map.

103
00:06:07.380 --> 00:06:11.378
Map as an ML takes in two arguments,
f and xs.

104
00:06:11.378 --> 00:06:14.629
Remember in Racket, this is really
a two argument functions, so

105
00:06:14.629 --> 00:06:16.420
this isn't toppling or carrying.

106
00:06:16.420 --> 00:06:18.900
And we know how map should work.

107
00:06:18.900 --> 00:06:22.100
It should apply after
every element of xs and

108
00:06:22.100 --> 00:06:25.660
return a list of the same length
with the result of those calls.

109
00:06:25.660 --> 00:06:31.840
So if you have a zero length, zero list,
you end up with null, all right?

110
00:06:31.840 --> 00:06:34.340
So I asked here, is xs null?

111
00:06:34.340 --> 00:06:36.780
If it is, I want to return the empty list.

112
00:06:36.780 --> 00:06:43.360
I could have written xs here, but I wanted
to show using the null value, okay?

113
00:06:43.360 --> 00:06:46.820
The variable null is essentially
bound to the empty list.

114
00:06:46.820 --> 00:06:50.920
Otherwise cons f of car of xs.

115
00:06:50.920 --> 00:06:52.440
All right, so what have I done so far?

116
00:06:52.440 --> 00:06:57.940
I got the head of the list and
I called f with that head of the list.

117
00:06:57.940 --> 00:07:00.410
So that's my first argument to cons.

118
00:07:00.410 --> 00:07:02.050
And then my second argument to cons,

119
00:07:02.050 --> 00:07:04.810
I can hit return here if I
want it to indent nicely.

120
00:07:04.810 --> 00:07:09.120
Is to call map recursively with
the same f and the rest of the list.

121
00:07:09.120 --> 00:07:14.610
And the call to cdr, call to my-map,
call to cons, the if, and the define.

122
00:07:15.750 --> 00:07:18.460
Okay, so that's map and
we can run all this,

123
00:07:18.460 --> 00:07:22.660
and we'll see if we do that I do
now have a function my-append.

124
00:07:22.660 --> 00:07:24.680
The ripple will say, that's a procedure.

125
00:07:24.680 --> 00:07:26.880
The same way ML likes to
say that's a function.

126
00:07:26.880 --> 00:07:29.635
I'm not going to print
anything else out for you.

127
00:07:29.635 --> 00:07:31.300
My-map is also a procedure.

128
00:07:31.300 --> 00:07:37.170
If I try to call my-map with just
one argument like lambda x plus x1,

129
00:07:37.170 --> 00:07:42.090
this will be an error, and that's
because my-map expects two arguments.

130
00:07:42.090 --> 00:07:45.430
But, okay, let's go ahead and
call my-map with two arguments.

131
00:07:45.430 --> 00:07:48.985
In fact, let's define
a variable foo to be the result

132
00:07:48.985 --> 00:07:53.808
of calling my-map with this little
anonymous function, plus x and 1.

133
00:07:53.808 --> 00:07:56.832
So what I've written just here,
you see highlighted in the gray,

134
00:07:56.832 --> 00:07:58.291
is just an anonymous function.

135
00:07:58.291 --> 00:08:02.144
Takes in one argument,
x that it's in its own parentheses and

136
00:08:02.144 --> 00:08:05.120
the function body is a call
to plus with x and 1.

137
00:08:05.120 --> 00:08:09.990
And then for my second argument to my map,
how about cons 3

138
00:08:09.990 --> 00:08:14.740
onto cons 4 onto cons 5 onto null.

139
00:08:14.740 --> 00:08:18.940
Of course I could have used the list
function to write this more concisely but

140
00:08:18.940 --> 00:08:21.280
I want you to get used
to lots of parentheses.

141
00:08:21.280 --> 00:08:22.480
This is not hard to read.

142
00:08:22.480 --> 00:08:24.970
That's the list containing 3, 4, and 5.

143
00:08:24.970 --> 00:08:29.160
Close the call to my map,
close the call to define, hit return.

144
00:08:29.160 --> 00:08:30.050
That worked just fine.

145
00:08:30.050 --> 00:08:31.690
The ripple doesn't tell us anything.

146
00:08:31.690 --> 00:08:36.660
It was happy to do that definition,
but if I asked to evaluate foo,

147
00:08:36.660 --> 00:08:40.300
it will tell me that
that is the list 4 5 6.

148
00:08:40.300 --> 00:08:46.360
The way the ripple prints lists, is with
this quote, and then the list elements.

149
00:08:46.360 --> 00:08:51.142
And that's fine that
really is the list (cons 4

150
00:08:51.142 --> 00:08:56.970
(cons 5 (cons 6 null) and
we'll see that because if I evaluate this,

151
00:08:56.970 --> 00:08:59.910
I will get the same thing
printed by the ripple.

152
00:08:59.910 --> 00:09:01.720
So that's our practice
with list functions,

153
00:09:01.720 --> 00:09:03.550
again they work a lot like in ML.

154
00:09:03.550 --> 00:09:06.560
They're just as convenient and
powerful, recursion is just as useful.