WEBVTT

1
00:00:04.070 --> 00:00:08.995
We can now move on to our next closure idiom which are callbacks.

2
00:00:08.995 --> 00:00:13.470
Callback style programming is very common these days.

3
00:00:13.470 --> 00:00:18.900
The idiom we're using here is that someone writes a library that takes in from

4
00:00:18.900 --> 00:00:25.440
clients functions that should be called later when some sort of event occurs.

5
00:00:25.440 --> 00:00:27.540
So example libraries are things that

6
00:00:27.540 --> 00:00:32.970
control the keyboard or the mouse or when data arrives from the network.

7
00:00:32.970 --> 00:00:35.309
So programs may want to know.

8
00:00:35.309 --> 00:00:36.870
may want to act on,

9
00:00:36.870 --> 00:00:38.985
keys being pressed on the keyboard.

10
00:00:38.985 --> 00:00:40.925
And so what they will do is pass to

11
00:00:40.925 --> 00:00:45.955
the library code that should execute when a key is pressed.

12
00:00:45.955 --> 00:00:49.995
So we really want first class functions for this so we can pass in

13
00:00:49.995 --> 00:00:54.965
some code that should be called later when an event occurs.

14
00:00:54.965 --> 00:00:57.009
And that's called a callback.

15
00:00:57.009 --> 00:01:02.715
That doesn't have to be this out external data like a keyboard or data from the network.

16
00:01:02.715 --> 00:01:04.875
Sometimes we write games in this style.

17
00:01:04.875 --> 00:01:09.630
Some player in the game maybe an automatic player should register

18
00:01:09.630 --> 00:01:11.310
code that should be called when it's

19
00:01:11.310 --> 00:01:15.475
that player's turn to move around in some virtual world.

20
00:01:15.475 --> 00:01:19.560
Now the way these library should work is they should accept multiple callbacks.

21
00:01:19.560 --> 00:01:23.610
There may be many different parts of the program that all need to know when keys are

22
00:01:23.610 --> 00:01:28.100
pressed on the keyboard and they need different data to act on.

23
00:01:28.100 --> 00:01:30.720
So we don't just need to pass first class functions.

24
00:01:30.720 --> 00:01:34.455
They need to be closures so that each client passing

25
00:01:34.455 --> 00:01:38.490
in a callback can use the private data,

26
00:01:38.490 --> 00:01:42.015
the bindings in the environment where the function was defined,

27
00:01:42.015 --> 00:01:46.100
to have access to the data it's going to need when the callback executes.

28
00:01:46.100 --> 00:01:48.500
So this is where closures are really valuable.

29
00:01:48.500 --> 00:01:52.245
It's important that that private data not show up in the type of the callback

30
00:01:52.245 --> 00:01:57.170
because the library implementer has no idea what that data should be.

31
00:01:57.170 --> 00:01:59.220
Now object-oriented languages for those of

32
00:01:59.220 --> 00:02:01.276
you that are used to them also handle callbacks,

33
00:02:01.276 --> 00:02:02.715
they do it with objects.

34
00:02:02.715 --> 00:02:05.670
I find closure is just as elegant if not more

35
00:02:05.670 --> 00:02:10.050
elegant and you can learn the idea of callbacks either way.

36
00:02:10.050 --> 00:02:15.200
So since we're setting functional languages here we'll do it that way.

37
00:02:15.200 --> 00:02:17.040
So we are going to use mutable state in

38
00:02:17.040 --> 00:02:20.280
our library and I'm going to argue that's appropriate here.

39
00:02:20.280 --> 00:02:25.615
Our library is going to keep track of all the callbacks that have been registered,

40
00:02:25.615 --> 00:02:29.220
all the code that should execute when an event occurs.

41
00:02:29.220 --> 00:02:31.995
And when a new one gets registered we really do want to

42
00:02:31.995 --> 00:02:35.155
update state so that we can have more things,

43
00:02:35.155 --> 00:02:39.870
you know, we can keep track of what we are supposed to do.

44
00:02:39.870 --> 00:02:44.910
So our library is going to maintain that mutable state for what callbacks are

45
00:02:44.910 --> 00:02:47.640
there and it's going to provide a function for

46
00:02:47.640 --> 00:02:50.885
adding a new one to that mutable collection.

47
00:02:50.885 --> 00:02:53.610
Now real library of course would have lots of other features

48
00:02:53.610 --> 00:02:56.655
like for removing a callback that was previously added.

49
00:02:56.655 --> 00:03:00.120
And we're just going to take a very simple approach that what

50
00:03:00.120 --> 00:03:04.355
clients are going to pass us are functions of type int arrow unit.

51
00:03:04.355 --> 00:03:08.840
So you can think of that int as encoding which key on the keyboard was pressed.

52
00:03:08.840 --> 00:03:10.060
Maybe A is one,

53
00:03:10.060 --> 00:03:12.350
B is two, that sort of thing.

54
00:03:12.350 --> 00:03:19.255
So the only public interface to our library is going to be this function onKeyEvent.

55
00:03:19.255 --> 00:03:24.270
It's going to say when a key event occurs you want me to call

56
00:03:24.270 --> 00:03:27.420
this int arrow unit you passed and I will give back

57
00:03:27.420 --> 00:03:31.140
to you the int corresponding to what key was pressed.

58
00:03:31.140 --> 00:03:33.850
So onKeyEvent takes an int arrow unit,

59
00:03:33.850 --> 00:03:35.261
there's no result here,

60
00:03:35.261 --> 00:03:37.900
the unit type has no useful content.

61
00:03:37.900 --> 00:03:43.825
And the result of onKeyEvent is just the side effect that I'll call you back later.

62
00:03:43.825 --> 00:03:45.625
So there is no useful result.

63
00:03:45.625 --> 00:03:47.855
So the result here is also unit.

64
00:03:47.855 --> 00:03:51.270
Okay? So that's the entire interface.

65
00:03:51.270 --> 00:03:55.385
Now we just need a library that will implement that interface.

66
00:03:55.385 --> 00:03:59.645
So here it is, it's in the code file as well but it all fits on the slide.

67
00:03:59.645 --> 00:04:03.225
The library is going to internally maintain

68
00:04:03.225 --> 00:04:09.285
a mutable reference that holds a list of all the callbacks that have been registered.

69
00:04:09.285 --> 00:04:12.540
So we'll initialize that mutable reference to

70
00:04:12.540 --> 00:04:16.860
have contents empty list because none have been added yet.

71
00:04:16.860 --> 00:04:23.654
Then when someone calls onKeyEvent with a function we will assign to cbs,

72
00:04:23.654 --> 00:04:28.320
for callbacks, this list which is made out

73
00:04:28.320 --> 00:04:33.295
of consing f onto the previous contents of cbs.

74
00:04:33.295 --> 00:04:37.944
So this is updating cbs to refer to a list with one more element than it used to.

75
00:04:37.944 --> 00:04:42.410
Perfect. Then when some event actually occurs,

76
00:04:42.410 --> 00:04:45.200
so you know the key is actually pressed.

77
00:04:45.200 --> 00:04:49.435
Let's assume that this function on event is called with a number.

78
00:04:49.435 --> 00:04:53.060
I'm not actually going to show you in ML how to actually hook up to the keyboard.

79
00:04:53.060 --> 00:04:54.840
We're going to fake it through this function,

80
00:04:54.840 --> 00:04:56.385
we're just simulating the idea.

81
00:04:56.385 --> 00:04:58.245
And all this function does,

82
00:04:58.245 --> 00:05:00.345
I will not explain the details to you,

83
00:05:00.345 --> 00:05:03.840
is take the contents of cbs as you see here with

84
00:05:03.840 --> 00:05:07.610
the exclamation point and go through and call each of the functions.

85
00:05:07.610 --> 00:05:11.250
Right? So for each function in that list we will call it

86
00:05:11.250 --> 00:05:15.525
with i that's exactly what a callback library is supposed to do.

87
00:05:15.525 --> 00:05:17.235
So that's the library.

88
00:05:17.235 --> 00:05:23.895
And remember all clients are going to do is call onKeyEvent with appropriate functions.

89
00:05:23.895 --> 00:05:27.540
So here are a couple example clients

90
00:05:27.540 --> 00:05:32.245
and they're always going to pass enclosures that do what they need to do.

91
00:05:32.245 --> 00:05:35.030
So here's my first client here OnKeyEvent.

92
00:05:35.030 --> 00:05:38.310
It actually ignores the integer it's given and all it

93
00:05:38.310 --> 00:05:41.975
does is increment this timesPressed variable.

94
00:05:41.975 --> 00:05:45.215
So the reference that timesPressed refers to.

95
00:05:45.215 --> 00:05:47.982
So timesPressed refers to an int ref,

96
00:05:47.982 --> 00:05:53.405
the contents are initially zero and we register here a callback that every

97
00:05:53.405 --> 00:05:56.055
time it's called it takes timesPressed and

98
00:05:56.055 --> 00:05:59.610
updates it to previous contents of timesPressed plus one.

99
00:05:59.610 --> 00:06:04.560
So this is a logger that is counting how many times keys have been pressed.

100
00:06:04.560 --> 00:06:09.985
Here I have a function that every time you call it registers a callback.

101
00:06:09.985 --> 00:06:12.470
And what it does is when you call printIfPressed with

102
00:06:12.470 --> 00:06:16.319
i it registers a callback that says i,

103
00:06:16.319 --> 00:06:17.935
if you give me back j,

104
00:06:17.935 --> 00:06:20.495
so j was the key that was pressed.

105
00:06:20.495 --> 00:06:23.990
If i equals j I'll print out a message saying you pressed i,

106
00:06:23.990 --> 00:06:26.250
otherwise I'll do nothing.

107
00:06:26.250 --> 00:06:31.583
I only care about the cases where it's i that was pressed.

108
00:06:31.583 --> 00:06:32.865
All right. So that's all good.

109
00:06:32.865 --> 00:06:34.425
Over here in the code I have

110
00:06:34.425 --> 00:06:38.310
all the code I just showed you exactly how I showed it to you.

111
00:06:38.310 --> 00:06:42.060
And then here at the bottom I used that function printIfPressed

112
00:06:42.060 --> 00:06:46.515
to add four more callbacks one for four.

113
00:06:46.515 --> 00:06:49.320
So that will print out you pressed four if indeed four was pressed,

114
00:06:49.320 --> 00:06:51.989
one for 11, one for 23, one for four.

115
00:06:51.989 --> 00:06:56.940
And so with this one up here that keeps track of how many have been pressed we'll have

116
00:06:56.940 --> 00:07:00.060
five total callbacks registered because we call

117
00:07:00.060 --> 00:07:03.945
onKeyEvent five times so that list will have five things in it.

118
00:07:03.945 --> 00:07:09.330
So let's just load it all up and it all loads it's all fine.

119
00:07:09.330 --> 00:07:15.559
We can see that by the time the REPL prints cbs the contents actually is five functions,

120
00:07:15.559 --> 00:07:17.165
it's a list with five elements.

121
00:07:17.165 --> 00:07:19.225
And nothing has been printed yet.

122
00:07:19.225 --> 00:07:25.080
And if I ask timesPressed I get zero because there haven't been any events yet.

123
00:07:25.080 --> 00:07:28.705
So now we're going to simulate events happening with this onEvent function.

124
00:07:28.705 --> 00:07:31.470
So when I call onEvent with a number it's going to pass

125
00:07:31.470 --> 00:07:35.455
that number back to all the closures that were registered with OnKeyEvent.

126
00:07:35.455 --> 00:07:40.082
So if I pass in 11 it prints you pressed 11,

127
00:07:40.082 --> 00:07:44.313
because one of those five callbacks chose to print that.

128
00:07:44.313 --> 00:07:46.650
The other printIfPressed did nothing.

129
00:07:46.650 --> 00:07:50.785
TimesPressed by the way is now one.

130
00:07:50.785 --> 00:07:52.650
So it really did call that code.

131
00:07:52.650 --> 00:07:57.610
We could do onEvent 79, nothing gets printed.

132
00:07:57.610 --> 00:07:58.945
No one wanted to print that.

133
00:07:58.945 --> 00:08:00.814
We could do onEvent four,

134
00:08:00.814 --> 00:08:03.630
that prints it twice because two of

135
00:08:03.630 --> 00:08:07.385
our callbacks chose to print that string. So that's fine.

136
00:08:07.385 --> 00:08:11.065
We could do onEvent 23, it prints once.

137
00:08:11.065 --> 00:08:14.970
We could at any time ask timesPress that's been incremented every

138
00:08:14.970 --> 00:08:19.214
time thanks to one of our callbacks and four because we did four events.

139
00:08:19.214 --> 00:08:21.520
I think we did 11, 79,

140
00:08:21.520 --> 00:08:25.000
four, and 23. All right? So that's callbacks.