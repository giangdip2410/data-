WEBVTT

1
00:00:04.280 --> 00:00:08.852
In this segment I'm going to show you a new language construct.

2
00:00:08.852 --> 00:00:10.608
ML has anonymous functions,

3
00:00:10.608 --> 00:00:14.185
these are functions you can define without using a fun binding.

4
00:00:14.185 --> 00:00:17.680
But to do that, I want to motivate why we would want such a thing.

5
00:00:17.680 --> 00:00:19.949
They work very well, they're great style,

6
00:00:19.949 --> 00:00:23.770
they're more convenient usually when using higher order functions.

7
00:00:23.770 --> 00:00:26.380
So I'm gonna sneak up on this a little bit and show you

8
00:00:26.380 --> 00:00:30.010
a few versions before I actually get to anonymous functions.

9
00:00:30.010 --> 00:00:33.540
I have a similar example we've been using in the past to have this function

10
00:00:33.540 --> 00:00:37.420
n_times we're now very familiar with and then I have a use of it,

11
00:00:37.420 --> 00:00:40.600
this function triple_n_times that just wants to

12
00:00:40.600 --> 00:00:44.230
take n and x and return three to the n times x.

13
00:00:44.230 --> 00:00:50.732
So it calls its bodies just n_times with this helper function triple n and x.

14
00:00:50.732 --> 00:00:53.800
And this segment is really all about that helper function.

15
00:00:53.800 --> 00:00:56.770
And the first thing, I hope at least a few of you noticed,

16
00:00:56.770 --> 00:01:01.445
is that it doesn't make a lot of sense to define this helper function up at top level.

17
00:01:01.445 --> 00:01:05.135
This is really only a helper function for triple_n_times.

18
00:01:05.135 --> 00:01:10.600
So, it would be better style unless we needed a triple somewhere else in our program to

19
00:01:10.600 --> 00:01:13.300
define it as a local helper function like

20
00:01:13.300 --> 00:01:16.715
this and that's the second version I want to show you.

21
00:01:16.715 --> 00:01:20.290
Okay. So this second version is better style than

22
00:01:20.290 --> 00:01:25.570
the first version but now we might go even further and we might say,

23
00:01:25.570 --> 00:01:30.200
you know, triple isn't really needed in this entire body.

24
00:01:30.200 --> 00:01:32.980
If we want to give things the smallest scope they

25
00:01:32.980 --> 00:01:37.145
need we only need triple right in there.

26
00:01:37.145 --> 00:01:39.160
Okay. So let's try that.

27
00:01:39.160 --> 00:01:45.215
This is going to look a little silly but I promise you it's going to work just fine.

28
00:01:45.215 --> 00:01:51.879
Okay. What I'm going to do is right here in the first argument to n_times,

29
00:01:51.879 --> 00:01:58.525
I'm going to put the entire let expression.

30
00:01:58.525 --> 00:02:02.425
Now let's just make sure we understand what's going on here.

31
00:02:02.425 --> 00:02:03.970
I have a call to triple n_times,

32
00:02:03.970 --> 00:02:06.130
I have a function I'm defining triple n times,

33
00:02:06.130 --> 00:02:08.075
this is its body.

34
00:02:08.075 --> 00:02:09.220
It's a call to n*,

35
00:02:09.220 --> 00:02:11.530
n* takes three arguments.

36
00:02:11.530 --> 00:02:14.626
The first argument, is the result of this led expression.

37
00:02:14.626 --> 00:02:17.660
The second argument, is n. The third argument is x.

38
00:02:17.660 --> 00:02:19.870
So how do we evaluate this let expression?

39
00:02:19.870 --> 00:02:25.165
What we do is we define a local function, triple,

40
00:02:25.165 --> 00:02:28.600
and then right here we return from the let expression,

41
00:02:28.600 --> 00:02:30.565
the result of the lead expression,

42
00:02:30.565 --> 00:02:35.560
is that function we define and so that's what we end up passing to n*.

43
00:02:35.560 --> 00:02:38.665
This works great and it actually indicates

44
00:02:38.665 --> 00:02:43.480
fairly nicely that the only place we need this function is right here.

45
00:02:43.480 --> 00:02:46.499
All we're doing with it is passing it to n*.

46
00:02:46.499 --> 00:02:48.520
So this works.

47
00:02:48.520 --> 00:02:53.830
This is not good style but it's only because ML has a construct that I've never

48
00:02:53.830 --> 00:02:56.770
shown you that I'm about to and that

49
00:02:56.770 --> 00:03:00.280
is better than using a let expression in this strange way.

50
00:03:00.280 --> 00:03:03.610
So I really like the function is only to find right where we need it.

51
00:03:03.610 --> 00:03:08.525
I just have a better construct for it and that is to not give it a name at all.

52
00:03:08.525 --> 00:03:13.735
So one thing you might think you could do would be something like this.

53
00:03:13.735 --> 00:03:15.754
Right. That looks great,

54
00:03:15.754 --> 00:03:21.065
I want to call n* with this function defined right here n and X.

55
00:03:21.065 --> 00:03:23.599
Who needs a let expression just to return the variable?

56
00:03:23.599 --> 00:03:27.400
And this is the right idea but this will not compile and

57
00:03:27.400 --> 00:03:32.315
the reason why it won't compile is this is a binding not an expression.

58
00:03:32.315 --> 00:03:35.650
What we need is some expression that represents

59
00:03:35.650 --> 00:03:40.390
a function that is a function as an expression not as a fun binding.

60
00:03:40.390 --> 00:03:44.575
So it's a little bit different syntax but the idea is just right here.

61
00:03:44.575 --> 00:03:46.544
So here's the difference in syntax,

62
00:03:46.544 --> 00:03:49.251
the key word is f-n not f-u-n,

63
00:03:49.251 --> 00:03:51.315
so you get rid of the U.

64
00:03:51.315 --> 00:03:54.849
We do not write a name for the function,

65
00:03:54.849 --> 00:03:59.510
after all, we have this name triple, we never used it.

66
00:03:59.510 --> 00:04:02.650
All we did was define a function and pass it to n*.

67
00:04:02.650 --> 00:04:05.890
In n* it's called f. So if we don't need a name

68
00:04:05.890 --> 00:04:09.294
for the function let's not give it one and with f_n bindings,

69
00:04:09.294 --> 00:04:11.380
these function expressions, excuse me,

70
00:04:11.380 --> 00:04:14.785
they're not bindings they're expressions you cannot give a name.

71
00:04:14.785 --> 00:04:17.245
These are for defining anonymous functions.

72
00:04:17.245 --> 00:04:18.705
It's actually a rather clever name.

73
00:04:18.705 --> 00:04:25.075
Anonymous is an English word for does not have a name or is has an unknown name.

74
00:04:25.075 --> 00:04:26.320
Instead of running equals,

75
00:04:26.320 --> 00:04:27.865
we write this double arrow.

76
00:04:27.865 --> 00:04:30.735
It's just syntax, that was the choice of the people who designed them

77
00:04:30.735 --> 00:04:33.875
now and then the body and for some clarity here,

78
00:04:33.875 --> 00:04:38.590
how about I put this in parentheses and now this is the version I like the most.

79
00:04:38.590 --> 00:04:41.446
We now have an anonymous function defined right here.

80
00:04:41.446 --> 00:04:45.577
This is the function that takes an argument X. X is not the name of the function,

81
00:04:45.577 --> 00:04:46.918
it does not have a name.

82
00:04:46.918 --> 00:04:49.359
It's the argument and it returns 3*X.

83
00:04:49.359 --> 00:04:51.325
That's exactly what I want.

84
00:04:51.325 --> 00:04:57.130
I want the body of triple n* to be a call to n* with this function as the first argument,

85
00:04:57.130 --> 00:04:59.474
n is the second, X is the third.

86
00:04:59.474 --> 00:05:04.390
And so that is us sneaking up on anonymous functions and seeing what they're really great

87
00:05:04.390 --> 00:05:06.250
for which is when you are using

88
00:05:06.250 --> 00:05:09.535
first class functions and you're only ever going to use this function in one place,

89
00:05:09.535 --> 00:05:12.086
right here, so why bother giving it a name,

90
00:05:12.086 --> 00:05:15.360
let's just define it right where we need it.

91
00:05:15.360 --> 00:05:17.710
Okay. So, let's go back to the slides and see

92
00:05:17.710 --> 00:05:21.040
that progression one more time and then talk a little bit more about

93
00:05:21.040 --> 00:05:24.910
the difference between these anonymous functions

94
00:05:24.910 --> 00:05:27.220
and the bindings we've been using previously.

95
00:05:27.220 --> 00:05:29.645
Okay. So we started with this version where

96
00:05:29.645 --> 00:05:32.680
helper function triple was to find the top level.

97
00:05:32.680 --> 00:05:36.820
I said a much better way would be to at least put it inside,

98
00:05:36.820 --> 00:05:38.035
the definition of the function,

99
00:05:38.035 --> 00:05:40.990
inside the body of triple n* and then I

100
00:05:40.990 --> 00:05:44.170
said we don't need it for the entire body of triple n*.

101
00:05:44.170 --> 00:05:47.989
We only need it right in that first position.

102
00:05:47.989 --> 00:05:52.005
So I move the function definition to exactly where I needed it.

103
00:05:52.005 --> 00:05:55.705
Then I showed you that you cannot just get rid of the let.

104
00:05:55.705 --> 00:05:58.222
You cannot put a function binding here.

105
00:05:58.222 --> 00:05:59.680
You have to put an expression,

106
00:05:59.680 --> 00:06:01.390
let expressions are expressions,

107
00:06:01.390 --> 00:06:02.969
function bindings or not,

108
00:06:02.969 --> 00:06:06.340
but what we do now have new in this segment is

109
00:06:06.340 --> 00:06:07.930
the expression form of

110
00:06:07.930 --> 00:06:10.120
an anonymous function and that's what we

111
00:06:10.120 --> 00:06:12.820
finally saw in that last version I liked the most.

112
00:06:12.820 --> 00:06:14.704
The syntax is very simple you write f_n,

113
00:06:14.704 --> 00:06:17.920
you write the argument which can be a pattern in

114
00:06:17.920 --> 00:06:22.655
general.Here we just have one variable for the one argument,

115
00:06:22.655 --> 00:06:24.115
a double arrow if you will,

116
00:06:24.115 --> 00:06:27.235
equal greater than sign and then the body of the function.

117
00:06:27.235 --> 00:06:31.600
So is a function that takes one argument and returns three times that argument.

118
00:06:31.600 --> 00:06:35.010
There is no name for the function, just the argument.

119
00:06:35.010 --> 00:06:37.690
Okay. So the most common use of

120
00:06:37.690 --> 00:06:42.460
anonymous functions is when we're passing an argument to a higher order function.

121
00:06:42.460 --> 00:06:46.659
There's no reason to give it a name if this is the only place we're going to use it but

122
00:06:46.659 --> 00:06:51.985
the one thing you cannot do with anonymous functions is to find recursive functions.

123
00:06:51.985 --> 00:06:55.630
If you need a recursive function then you have to use

124
00:06:55.630 --> 00:06:59.495
a function binding with either a let expression or at top level.

125
00:06:59.495 --> 00:07:02.200
And that's exactly because the way we define

126
00:07:02.200 --> 00:07:05.530
recursive functions in ML is by calling the function

127
00:07:05.530 --> 00:07:09.040
itself using the name of the function and if our function doesn't

128
00:07:09.040 --> 00:07:13.210
have a name then we don't have a way to call it recursively.

129
00:07:13.210 --> 00:07:14.559
So, that's pretty interesting.

130
00:07:14.559 --> 00:07:20.980
Anonymous functions do everything other function bindings do except recursion and that is

131
00:07:20.980 --> 00:07:24.220
interesting because if it were not for recursion

132
00:07:24.220 --> 00:07:28.490
then fun bindings would actually be syntactic sugar.

133
00:07:28.490 --> 00:07:33.879
Let's look back again at a very simple function like fun triple X equals 3*X.

134
00:07:33.879 --> 00:07:36.430
We could have, even at top level,

135
00:07:36.430 --> 00:07:38.330
define that as val triple.

136
00:07:38.330 --> 00:07:42.610
I just want to introduce a variable triple and what that variable will be

137
00:07:42.610 --> 00:07:48.220
bound to is this function that I've defined via an anonymous function.

138
00:07:48.220 --> 00:07:53.470
That makes perfect sense and we could think of this first function binding as

139
00:07:53.470 --> 00:07:59.935
syntactic sugar for the second variable binding as long as triple is not recursive.

140
00:07:59.935 --> 00:08:03.040
If the body of triple itself caused triple then

141
00:08:03.040 --> 00:08:06.010
this unsugared version won't

142
00:08:06.010 --> 00:08:09.610
work because we won't have the name to do the recursive call.

143
00:08:09.610 --> 00:08:12.550
And, in fact, over here in the code I showed you I have

144
00:08:12.550 --> 00:08:16.555
another example of this that I can write out real quickly.

145
00:08:16.555 --> 00:08:21.010
I could actually write triple n* the same way.

146
00:08:21.010 --> 00:08:26.050
I could make this a function that takes in one argument that matches the pattern n,

147
00:08:26.050 --> 00:08:31.390
X and then calls n* with fun y,

148
00:08:31.390 --> 00:08:38.690
3*Y and n-X now this de-sugaring is poor style.

149
00:08:38.690 --> 00:08:41.335
Okay. There are reasons not to do this.

150
00:08:41.335 --> 00:08:44.470
It's much easier to read the function binding version.

151
00:08:44.470 --> 00:08:47.590
They happen to mean the same things since triple n* is not

152
00:08:47.590 --> 00:08:51.245
recursive but most people find it easier to read the function binding,

153
00:08:51.245 --> 00:08:52.555
which is actually shorter,

154
00:08:52.555 --> 00:08:54.940
the same way that we use and also and or

155
00:08:54.940 --> 00:08:58.000
else instead of if then else even though we don't need to.

156
00:08:58.000 --> 00:09:02.830
Anyway, the high level takeaway point is if you only need a function in one place,

157
00:09:02.830 --> 00:09:05.139
an anonymous function is usually the way to go.

158
00:09:05.139 --> 00:09:07.840
Just like we don't make up variable names

159
00:09:07.840 --> 00:09:10.855
for intermediate computations that we only need everyone,

160
00:09:10.855 --> 00:09:13.420
only need once, we don't need to come up with

161
00:09:13.420 --> 00:09:17.000
names for functions that we're only going to use in one place.