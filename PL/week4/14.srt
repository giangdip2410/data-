WEBVTT

1
00:00:00.012 --> 00:00:06.550
[MUSIC] In this segment, we're going take 
curried functions and call them with too 

2
00:00:06.550 --> 00:00:10.672
few arguments and see why that's a neat 
thing to do. 

3
00:00:10.672 --> 00:00:16.225
So previously we used currying just to 
simulate multiple arguments. 

4
00:00:16.225 --> 00:00:22.045
If you wanted a three argument function 
We used currying to have a function that 

5
00:00:22.045 --> 00:00:26.630
returned a function, that returned a 
function to have three arguments. 

6
00:00:26.630 --> 00:00:31.858
But, what if we took those same function 
definitions and as callers just passed in 

7
00:00:31.858 --> 00:00:34.902
fewer arguments, one or two, instead of 
three. 

8
00:00:34.902 --> 00:00:38.042
Well then what we would get back, is a 
closure. 

9
00:00:38.042 --> 00:00:41.723
That's waiting, if you will, for the 
remaining arguments. 

10
00:00:41.723 --> 00:00:46.489
There's no new semantics here, it's just 
a pleasant idiom that is completely 

11
00:00:46.489 --> 00:00:51.581
allowed, you can always call a function 
that returns another function, and then, 

12
00:00:51.581 --> 00:00:55.776
save that function and have it around, 
for when you want to call it. 

13
00:00:55.776 --> 00:01:00.314
So this is called partial application. 
It's very convenient and useful. 

14
00:01:00.314 --> 00:01:04.963
You can do it with any curried function, 
and I'm now showing you any new language 

15
00:01:04.963 --> 00:01:08.054
constructs here. 
So let's do a couple examples, I've 

16
00:01:08.054 --> 00:01:10.992
already written out all the code for this 
segment. 

17
00:01:10.992 --> 00:01:14.684
So we have our two curried functions from 
the previous segment. 

18
00:01:14.684 --> 00:01:19.152
We have sorted three which takes x, y, 
and z curried, and fold which takes f, 

19
00:01:19.152 --> 00:01:22.771
acc, and xs curried. 
And now let's notice Then we can just 

20
00:01:22.771 --> 00:01:25.984
call sorted3 with 2 arguments instead of 
3. 

21
00:01:25.984 --> 00:01:31.555
So we're going to call sorted3 with 0. 
That will give back a function, we'll 

22
00:01:31.555 --> 00:01:35.839
call that with 0. 
We'll get back another function and then 

23
00:01:35.839 --> 00:01:41.659
when we call that function what we'll end 
up doing is taking in an argument z and 

24
00:01:41.659 --> 00:01:45.247
asking is z>=0? And is y, is 0 greater 
than or equal to 0. 

25
00:01:45.247 --> 00:01:49.937
So fundamentally, what we got back was a 
function that takes in one argument and 

26
00:01:49.937 --> 00:01:54.317
tells you if it's non-negative. 
Well, that's not the most useful function 

27
00:01:54.317 --> 00:01:59.097
in the world, but it helps out something 
actually useful, like summing up all the 

28
00:01:59.097 --> 00:02:03.195
elements in a list. 
Here I have a call to fold where I've 

29
00:02:03.195 --> 00:02:09.282
also passed in 2 arguments instead of 3. 
So what I'm going to do is get back a 

30
00:02:09.282 --> 00:02:14.903
function that expects a list x's. 
Right? It'll basically be this function 

31
00:02:14.903 --> 00:02:20.280
here and we'll fold over it using this 
for fn its environment and this for the 

32
00:02:20.280 --> 00:02:24.164
initial accumulator. 
So this will actually sum all the 

33
00:02:24.164 --> 00:02:28.439
elements in the list. 
Now there are other ways, perhaps more 

34
00:02:28.439 --> 00:02:34.110
intuitive to you before you've seen this. 
Technique ways to write this function. 

35
00:02:34.110 --> 00:02:39.029
I could write is_nonnegative by just 
being a function that takes in x and call 

36
00:02:39.029 --> 00:02:43.789
sorted3 with 0 and 0 and x or sum all the 
elements in the list, the same way I 

37
00:02:43.789 --> 00:02:48.850
showed you in the previous segment where 
we just create a function that takes in 

38
00:02:48.850 --> 00:02:53.395
xs And calls fold with these 3 arguments. 
It's just longer, right? These are 

39
00:02:53.395 --> 00:02:57.676
pleasant, we get used to it, it's a 
convenient thing partial application. 

40
00:02:57.676 --> 00:03:00.471
These are not terrible, this is not awful 
style. 

41
00:03:00.471 --> 00:03:03.342
But we want you to get some practice with 
the sh. 

42
00:03:03.342 --> 00:03:08.387
Shorter way, that demonstrates that you 
understand how currying and partial 

43
00:03:08.387 --> 00:03:12.095
application work. 
And in fact, if I go back to the slides 

44
00:03:12.095 --> 00:03:17.240
here quickly, the reason why the second 
version is really the same as the first 

45
00:03:17.240 --> 00:03:20.632
version, is actually something we've seen 
before. 

46
00:03:20.632 --> 00:03:25.213
Just a little bit different. 
This top version, is just unnecessary 

47
00:03:25.213 --> 00:03:29.211
function wrapping. 
Right? We, have seen before, that, we 

48
00:03:29.211 --> 00:03:33.259
shouldn't write fn fx = g(x) when we can 
just write val f = g. 

49
00:03:33.259 --> 00:03:38.447
Well its the same thing here, except 
instead of having the variable g for the 

50
00:03:38.447 --> 00:03:42.445
name of the function. 
We have the function that you get, by 

51
00:03:42.445 --> 00:03:45.642
calling fold with the synonymous 
function. 

52
00:03:45.642 --> 00:03:49.030
And zero. 
Alright? So let me show you a couple more 

53
00:03:49.030 --> 00:03:53.943
examples I have here of just currying and 
partial application being useful to 

54
00:03:53.943 --> 00:03:57.827
hopefully get the hang of it. 
Here's a function range which takes two 

55
00:03:57.827 --> 00:04:02.493
arguments in a curried form. 
And essentially if you call Range with 

56
00:04:02.493 --> 00:04:07.699
something like 3 comma, sorry, not comma. 
We're not toppling. 

57
00:04:07.699 --> 00:04:11.214
Range 3 6, that produced the list 3, 4, 
5, 6. 

58
00:04:11.214 --> 00:04:16.014
Something like that. 
All right? And so if you call range with 

59
00:04:16.014 --> 00:04:22.869
just 1 number, like, say 1 That's going 
to give a function back, that when you 

60
00:04:22.869 --> 00:04:28.625
call it with a number, returns from the 
one up-to that number. 

61
00:04:28.625 --> 00:04:34.912
And so, count up of, 6 where we return to 
the left 1,2,3,4,5,6. 

62
00:04:34.912 --> 00:04:40.346
Just another example where we didn't need 
this unneccessary function wrapping 

63
00:04:40.346 --> 00:04:45.008
version that you have here. 
The function range 1 is a perfectly good 

64
00:04:45.008 --> 00:04:48.311
function, we can just say val countup = 
range 1. 

65
00:04:48.311 --> 00:04:54.534
As a more useful example are iterators. 
Are higher order functions over lists and 

66
00:04:54.534 --> 00:04:59.205
data structures like that, are often 
written in a curried form. 

67
00:04:59.205 --> 00:05:04.853
So let me show you another example, just 
to sneak in another useful iterator. 

68
00:05:04.853 --> 00:05:10.287
Here's a high order function exists, that 
takes a function which I'll call 

69
00:05:10.287 --> 00:05:13.762
predicate, and a list xes. 
And returns true. 

70
00:05:13.762 --> 00:05:19.046
Returns true, otherwise it returns false. 
So there's a simple 3 line function. 

71
00:05:19.046 --> 00:05:23.935
The empty list should return false. 
There does not exist an element of the 

72
00:05:23.935 --> 00:05:28.848
list for which predicate is true. 
Otherwise it's predicate applied to the 

73
00:05:28.848 --> 00:05:34.452
first element of the list Or there exists 
some element in the rest of the list for 

74
00:05:34.452 --> 00:05:37.875
which predicate returns true, so that's 
exists. 

75
00:05:37.875 --> 00:05:41.813
Here's a use of it. 
If you call Exist with a function that 

76
00:05:41.813 --> 00:05:47.567
checks whether its argument is seven, and 
a list that does not have seven, you will 

77
00:05:47.567 --> 00:05:50.962
get false. 
Alright so that's the result here, is 

78
00:05:50.962 --> 00:05:54.098
false. 
But much more interesting, is to take 

79
00:05:54.098 --> 00:05:59.381
Exists, and partially apply it. 
A way applied to one argument will get 

80
00:05:59.381 --> 00:06:03.686
back a function that takes a list and 
returns the book. 

81
00:06:03.686 --> 00:06:09.515
So has zero does indeed have type int 
list arrow book and when your call has 

82
00:06:09.515 --> 00:06:16.017
zero within int list, itwill check wether 
any of the elements in the list are zero, 

83
00:06:16.017 --> 00:06:21.986
because exists with this anonymous 
function returns the function, Returns a 

84
00:06:21.986 --> 00:06:25.669
closure, that given a list, checks what 
we want to check. 

85
00:06:25.669 --> 00:06:31.156
Similarly, the, build in library 
functions in the list library provided by 

86
00:06:31.156 --> 00:06:35.008
ML's standard library, are often written 
in curried form. 

87
00:06:35.008 --> 00:06:39.008
So list dot map is actually defined for 
us, but it's curried. 

88
00:06:39.008 --> 00:06:42.152
So if you call it with fun X, arrow, X 
plus 1. 

89
00:06:42.152 --> 00:06:47.196
You get back a function, int list arrow 
int list, that will, indeed add 1 to all 

90
00:06:47.196 --> 00:06:52.712
the elements in the list, returning a new 
list, and List.filter works the same way 

91
00:06:52.712 --> 00:06:56.779
in the standard library. 
If I call it with this function, I will 

92
00:06:56.779 --> 00:07:01.134
get back a list that is also an int list 
arrow int list, is the type of 

93
00:07:01.134 --> 00:07:05.132
removeZeros, and the list I get back will 
have all the zeros. 

94
00:07:05.132 --> 00:07:08.907
Removed from it. 
So that's very elegant and when you go to 

95
00:07:08.907 --> 00:07:13.684
use these functions you have to use them 
in a curried form here we're using 

96
00:07:13.684 --> 00:07:17.706
partial application. 
but there is one thing that I don't want 

97
00:07:17.706 --> 00:07:21.136
to talk about right now. 
But unfortunately I have to. 

98
00:07:21.136 --> 00:07:25.503
So once you start using these polymorphic 
curried functions with partial 

99
00:07:25.503 --> 00:07:29.920
application, you might run into this 
thing called the value restriction. 

100
00:07:29.920 --> 00:07:34.560
The value restriction is something that's 
NML for very good reasons, the type 

101
00:07:34.560 --> 00:07:38.763
system would be broken without it. 
I don't really want to talk about it 

102
00:07:38.763 --> 00:07:43.073
right now, 'cuz it's confusing. 
But you may start seeing something like 

103
00:07:43.073 --> 00:07:47.410
warning type vars not generalized. 
And if you see that warning about some 

104
00:07:47.410 --> 00:07:51.754
partial application that you have, you're 
not going to be able to use the function 

105
00:07:51.754 --> 00:07:54.581
to get back. 
And this shouldn't surprise you have not 

106
00:07:54.581 --> 00:07:58.718
actually done anything wrong in terms of 
what I have taught you so far, but you 

107
00:07:58.718 --> 00:08:02.862
simply have to work around it. 
And you know no language is perfect. 

108
00:08:02.862 --> 00:08:05.962
This is an ugly fact of life in languages 
like ML. 

109
00:08:05.962 --> 00:08:09.227
So let me show you an example that might 
happen. 

110
00:08:09.227 --> 00:08:14.127
Use partial application all that you want 
for now, it's a beautiful item. 

111
00:08:14.127 --> 00:08:19.254
But if you do something like this. 
Where the result would be a polymorphic 

112
00:08:19.254 --> 00:08:21.982
function. 
So I'm going to map this across 

113
00:08:21.982 --> 00:08:25.471
something. 
So this could take any, the resulting 

114
00:08:25.471 --> 00:08:31.031
function could take any kind of list and 
would return an alpha star int list, of 

115
00:08:31.031 --> 00:08:36.483
the same length where I put a 1 next to 
every element of the list, and this will 

116
00:08:36.483 --> 00:08:40.580
give that weird warning. 
And, it won't be able to be called, and 

117
00:08:40.580 --> 00:08:45.112
how should you work around this? Well, 
the first way is to just, give up on the 

118
00:08:45.112 --> 00:08:49.839
partial application, and put in, what I 
said was unnecessary function wrapping, 

119
00:08:49.839 --> 00:08:54.321
but now it's a little more, necessary. 
If you don't like that, and you really 

120
00:08:54.321 --> 00:08:58.412
want to do partial application, then you 
can put in an explicit type. 

121
00:08:58.412 --> 00:09:02.483
That's not polymorphic, like this, and 
then you have a perfectly fine function 

122
00:09:02.483 --> 00:09:06.044
but it can only be used with string 
lists, not with any kinds of list. 

123
00:09:06.044 --> 00:09:10.047
I should also point out, that on homework 
3, and things like that, you are not 

124
00:09:10.047 --> 00:09:14.093
likely to run across this, because it 
only happens when the resulting function 

125
00:09:14.093 --> 00:09:17.274
would be polymorphic. 
So for example, this call will not give 

126
00:09:17.274 --> 00:09:21.766
any kind of warning, because we can tell 
from this anonymous function That it can 

127
00:09:21.766 --> 00:09:25.765
only be applied to int-list anyway. 
So, just wanted to talk about that, 

128
00:09:25.765 --> 00:09:30.266
didn't really wanted to, but in case you 
hit the warning, I didn't want a bunch of 

129
00:09:30.266 --> 00:09:33.971
questions, of that thing you told me to 
do isn't actually working. 

130
00:09:33.971 --> 00:09:38.544
It usually works, when you get the value 
instruction for things like List.map, 

131
00:09:38.544 --> 00:09:40.684
I've given you a couple of work arounds. 