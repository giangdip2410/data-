WEBVTT

1
00:00:00.000 --> 00:00:06.476
[MUSIC] So it turns out that first class 
functions are a lot more powerful than 

2
00:00:06.476 --> 00:00:10.928
we've seen so far. 
But before we can understand that, we 

3
00:00:10.928 --> 00:00:17.161
need to take a step back and carefully 
reason about this idea called Lexical 

4
00:00:17.161 --> 00:00:20.400
Scope. 
So we're going to start that here. 

5
00:00:20.400 --> 00:00:24.844
So, this is a very important concept, but 
it's not actually anything new. 

6
00:00:24.844 --> 00:00:29.789
It's something we just need to focus on 
and reconsider now that we have higher 

7
00:00:29.789 --> 00:00:33.357
rare functions. 
We know that a function body can use more 

8
00:00:33.357 --> 00:00:37.051
than just its arguments and any local 
variables it defines. 

9
00:00:37.051 --> 00:00:41.120
It can use anything already in the 
environment, anything in scope. 

10
00:00:41.120 --> 00:00:46.794
But the question is which scope, which 
environment and the answer in almost all 

11
00:00:46.794 --> 00:00:52.397
programming languages these days is 
Lexical Scope that we use the environment 

12
00:00:52.397 --> 00:00:58.000
where the function was defined not the 
one where the function is being called. 

13
00:00:58.000 --> 00:01:00.860
Alright. 
There are lot's of good reasons for the 

14
00:01:00.860 --> 00:01:03.779
symantecs, which we'll get to in the next 
segment. 

15
00:01:03.779 --> 00:01:08.427
We'll even later in the course learn how 
to implement the symantecs, which you 

16
00:01:08.427 --> 00:01:11.406
will do on one of your later homework 
assignments. 

17
00:01:11.406 --> 00:01:16.113
But, at this point, we just want to make 
sure we understand what the rule is and 

18
00:01:16.113 --> 00:01:19.807
the way Lexical Scope works. 
This is one of the most important 

19
00:01:19.807 --> 00:01:24.395
concepts in the course, because we need 
it to use first class functions as 

20
00:01:24.395 --> 00:01:29.847
properly and as powerfully as we can. 
So let's look at an example, and I'll do 

21
00:01:29.847 --> 00:01:32.016
this with the code. 
Alright. 

22
00:01:32.016 --> 00:01:38.436
this example doesn't actually have high 
order functions in it, but we can still 

23
00:01:38.436 --> 00:01:43.291
see Lexical Scope being used. 
So, here after line one, I have an 

24
00:01:43.291 --> 00:01:49.477
environment where clearly X maps to one. 
So, in the next line when I add F to my 

25
00:01:49.477 --> 00:01:54.096
environment, I'm not going to repeat X, 
I'll just add F here. 

26
00:01:54.096 --> 00:01:58.090
F maps to a function that adds one to its 
argument. 

27
00:01:58.090 --> 00:02:03.671
And that is because whenever we call this 
function we're going to valuate this 

28
00:02:03.671 --> 00:02:08.970
body, X plus Y, in an environment that we 
have when the function was defined. 

29
00:02:08.970 --> 00:02:14.204
And when we defined this function, we had 
an environment where X maps to 1. 

30
00:02:14.204 --> 00:02:19.714
So this function that f maps to always 
adds one to its argument, no matter where 

31
00:02:19.714 --> 00:02:21.931
it is called. 
That is the rule. 

32
00:02:21.931 --> 00:02:27.374
So, now lets see what happens, here on 
line three, I shadow X so in this 

33
00:02:27.374 --> 00:02:32.972
environment X maps the two that has no 
effect on F, has no effect on the 

34
00:02:32.972 --> 00:02:38.406
environment where F was defined. 
Clearly here, we now have an environment 

35
00:02:38.406 --> 00:02:41.795
where x still maps to two, and y maps to 
three. 

36
00:02:41.795 --> 00:02:45.110
So now we get to the all important call 
here. 

37
00:02:45.110 --> 00:02:52.963
We look up F in the environment, we get 
the function that adds 1 to it's 

38
00:02:52.963 --> 00:02:58.164
argument. 
We look up X we get 2, we look up Y we 

39
00:02:58.164 --> 00:03:02.940
get 3. 
So we call the function defined on. 

40
00:03:02.940 --> 00:03:10.431
Line 2 with 5, because we looked up X and 
Y here in the environment at the call 

41
00:03:10.431 --> 00:03:13.844
site. 
But then when we make the call, we pass 

42
00:03:13.844 --> 00:03:18.675
5, we add 1 to the argument, and so in 
the end, Z maps to 6. 

43
00:03:18.675 --> 00:03:23.883
That's the essential part. 
If you thought Z was going to map to 7, 

44
00:03:23.883 --> 00:03:29.394
you're using a different rule, which is 
not how ML works, and not how most 

45
00:03:29.394 --> 00:03:31.810
programming languages work. 
Okay. 

46
00:03:31.810 --> 00:03:35.893
So that is the key idea and the key 
example for this segment. 

47
00:03:35.893 --> 00:03:40.579
Now let's go back to the slides. 
Here I've said the same thing we just 

48
00:03:40.579 --> 00:03:44.461
talked about. 
The point is that on Line 5 we evaluate X 

49
00:03:44.461 --> 00:03:50.552
+ Y in the current environment at Line 5 
which gives us a 5 but then when we call 

50
00:03:50.552 --> 00:03:55.908
the function, we evaluate that function 
body, the X + Y on line 2 in the old 

51
00:03:55.908 --> 00:04:01.397
environment where X maps to 1, extended 
with Y, of course, mapping to 5 because 

52
00:04:01.397 --> 00:04:07.014
that's how function arguments work. 
So this is why we need function closures, 

53
00:04:07.014 --> 00:04:10.799
which we have not talked about before, in 
our language. 

54
00:04:10.799 --> 00:04:14.094
Right? 
Because you might be thinking, that seems 

55
00:04:14.094 --> 00:04:18.510
a little magic to me. 
How can a function be evaluated in an old 

56
00:04:18.510 --> 00:04:24.048
environment that isn't around any more? 
Once we've shadowed X, how can that body 

57
00:04:24.048 --> 00:04:27.795
of F use the old X? 
And the fact of the matter is it's not 

58
00:04:27.795 --> 00:04:31.945
magical because the language 
implementation, the ML interpreter and 

59
00:04:31.945 --> 00:04:36.343
compiler and whatever else that 
implements ML has to keep around those 

60
00:04:36.343 --> 00:04:40.370
old environments so that we can implement 
Lexical Scope properly. 

61
00:04:40.370 --> 00:04:45.197
So the way to think about the semantics 
of functions in general, is that we know 

62
00:04:45.197 --> 00:04:48.878
functions are values. 
We can pass them around however we want. 

63
00:04:48.878 --> 00:04:51.533
But a function value actually has two 
parts. 

64
00:04:51.533 --> 00:04:56.120
So far we've only been talking about the 
code part which is sort of obvious. 

65
00:04:56.120 --> 00:04:59.620
You can't have a function without a body 
to that function. 

66
00:04:59.620 --> 00:05:03.292
But a function value, this closure has a 
second part. 

67
00:05:03.292 --> 00:05:08.800
It has with it the environment that was 
current when the function was defined. 

68
00:05:08.800 --> 00:05:11.566
So we really have a pair. 
It's not an ML pair. 

69
00:05:11.566 --> 00:05:16.300
It's just something with two parts, and 
they, and those parts are the code and 

70
00:05:16.300 --> 00:05:19.743
the environment. 
This thing is called a closure, and when 

71
00:05:19.743 --> 00:05:24.415
you call a function, you're actually 
calling one of these pairs, one of these 

72
00:05:24.415 --> 00:05:27.489
closures. 
And what you do is you evaluate the code 

73
00:05:27.489 --> 00:05:31.177
using the environment. 
So you use both parts of the pair and 

74
00:05:31.177 --> 00:05:34.300
that's how a function call actually 
works. 

75
00:05:34.300 --> 00:05:39.242
So in our example we can now go back to 
it and see what actually happened, 

76
00:05:39.242 --> 00:05:43.650
another way to reason about the 
semantics, which is at line two we 

77
00:05:43.650 --> 00:05:49.061
created a closure, and that closure had a 
code part that said give me an argument 

78
00:05:49.061 --> 00:05:54.471
why and I'll evaluate the code X + Y. 
And it had an environment part that said 

79
00:05:54.471 --> 00:05:59.080
that I will evaluate that code in an 
environment where X maps to 1. 

80
00:05:59.080 --> 00:06:05.143
So then when we did the call on Line 5 we 
passed to that closure the argument five, 

81
00:06:05.143 --> 00:06:11.065
two plus three and then the result of the 
call used the code in the closure and the 

82
00:06:11.065 --> 00:06:16.564
environment in the closure with the one 
addition that Y maps the 5 for the 

83
00:06:16.564 --> 00:06:20.865
function argument. 
And that is once again why we got 6 back, 

84
00:06:20.865 --> 00:06:24.249
alright. 
So that is Lexical Scope and that's how 

85
00:06:24.249 --> 00:06:29.325
closures implement Lexical Scope and 
that's how you can think about the 

86
00:06:29.325 --> 00:06:32.780
functions we're going to be passing 
around in ml. 

87
00:06:32.780 --> 00:06:38.201
So to give you a bit of an outline of 
where we're going from here that is the 

88
00:06:38.201 --> 00:06:42.064
rule of Lexical Scope. 
Now what I want to do in the next segment 

89
00:06:42.064 --> 00:06:45.844
is continue with these sort of silly 
examples, but examples that use 

90
00:06:45.844 --> 00:06:49.624
functions, taking functions, or 
functions, returning functions because 

91
00:06:49.624 --> 00:06:54.182
that shows that its a pretty powerful 
feature, its may be a little harder to 

92
00:06:54.182 --> 00:06:57.351
reason about, so I want some more 
advanced silly examples. 

93
00:06:57.351 --> 00:07:00.908
Then we'll get to the why. 
Why would you implement, why would you 

94
00:07:00.908 --> 00:07:04.410
want the semantics of your language to 
have this Lexical Scope. 

95
00:07:04.410 --> 00:07:08.246
We'll contrast it with the other 
possibility which is called dynamic 

96
00:07:08.246 --> 00:07:10.738
scope. 
And then we're going to talk a lot about 

97
00:07:10.738 --> 00:07:13.976
programming idioms. 
How once you know that a language has 

98
00:07:13.976 --> 00:07:18.350
Lexical Scope, there's a number of very 
powerful things you can do with first 

99
00:07:18.350 --> 00:07:22.043
class functions that rely on the fact 
that we have Lexical Scope. 