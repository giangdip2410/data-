WEBVTT

1
00:00:00.012 --> 00:00:06.435
[MUSIC] In this segment we're going to 
start our study of currying, our next 

2
00:00:06.435 --> 00:00:10.959
closure idiom. 
It's one of my favorite things to do in 

3
00:00:10.959 --> 00:00:16.205
functional programming. 
and this is a new way to deal with 

4
00:00:16.205 --> 00:00:22.735
conceptually multi-argument function. 
So you might remember that in ML, every 

5
00:00:22.735 --> 00:00:28.243
function takes exactly one argument. 
We worked around this previously by 

6
00:00:28.243 --> 00:00:32.896
passing n arguments as n different pieces 
of a single tuple. 

7
00:00:32.896 --> 00:00:37.139
So another way we could do it which is 
called currying, is to take one argument 

8
00:00:37.139 --> 00:00:41.504
and return a function that takes the next 
argument and it we'll still be able to 

9
00:00:41.504 --> 00:00:44.890
use the first argument, because it will 
be in its environment. 

10
00:00:44.890 --> 00:00:49.452
This is called Currying after the name of 
the person just as a funniest side, I 

11
00:00:49.452 --> 00:00:53.695
actually spent years of my life before I 
knew that, trying to figure out why it 

12
00:00:53.695 --> 00:00:57.002
was called currying, and of course, I was 
never successful. 

13
00:00:57.002 --> 00:01:01.117
So, let me show you an example in the 
code of how this is going to work. 

14
00:01:01.117 --> 00:01:05.777
So, we are going to stick with a very 
simple example in this section of just a 

15
00:01:05.777 --> 00:01:10.272
function that takes three arguments 
conceptually, x, y and z and sees that 

16
00:01:10.272 --> 00:01:13.329
they're sorted. 
So in terms of tupling, just take a 

17
00:01:13.329 --> 00:01:17.825
triple, pattern match against it like 
this, and return true or false based on 

18
00:01:17.825 --> 00:01:23.826
is z >= y and is y >= equal to x. 
And we would call that tupled function 

19
00:01:23.826 --> 00:01:27.935
with a triple like 7, 9, 11. 
So here is a new way to do it that at 

20
00:01:27.935 --> 00:01:32.367
first will seem very ugly, but then I 
will show you some syntactic sugar that 

21
00:01:32.367 --> 00:01:36.832
will perhaps make it even cleaner, even 
more pleasant than the tupled version. 

22
00:01:36.832 --> 00:01:43.897
So let's just make a sorted3 function 
that takes in an x and returns, these 

23
00:01:43.897 --> 00:01:50.786
parentheses are not optional or are 
optional, so I'm going to take them out, 

24
00:01:50.786 --> 00:01:56.192
a function y that when you call it, 
returns a function z, a function that 

25
00:01:56.192 --> 00:02:03.342
takes a z, and when you call it says z >= 
y and also y >= x. 

26
00:02:03.342 --> 00:02:08.317
Now that looks a little funny too, we 
could have instead said it fun sorted3 

27
00:02:08.317 --> 00:02:14.334
taking an x and then return a function y 
that when you call it, takes a function z 

28
00:02:14.334 --> 00:02:18.649
and so on. 
That's exactly the same thing so maybe 

29
00:02:18.649 --> 00:02:22.636
the val version will be a little easier 
here. 

30
00:02:22.636 --> 00:02:30.357
And now, what we can do is we could call 
sorted3 with a number, like 7 and that 

31
00:02:30.357 --> 00:02:36.968
would give us back a function, right? If 
we call this with x, we're going to get 

32
00:02:36.968 --> 00:02:41.779
back this. 
So what we could then do is call that 

33
00:02:41.779 --> 00:02:47.641
function with 9 and that would give us 
back this function, 

34
00:02:47.641 --> 00:02:55.307
and then we could call that with 11. 
And this will absolutely work and should 

35
00:02:55.307 --> 00:02:58.966
even give us the right answer, 
so let's see. 

36
00:02:58.966 --> 00:03:04.254
sure enough I have some lower stuff in 
the file, ignore that. 

37
00:03:04.254 --> 00:03:08.859
sorted3_tupled takes a tuple of ints and 
returns a bool. 

38
00:03:08.859 --> 00:03:11.822
t1 was true. 
Sorted3 takes an int, 

39
00:03:11.822 --> 00:03:16.644
returns a function that takes an int, and 
returns a function that takes an int, and 

40
00:03:16.644 --> 00:03:20.436
that all returns a bool, 
and then we did use it correctly, and so 

41
00:03:20.436 --> 00:03:23.349
t2 is true. 
So let's take a closer look at what's 

42
00:03:23.349 --> 00:03:26.363
going on, because that looks awfully 
complicated. 

43
00:03:26.363 --> 00:03:29.988
It's all the same semantics, we already 
know about closures. 

44
00:03:29.988 --> 00:03:33.244
So when we called (sorted3 7), we got 
back a closure. 

45
00:03:33.244 --> 00:03:37.012
Remember, a closure has two parts, a code 
and an environment. 

46
00:03:37.012 --> 00:03:44.364
The code is just the body of the function 
we called fn y, fn z, z >= y, and also, 

47
00:03:44.364 --> 00:03:48.170
that's the function we got back, 
we called with (sorted3 7). 

48
00:03:48.170 --> 00:03:53.702
It returned this function that takes y 
and the environment for that closure is 

49
00:03:53.702 --> 00:03:59.217
that x maps to 7. So when we call that 
closure with 9, we get back a closure 

50
00:03:59.217 --> 00:04:08.017
whose code is now fn z, z >= y and also y 
>= x, because that's what the result is 

51
00:04:08.017 --> 00:04:13.991
of calling the function with y to 9 and 
in the environment, x maps to 7 and y 

52
00:04:13.991 --> 00:04:17.901
maps to 9. 
So when we call that closure with 11, we 

53
00:04:17.901 --> 00:04:21.922
evaluate the and expression, and we get 
back true, 

54
00:04:21.922 --> 00:04:25.367
that's all there is to it. 
And, while the semantics may seem 

55
00:04:25.367 --> 00:04:28.567
complicated, it's just closures which we 
get used to. 

56
00:04:28.567 --> 00:04:32.427
And since currying is such a common 
pattern, such a common idiom, 

57
00:04:32.427 --> 00:04:35.432
we don't think through it on this level 
every time. 

58
00:04:35.432 --> 00:04:39.977
We just say oh, I'm using currying, 
so it's like a multi-argument function. 

59
00:04:39.977 --> 00:04:44.147
And, so now, let's make it even more 
pleasant to use by pointing out some 

60
00:04:44.147 --> 00:04:48.017
syntactic sugar that we happen to have in 
ML. 

61
00:04:48.017 --> 00:04:52.043
So, it turns out, the first thing we can 
clean up is this call. 

62
00:04:52.043 --> 00:04:55.476
Okay? So we don't need all these 
parentheses. 

63
00:04:55.476 --> 00:05:00.093
In general, if you just leave the 
parentheses out with spaces between 

64
00:05:00.093 --> 00:05:03.945
arguments, 
the parentheses go in to organize things 

65
00:05:03.945 --> 00:05:08.935
to the left. 
So if you just write sorted3 7 9 11, it's 

66
00:05:08.935 --> 00:05:13.482
calling sorted3 with 7, getting back a 
function and calling it with 9, and 

67
00:05:13.482 --> 00:05:16.501
getting back a function and calling it 
with 11. 

68
00:05:16.501 --> 00:05:21.733
So we don't need those parentheses. We 
can go back to our code here and instead, 

69
00:05:21.733 --> 00:05:26.255
just say val t3 = sorted3 7 9 11. 
And now if you compare this to calling a 

70
00:05:26.255 --> 00:05:31.074
tupled function, it's actually fewer 
characters, more space characters, but 

71
00:05:31.074 --> 00:05:34.703
less clutter on the screen, 
so that's actually kind of nice. 

72
00:05:34.703 --> 00:05:38.752
And this is a good time to point out that 
you have a curried function, like 

73
00:05:38.752 --> 00:05:41.378
sorted3, you can call it either of these 
two ways. 

74
00:05:41.378 --> 00:05:44.703
If you have a tupled function, you can 
only call it this way, 

75
00:05:44.703 --> 00:05:47.969
you can't mix and match, 
right? If you want to call a function 

76
00:05:47.969 --> 00:05:50.570
that takes a tuple, you have to pass a 
tuple. 

77
00:05:50.570 --> 00:05:54.939
And if you want to call a function that 
takes, that's curried, you have do via 

78
00:05:54.939 --> 00:05:58.503
via a sequence of calls. 
So you can't, for example, write 

79
00:05:58.503 --> 00:06:01.729
sorted3_tupled 7 9 11. 
That's going to try to call 

80
00:06:01.729 --> 00:06:05.904
sorted3_tupled with 7, 
you'll get a type error immediately, 

81
00:06:05.904 --> 00:06:11.386
because you're not passing a tuple where 
you need it. And similarly, you cannot 

82
00:06:11.386 --> 00:06:17.475
call sorted3 with a tuple, you will also 
get a type error. It doesn't expect a 

83
00:06:17.475 --> 00:06:22.396
tuple, we can see here in the greater 
than, y >= x, that x needs to be an int 

84
00:06:22.396 --> 00:06:26.256
and not a triple int, 
so we better comment all that out. 

85
00:06:26.256 --> 00:06:30.868
Okay? So, so far, so good. 
That's the first step of syntactic sugar, 

86
00:06:30.868 --> 00:06:35.782
is that callers can just think oh, it's 
curried and takes three arguments. 

87
00:06:35.782 --> 00:06:41.037
I'll just separate them by spaces. 
It's also easier to define curried 

88
00:06:41.037 --> 00:06:46.002
functions than I've suggested, 
that you don't have to write all these 

89
00:06:46.002 --> 00:06:50.362
anonymous functions that return other 
anonymous functions. 

90
00:06:50.362 --> 00:06:55.632
That you can, or syntax for function 
binding has built in support for 

91
00:06:55.632 --> 00:06:59.333
currying. 
So, I have the definitions here written 

92
00:06:59.333 --> 00:07:04.155
on the slide, but it is sometimes easier 
just to show an example. 

93
00:07:04.155 --> 00:07:09.554
Here is another definition of sorted3, 
which I'll call sorted3_nicer. 

94
00:07:09.554 --> 00:07:15.838
If you just separate multiple patterns in 
general, here just variables, before the 

95
00:07:15.838 --> 00:07:22.421
equals, this means curried Alright? 
So y >= x, and so, compared to our 

96
00:07:22.421 --> 00:07:25.810
previous version here, these are exactly 
the same, 

97
00:07:25.810 --> 00:07:30.565
this is syntactic sugar for this, 
although, because we used fn, we could 

98
00:07:30.565 --> 00:07:33.881
also use recursion, we don't need 
recursion here. 

99
00:07:33.881 --> 00:07:39.320
So given this that's a much nicer way to 
write the function, and we can continue 

100
00:07:39.320 --> 00:07:45.063
to use it using our syntactic sugar, 
and that is a really nice way to think of 

101
00:07:45.063 --> 00:07:48.876
multi-argument functions. 
Just the caller, separated them by 

102
00:07:48.876 --> 00:07:53.956
spaces, the callee and the caller, 
separated them by spaces, but what is 

103
00:07:53.956 --> 00:07:59.162
going on semantically is closures, 
functions returning other functions, 

104
00:07:59.162 --> 00:08:03.698
the rest is just syntactic sugar. 
I would point out that because this is 

105
00:08:03.698 --> 00:08:09.575
just syntax, you could call sorted3_nicer 
with all these parentheses, because this 

106
00:08:09.575 --> 00:08:16.423
means exactly the same thing as the line 
and a buff, 'kay? So that is what most of 

107
00:08:16.423 --> 00:08:23.202
what I wanted to show you. 
Remember here, over in the over in SML, 

108
00:08:23.202 --> 00:08:29.854
in ripple, that these tupled functions 
will print their arguments looking like 

109
00:08:29.854 --> 00:08:32.649
this, 
sorted3_nicer, we'd have exactly the same 

110
00:08:32.649 --> 00:08:35.520
type. 
Remember, the parentheses go to the right 

111
00:08:35.520 --> 00:08:38.126
here, 
so this says, I'm a function that takes 

112
00:08:38.126 --> 00:08:42.671
an int and returns an int -> int -> bool. 
meaning that you passed that function in 

113
00:08:42.671 --> 00:08:47.279
int and you get back a function, you pass 
that function in int and you'll get back 

114
00:08:47.279 --> 00:08:49.809
a bool. 
So as you can, here in the alpha to the 

115
00:08:49.809 --> 00:08:52.562
ripple, I had one more thing I wanted to 
show you, 

116
00:08:52.562 --> 00:08:57.100
which was a fold in a curried form. 
So we've seen fold before, it was a 

117
00:08:57.100 --> 00:09:00.879
couple of segments ago. 
Here is a version that takes three 

118
00:09:00.879 --> 00:09:06.120
curried arguments using our syntactic 
sugar. So this first line right here that 

119
00:09:06.120 --> 00:09:11.369
I'm highlighting, means exactly the same 
thing as on a function fold that takes f 

120
00:09:11.369 --> 00:09:14.072
and returns a function that takes the 
accumulator. 

121
00:09:14.072 --> 00:09:18.382
If you call that, it returns a functions 
that takes x's and this is its body. And 

122
00:09:18.382 --> 00:09:22.676
you'll notice that here in the recursive 
call, since I have a curried function, I 

123
00:09:22.676 --> 00:09:26.364
need to pass those arguments separated by 
spaces and I've done that. 

124
00:09:26.364 --> 00:09:30.052
Here is the first argument, 
here is the second argument, and you need 

125
00:09:30.052 --> 00:09:34.805
these parentheses so that you know where 
the second argument ends and this third 

126
00:09:34.805 --> 00:09:37.654
argument begins. 
So that's a perfectly fine curried 

127
00:09:37.654 --> 00:09:39.390
function. 
Here is a use of it. 

128
00:09:39.390 --> 00:09:43.630
Here is a function that sums all the 
elements in a list by just calling fold, 

129
00:09:43.630 --> 00:09:47.283
which here is curried. 
Here's the first argument, space, second 

130
00:09:47.283 --> 00:09:51.762
argument, space, third argument, 
exact same semantics as sorted3, 

131
00:09:51.762 --> 00:09:55.363
just more useful. 
So, coming back here, in terms of 

132
00:09:55.363 --> 00:09:59.432
sorted3, our final version here is really 
very elegant. 

133
00:09:59.432 --> 00:10:05.139
It's actually fewer non-space characters 
than the tupled approach, the approach 

134
00:10:05.139 --> 00:10:09.002
that used tuples, 
and we just know that it's syntactic 

135
00:10:09.002 --> 00:10:13.732
sugar for this bottom version, which is 
easier to understand what's going on. 

136
00:10:13.732 --> 00:10:17.584
But once you get it, once you go oh, 
that's what curring is doing, 

137
00:10:17.584 --> 00:10:21.789
then you just think of it as a three 
argument function, like we've thought of 

138
00:10:21.789 --> 00:10:26.221
tuples as multi-argument functions. 
And then for fold, we just write it this 

139
00:10:26.221 --> 00:10:28.550
way to begin with. 
It's just as elegant. 

140
00:10:28.550 --> 00:10:32.012
We think of fold as a three argument 
function and we call it with three 

141
00:10:32.012 --> 00:10:32.012
arguments. 