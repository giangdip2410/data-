WEBVTT

1
00:00:00.012 --> 00:00:05.558
[MUSIC] In this segment, we're going to 
take a brief break from closures. 

2
00:00:05.558 --> 00:00:11.104
To, for the first time in the course, 
actually show you something mutable. 

3
00:00:11.104 --> 00:00:16.052
Show you an assignment statement. 
So, I have certainly emphasized 

4
00:00:16.052 --> 00:00:21.052
throughout this course, that you do not 
need mutable data structures. 

5
00:00:21.052 --> 00:00:25.837
That they cause lots of problems. 
There are benefits to avoiding them, that 

6
00:00:25.837 --> 00:00:30.527
immutability is a great default. 
But I don't believe that there's always a 

7
00:00:30.527 --> 00:00:34.537
need to avoid mutation. 
There are situations where what you are 

8
00:00:34.537 --> 00:00:37.422
programming. 
The model of the thing that your 

9
00:00:37.422 --> 00:00:41.517
computation is about has certain inherent 
updates to it. 

10
00:00:41.517 --> 00:00:47.395
There's some state in the world, and that 
state needs to be updated for everyone 

11
00:00:47.395 --> 00:00:52.775
who has access to that state to see. 
That's the natural way to think about 

12
00:00:52.775 --> 00:00:56.258
your problem. 
Then using mutation makes sense. 

13
00:00:56.258 --> 00:01:01.307
The problem with most programming 
languages is that they make everything 

14
00:01:01.307 --> 00:01:04.637
mutable. 
So you have to worry that things should 

15
00:01:04.637 --> 00:01:09.888
be changed even when, in your model of 
what the computation should be doing, 

16
00:01:09.888 --> 00:01:15.062
there's no reason it should ever change. 
So ML does a nice job of supporting 

17
00:01:15.062 --> 00:01:19.636
mutation, but not for variables, not for 
tuples, not for lists. 

18
00:01:19.636 --> 00:01:24.743
For things you want mutable you have to 
use a separate language construct called 

19
00:01:24.743 --> 00:01:28.902
a reference, and only the contents of 
references can be updated. 

20
00:01:28.902 --> 00:01:33.633
So I'm showing this to you now because 
the next closure idiom I want to show 

21
00:01:33.633 --> 00:01:38.723
you, I'm going to use this in my example. 
So that's the reason for the ordering. 

22
00:01:38.723 --> 00:01:42.772
You still did not get to use mutation on 
your homework. 

23
00:01:42.772 --> 00:01:46.642
It's an important thing. 
You need plenty of practice for this 

24
00:01:46.642 --> 00:01:50.887
mutation free programming. 
And none of the things we are asking you 

25
00:01:50.887 --> 00:01:55.887
to program, benefit from mutation, or any 
easier to do if you are allowed to use 

26
00:01:55.887 --> 00:01:57.647
references, 
so you're not, 

27
00:01:57.647 --> 00:02:02.612
okay? So, here is everything you need to 
know about these mutable references. 

28
00:02:02.612 --> 00:02:08.921
There's a new kind of type, t ref, where 
t is any type, the same way t list is a 

29
00:02:08.921 --> 00:02:14.635
type for any type t, t ref is. 
So the type of a reference whose content 

30
00:02:14.635 --> 00:02:18.319
is a t. 
So an int ref would have contents that 

31
00:02:18.319 --> 00:02:22.752
are ints. 
We have 3 new primatives in the language. 

32
00:02:22.752 --> 00:02:27.524
Functions we can use, to use references. 
We make a new reference with the ref 

33
00:02:27.524 --> 00:02:30.653
function, so this is on the left of an 
expression. 

34
00:02:30.653 --> 00:02:34.917
It's a little confusing, we reuse the 
same thing we used in the type. 

35
00:02:34.917 --> 00:02:38.332
But the way this works is, you evaluate e 
to a value. 

36
00:02:38.332 --> 00:02:43.609
And then you create a new reference and 
the result is a pointer to that 

37
00:02:43.609 --> 00:02:47.890
reference, if you will. 
It's a thing that refers to that 

38
00:02:47.890 --> 00:02:51.211
reference. 
So, you now have this thing whose 

39
00:02:51.211 --> 00:02:55.002
contents are initially whatever e 
evaluated to. 

40
00:02:55.002 --> 00:02:58.957
Now those contents can change, cause this 
is mutation. 

41
00:02:58.957 --> 00:03:03.842
We change the contents of a reference 
with the =: operator. 

42
00:03:03.842 --> 00:03:09.517
This is our assignment statement, =.: 
What we do is we evaluate 1 to a 

43
00:03:09.517 --> 00:03:13.960
reference. 
E2 to some value, and then we update the 

44
00:03:13.960 --> 00:03:20.600
contents of the reference to that value, 
so the thing e1 refers to has its 

45
00:03:20.600 --> 00:03:26.908
contents changed to be the result of e2. 
In terms of type checking, perhaps not 

46
00:03:26.908 --> 00:03:31.498
surprisingly, e1 has to be a t ref for 
sum type t, and e2 has to be a t. 

47
00:03:31.498 --> 00:03:35.448
We don't allow the contents of a 
reference is type to change. 

48
00:03:35.448 --> 00:03:40.839
The type can't change, we have to replace 
1 int with another int or 1 string with 

49
00:03:40.839 --> 00:03:44.863
another string. 
Finally, if you want to read the contents 

50
00:03:44.863 --> 00:03:49.876
of a reference, as opposed to writing 
them or updating them, this is what we 

51
00:03:49.876 --> 00:03:54.789
use the exclamation point for. 
So, many languages use exclamation points 

52
00:03:54.789 --> 00:03:59.431
for negation. ML uses it for retreiveing 
the contents of a reference. 

53
00:03:59.431 --> 00:04:04.495
So we evaluate e to a value, it better be 
some t ref, and then bang of that, the 

54
00:04:04.495 --> 00:04:10.139
exclamation point of that retrieves the 
t, retrieves the value in the reference. 

55
00:04:10.139 --> 00:04:14.749
So let's see an example. 
it's a silly example, but it emphasizes 

56
00:04:14.749 --> 00:04:20.050
what is different about these things. 
So on the first line here you see, val x 

57
00:04:20.050 --> 00:04:23.387
= ref 42. 
That is going to go and creat some new 

58
00:04:23.387 --> 00:04:28.771
location whos contents can change, 
initialize those contents with 42 and 

59
00:04:28.771 --> 00:04:34.526
return a reference, an arrow in the 
picture over on the left to that thing. 

60
00:04:34.526 --> 00:04:40.117
I din't write the 42 in the box but you 
should imagine that at this point we've 

61
00:04:40.117 --> 00:04:45.078
returned X is bound to. 
This arrow that refers to this box that 

62
00:04:45.078 --> 00:04:49.080
holds a 42. 
The next line val y = ref 42, that will 

63
00:04:49.080 --> 00:04:53.286
make a new box. 
Initialize it's contents to 42, the 

64
00:04:53.286 --> 00:04:59.781
result of ref 42 is that arrow pointing 
to it, and then the variable y now refers 

65
00:04:59.781 --> 00:05:04.727
to that thing. 
When we say val z = x, well we evaluate 

66
00:05:04.727 --> 00:05:09.027
x. 
We look up x in our dynamic environment, 

67
00:05:09.027 --> 00:05:15.827
we get the arrow that it points to. 
And so z and x now refer to the same 

68
00:05:15.827 --> 00:05:20.622
reference, they are aliases. 
They both refer to that. 

69
00:05:20.622 --> 00:05:25.552
So, when you see here, x:=43, which is 
the next thing this file does. 

70
00:05:25.552 --> 00:05:29.052
This Bell underscore is just an idiom 
for, do it. 

71
00:05:29.052 --> 00:05:34.357
And I don't care about the result. 
because the result here is not going to 

72
00:05:34.357 --> 00:05:37.352
be bound to any variable. 
So we say x =: 43. 

73
00:05:37.352 --> 00:05:40.142
Now, this left box. 
Oop, pardon me, 

74
00:05:40.142 --> 00:05:45.127
holds 43, alright? So on this last line, 
when we say bang y. 

75
00:05:45.127 --> 00:05:49.132
We retrieve the contents over here. 
We get a 42. 

76
00:05:49.132 --> 00:05:53.017
We retrieve the contents over here, we 
get 43. 

77
00:05:53.017 --> 00:05:57.407
42 + 43 is 85. 
Notice that x, y, and z all have type int 

78
00:05:57.407 --> 00:06:01.242
ref. 
They refer to a mutable location holding 

79
00:06:01.242 --> 00:06:04.959
an int. 
You cannot apply addition to an int ref, 

80
00:06:04.959 --> 00:06:08.544
that doesn't make any sense. 
The only operation you can do in a ref 

81
00:06:08.544 --> 00:06:13.666
are assignment with =: and the reference 
with exclamation point, so you can't 

82
00:06:13.666 --> 00:06:16.243
write x + 1. 
You have to write x! + 1. 

83
00:06:16.243 --> 00:06:22.053
That's keeping separate the notion of a 
mutable location from the notion of an 

84
00:06:22.053 --> 00:06:27.611
integer and that's a good thing. 
In fact as I want to emphasize here x, is 

85
00:06:27.611 --> 00:06:31.630
immutable. 
The variable x, the variably y, the 

86
00:06:31.630 --> 00:06:38.053
variable z, those always refer to the 
same reference they did when they were 

87
00:06:38.053 --> 00:06:42.026
created. 
x holds, is bound to, this arrow, and 

88
00:06:42.026 --> 00:06:47.777
will always be, this arrow. 
It's the contents of the thing the arrow 

89
00:06:47.777 --> 00:06:53.242
is pointing to, that can change. 
So once you're using mutation, just like 

90
00:06:53.242 --> 00:06:58.142
in any other programming language, you 
have to deal with potential aliasing. 

91
00:06:58.142 --> 00:07:02.927
That is why when we assigned x, the 
result we get henceforth for exclamation 

92
00:07:02.927 --> 00:07:06.727
point z changes. 
Presumably, if you're using mutation, you 

93
00:07:06.727 --> 00:07:11.632
want to think about stuff like that, and 
if you don't want to think about stuff 

94
00:07:11.632 --> 00:07:14.323
like that, don't use mutation. 
All right. 

95
00:07:14.323 --> 00:07:19.288
So you should really think of these 
references as first-class values. You can 

96
00:07:19.288 --> 00:07:24.190
pass them around, you can do, you can 
pass a ref to a function, you can return 

97
00:07:24.190 --> 00:07:28.023
a ref from a function. 
And for those of you more used to, 

98
00:07:28.023 --> 00:07:33.017
programming in other languages, Java, C, 
C++, whatever, you could think of a 

99
00:07:33.017 --> 00:07:37.657
reference as a little mutable object. 
It just has one field, so since it only 

100
00:07:37.657 --> 00:07:41.022
has one field := updates that field, 
exclamation point reads that field. We 

101
00:07:41.022 --> 00:07:45.232
don't need to give a name to the field 
because references only have one. 

102
00:07:45.232 --> 00:07:50.222
If you wanted multiple fields you could 
have your reference hold a tuple and then 

103
00:07:50.222 --> 00:07:54.757
you could update it to point to a 
different tuple. It's not the tuple 

104
00:07:54.757 --> 00:07:57.682
that's mutable, it's always just the 
reference. 

105
00:07:57.682 --> 00:07:59.744
Contents. 
And those are minimal references. 

106
00:07:59.744 --> 00:08:03.331
As I mentioned, we will not use them very 
much in the course, but we need them a 

107
00:08:03.331 --> 00:08:06.721
little a bit for the next segment so I 
thought I would show them to you a bit 

108
00:08:06.721 --> 00:08:07.396
more generally. 