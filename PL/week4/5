WEBVTT

1
00:00:00.000 --> 00:00:04.940
[SOUND] 

2
00:00:04.940 --> 00:00:10.060
In this segment we're going to write and 
use two more high-order functions, which 

3
00:00:10.060 --> 00:00:13.891
we will call map and filter. 
And these examples are so famous, so 

4
00:00:13.891 --> 00:00:18.300
important, I like to joke that if there 
were a hall of fame for famous higher 

5
00:00:18.300 --> 00:00:22.480
order functions, these would be in it. 
These are not functions I made up, I 

6
00:00:22.480 --> 00:00:25.973
didn't make up their name. 
In fact, they're part of the common 

7
00:00:25.973 --> 00:00:30.383
vocabulary that computer scientists and 
software developers use all the time. 

8
00:00:30.383 --> 00:00:35.135
So it's important to understand when map 
and filter are the right thing to use and 

9
00:00:35.135 --> 00:00:39.659
it's great that in a language with higher 
order functions, we can easily define 

10
00:00:39.659 --> 00:00:42.580
them for ourselves over data structures 
like lists. 

11
00:00:42.580 --> 00:00:46.058
So let's just do that. 
I've just got a blank file here, 

12
00:00:46.058 --> 00:00:49.981
and we'll do map first. 
So we're going to do map over a list. 

13
00:00:49.981 --> 00:00:55.726
Map takes a function and a list, and what 
it does, is it computes a new list that 

14
00:00:55.726 --> 00:00:59.964
is like the input list, except F is 
applied to each element. 

15
00:00:59.964 --> 00:01:05.493
So it's got the same shape and size. 
The Ith element of the output is the Ith 

16
00:01:05.493 --> 00:01:08.510
element of the input with F applied to 
it. 

17
00:01:08.510 --> 00:01:14.009
And once you know how to write higher 
order functions in a language like ML, 

18
00:01:14.009 --> 00:01:17.772
this is actually very easy. 
let's just case on X's. 

19
00:01:17.772 --> 00:01:23.199
If we have the empty list, then the 
result of mapping F across all of those 

20
00:01:23.199 --> 00:01:28.409
elements is simply the empty list. 
Otherwise, we'll have a non-empty list, 

21
00:01:28.409 --> 00:01:34.125
and what we should do is create a list 
that's F applied to X consed on to 

22
00:01:34.125 --> 00:01:38.187
mapping F to X's prime. 
That is the entire thing that, for map, 

23
00:01:38.187 --> 00:01:43.110
and if it looks a little familiar, it 
might be because it's on the course logo 

24
00:01:43.110 --> 00:01:46.959
you've seen every time, you've 
participated in this course. 

25
00:01:46.959 --> 00:01:49.925
All right. 
Let's see how to use map in a couple 

26
00:01:49.925 --> 00:01:52.449
different ways. 
one thing we could do, 

27
00:01:52.449 --> 00:01:55.352
I'm just going to define a couple 
variables here, 

28
00:01:55.352 --> 00:02:00.463
is we could map the increment function, 
take X return X plus one, across a list 

29
00:02:00.463 --> 00:02:03.520
of integers. 
Maybe four, eight, twelve, sixteen? 

30
00:02:03.520 --> 00:02:06.977
Or we could, let's say map the head 
function. 

31
00:02:06.977 --> 00:02:12.400
Notice I'm not unnecessarily wrapping it 
here, across a list of lists. 

32
00:02:12.400 --> 00:02:17.901
You're going to have to have a list of 
lists, because we're going to apply head, 

33
00:02:17.901 --> 00:02:21.752
which requires a list to every element of 
a list. 

34
00:02:21.752 --> 00:02:26.624
So we do need a list of lists here. 
I'll make my list of lists, 

35
00:02:26.624 --> 00:02:30.240
list of lists of integers, and there we 
are. 

36
00:02:30.240 --> 00:02:35.359
Alright, 
and now let's save this and try this out. 

37
00:02:35.359 --> 00:02:43.530
Use map and filter.sml, and sure enough 
x1 is the list 5, 9, 13, 17, 

38
00:02:43.530 --> 00:02:49.883
and x2 is the list 1, 3, 5, which is what 
you get if you take the head of these 

39
00:02:49.883 --> 00:02:53.717
three lists here. 
their type of map is quite interesting, 

40
00:02:53.717 --> 00:02:58.369
and let's talk about that just a little 
bit more back here with the slide. 

41
00:02:58.369 --> 00:03:03.059
So here you see the code we wrote for 
map, and the type that we saw from the 

42
00:03:03.059 --> 00:03:07.642
Read About print loop is that map takes 
two arguments and returns something. 

43
00:03:07.642 --> 00:03:11.561
That's definitely true. 
The first argument can be a function from 

44
00:03:11.561 --> 00:03:14.816
any type alpha to any type beta, 
quote A arrow quote B. 

45
00:03:14.816 --> 00:03:17.530
The two types don't even have to be the 
same. 

46
00:03:17.530 --> 00:03:22.150
But there are some constraints, the 
second argument to map has to be a list 

47
00:03:22.150 --> 00:03:25.168
of alphas. 
So whatever the element type is of the 

48
00:03:25.168 --> 00:03:29.050
second argument has to be the argument 
type of that function F. 

49
00:03:29.050 --> 00:03:34.358
And what map returns is a beta list, a 
list whose elements are whatever type 

50
00:03:34.358 --> 00:03:37.781
this higher order function takes as its 
argument. 

51
00:03:37.781 --> 00:03:42.740
So it's very elegant to understand map. 
You need to understand its type. 

52
00:03:42.740 --> 00:03:46.442
It's an alpha aero beta star alpha list 
to beta list. 

53
00:03:46.442 --> 00:03:50.772
Alpha and beta can be the same. 
In this first example, where we 

54
00:03:50.772 --> 00:03:56.290
incremented every element of the list, we 
instantiated both alpha and beta with 

55
00:03:56.290 --> 00:03:59.084
int. 
But in this second example, where we 

56
00:03:59.084 --> 00:04:02.921
still have map of the same type, 
alpha is int list. 

57
00:04:02.921 --> 00:04:09.770
Head takes an int list and beta is int, 
because that's what head returns when 

58
00:04:09.770 --> 00:04:13.240
given an int list right. 
So that is map. 

59
00:04:13.240 --> 00:04:17.942
once you've learned it, once you've seen 
it, you end up using it all the time. 

60
00:04:17.942 --> 00:04:22.644
It's very often good style to use map 
because it communicates to the reader of 

61
00:04:22.644 --> 00:04:25.560
your code, what I'm doing here is a map 
operation. 

62
00:04:25.560 --> 00:04:30.322
I'm applying the same function to every 
element of some collection to produce a 

63
00:04:30.322 --> 00:04:32.355
corresponding collection. 
All right. 

64
00:04:32.355 --> 00:04:35.900
In fact, it's so common, it is 
pre-defined in standard ML standard 

65
00:04:35.900 --> 00:04:38.682
library, although it has a slightly 
different style. 

66
00:04:38.682 --> 00:04:42.990
It's, it doesn't have quite the type I've 
shown here, because it uses this thing 

67
00:04:42.990 --> 00:04:45.935
currying, that we're going to get to in a 
few segments. 

68
00:04:45.935 --> 00:04:49.590
But it's a, it's a very similar function 
that also performs mapping. 

69
00:04:49.590 --> 00:04:53.747
All right, so that was map. 
I promised you two hall of fame higher 

70
00:04:53.747 --> 00:04:56.677
order functions, so let's do the second 
one. 

71
00:04:56.677 --> 00:05:00.493
This is filter. 
It also takes an F and a list of X's but 

72
00:05:00.493 --> 00:05:04.991
F works differently here. 
Here we expect f to return true or false, 

73
00:05:04.991 --> 00:05:10.716
and what we're going to compute is a list 
that's a subset of the elements in X's in 

74
00:05:10.716 --> 00:05:14.601
the same order. 
And what we're going to do is we're going 

75
00:05:14.601 --> 00:05:18.690
to filter out any elements of X's for 
which F returns false. 

76
00:05:18.690 --> 00:05:23.356
So once again, we need a case for the 
empty list and a case for the non-empty 

77
00:05:23.356 --> 00:05:27.963
list, and if you don't start with any 
elements, no matter what you, there will 

78
00:05:27.963 --> 00:05:30.508
be nothing to even potentially filter 
out. 

79
00:05:30.508 --> 00:05:34.933
You'll just end up with no elements, 
whereas if you have a non-empty list, 

80
00:05:34.933 --> 00:05:39.660
well, whether to include X in the output 
or not depends on what F of X returns. 

81
00:05:39.660 --> 00:05:44.448
If F of X returns true, then we want X in 
our output, and the rest of our output 

82
00:05:44.448 --> 00:05:48.040
should be the result of filtering F with 
X's prime. 

83
00:05:48.040 --> 00:05:53.460
Otherwise, we just want to have F of X as 
prime. 

84
00:05:53.460 --> 00:05:55.920
There are other ways we could have 
written this. 

85
00:05:55.920 --> 00:06:00.748
for example, we could have written if. 
if fx, then and try to append the result. 

86
00:06:00.748 --> 00:06:05.788
But this is probably the most elegant 
way, and it says pretty directly what it 

87
00:06:05.788 --> 00:06:09.988
is we're trying to do. 
as before we can write a couple simpler 

88
00:06:09.988 --> 00:06:13.800
examples of this. 
Instead of actually showing examples that 

89
00:06:13.800 --> 00:06:18.776
process actual lists, how about we define 
some functions that use filter as a 

90
00:06:18.776 --> 00:06:22.440
helper function. 
so for my first example, I'll write this 

91
00:06:22.440 --> 00:06:26.723
out with a top-level function so it's a 
little easier for you to read. 

92
00:06:26.723 --> 00:06:31.618
If we wanted to take a list of integers 
and return only the even numbers out of 

93
00:06:31.618 --> 00:06:34.800
that list then I could write a function 
all even. 

94
00:06:34.800 --> 00:06:39.960
That just called filter with that is even 
function I just wrote and x's. 

95
00:06:39.960 --> 00:06:43.127
Alright. 
Here's a more complicated example that's 

96
00:06:43.127 --> 00:06:47.717
going to use a more sophisticated 
anonymous function, just because I 

97
00:06:47.717 --> 00:06:51.661
thought it would be fun. 
Let's take a list of pairs, where the 

98
00:06:51.661 --> 00:06:56.574
second thing has to be an integer, and 
return the elements where that second 

99
00:06:56.574 --> 00:07:00.711
thing is an even integer. 
So, I'm using a little pattern there in 

100
00:07:00.711 --> 00:07:04.720
my anonymous function. 
I need to write the fun keyword here. 

101
00:07:04.720 --> 00:07:06.265
Okay. 
and X's. 

102
00:07:06.265 --> 00:07:11.674
and I have too few parentheses. 
How about right there? 

103
00:07:11.674 --> 00:07:16.600
I think that's right. 
let's go over and try this. 

104
00:07:19.800 --> 00:07:26.772
And sure enough, all even is a nice 
filter function from int list to int 

105
00:07:26.772 --> 00:07:30.161
list. 
Let's try it out really quick. 

106
00:07:30.161 --> 00:07:36.249
All even of 3, 4, 6, 0, 13. 
And we get back the list 4, 6, 0. 

107
00:07:36.249 --> 00:07:41.233
I'll leave it to you to test out all even 
of the second things of pairs, if you're 

108
00:07:41.233 --> 00:07:42.874
interested in that one. 
Okay? 

109
00:07:42.874 --> 00:07:47.271
So, filter, which you see here on the 
slide, is also one of these very famous 

110
00:07:47.271 --> 00:07:49.968
functions. 
It's just part of the vocabulary of 

111
00:07:49.968 --> 00:07:53.310
computer science. 
Also in the standard library using that 

112
00:07:53.310 --> 00:07:57.121
currying feature we'll get to. 
But let's finish up this segment by 

113
00:07:57.121 --> 00:08:01.462
looking at the type of filter. 
It does take a list of alphas and it 

114
00:08:01.462 --> 00:08:05.296
returns a list of alphas. 
Unlike map we're not computing anything 

115
00:08:05.296 --> 00:08:09.483
based in terms of the elements. 
What we're returning is a subset of the 

116
00:08:09.483 --> 00:08:14.084
elements, keeping the same order and so 
the alpha list for the argument can be 

117
00:08:14.084 --> 00:08:17.977
the alpha list for the result. 
We can pass an ent list, string list, 

118
00:08:17.977 --> 00:08:22.460
lists of lists of ints, whatever but the 
output list will have the same type. 

119
00:08:22.460 --> 00:08:26.627
And the argument for F, that F argument, 
has type alpha aero bool. 

120
00:08:26.627 --> 00:08:31.445
We definitely pass elements of the 
argument list to F, so it has to be the 

121
00:08:31.445 --> 00:08:35.612
same type that F expects and that the 
elements of the list have. 

122
00:08:35.612 --> 00:08:40.952
And F needs to return a bool because we 
use it right here in the position between 

123
00:08:40.952 --> 00:08:46.291
if and then, and we know from very early 
in the course that for an if then else to 

124
00:08:46.291 --> 00:08:51.240
type check, the result of this expression 
after the if has to have type bool. 

125
00:08:51.240 --> 00:08:55.666
So there you are, probably two of the 
most famous functions in all of computer 

126
00:08:55.666 --> 00:08:56.972
science, map and filter. 