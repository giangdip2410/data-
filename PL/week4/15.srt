WEBVTT

1
00:00:00.012 --> 00:00:05.468
[MUSIC] There are just a couple more 
topics I want to cover with currying, and 

2
00:00:05.468 --> 00:00:11.136
the first is that sometimes the function 
you want to call isn't organized the way 

3
00:00:11.136 --> 00:00:15.673
you might wish it were. 
Maybe you want to curry function and it's 

4
00:00:15.673 --> 00:00:21.192
a tupled function, or you want a tupled 
function and it's a curried function. 

5
00:00:21.192 --> 00:00:25.461
Or maybe you want to use partial 
application but not with the first few 

6
00:00:25.461 --> 00:00:28.549
arguments. 
Maybe with the later arguments and you 

7
00:00:28.549 --> 00:00:31.687
can't do that. 
Given a curried function, you have to 

8
00:00:31.687 --> 00:00:35.742
pass the first argument to it. 
But what we could do is use our idea of 

9
00:00:35.742 --> 00:00:40.341
combining functions to, once and for all, 
write very generic, very reusable 

10
00:00:40.341 --> 00:00:44.915
functions like we did with function 
composition, that let us change one kind 

11
00:00:44.915 --> 00:00:48.598
of function into another. 
So let me motivate that with a short 

12
00:00:48.598 --> 00:00:51.383
example. 
We've seen this example before where I 

13
00:00:51.383 --> 00:00:56.210
wanted to take this function range, which 
takes two numbers, i and j and returns a 

14
00:00:56.210 --> 00:01:00.628
list with all the numbers from i up to j, 
use that to create a helper function 

15
00:01:00.628 --> 00:01:04.984
countup that just goes from one to the 
number and then use that A countup 

16
00:01:04.984 --> 00:01:07.908
function. 
So this code as written, will not work. 

17
00:01:07.908 --> 00:01:12.148
And that's because this version of range, 
is tupled. It takes a pair. 

18
00:01:12.148 --> 00:01:14.741
And here I tried to use partial 
application. 

19
00:01:14.741 --> 00:01:19.312
Now of course, I could work around this, 
or I could change range, but there's a 

20
00:01:19.312 --> 00:01:24.746
very general thing I could do, which is 
to take a, write a function that takes a 

21
00:01:24.746 --> 00:01:29.931
function expecting a pair and return the 
same function in curried form. 

22
00:01:29.931 --> 00:01:33.502
So it's basically takes a function and 
curries it. 

23
00:01:33.502 --> 00:01:38.675
So what if I did this, I can take this 
function f and then I would return a 

24
00:01:38.675 --> 00:01:42.103
function that takes 2 arguments in 
curried form. 

25
00:01:43.262 --> 00:01:49.122
And then calls f with the pair because f 
expects a pair but curry of f will return 

26
00:01:49.122 --> 00:01:54.452
a two argument curried function. 
And now, down here, for count up, I could 

27
00:01:54.452 --> 00:01:58.292
just, and still call, instead call, curry 
of range. 

28
00:01:58.292 --> 00:02:03.381
And this, will now work. 
So that's pretty neat, let me clean it up 

29
00:02:03.381 --> 00:02:08.948
a little bit more, just by using the 
syntactic sugar we've seen before. 

30
00:02:08.948 --> 00:02:15.143
I could of just written it like this. 
That's curry and at the call site, these 

31
00:02:15.143 --> 00:02:20.245
parenthesis, are optional. 
We can go the other diretion as well. 

32
00:02:20.245 --> 00:02:26.160
If we add a curry'ed function but we 
wanted to pass it a tuple and that could 

33
00:02:26.160 --> 00:02:31.828
actually be useful, if you are composing 
functions, or chaining them together. 

34
00:02:31.828 --> 00:02:37.904
We could take 2. We, we we could take f, 
and x,y and return a function, that would 

35
00:02:37.904 --> 00:02:41.784
look like this. 
So now when you call uncurry, with some 

36
00:02:41.784 --> 00:02:47.754
functions foo you would get back a 
function that expected a pair and then 

37
00:02:47.754 --> 00:02:53.018
called f with 2 arguments in curried 
form, so that's pretty neat. 

38
00:02:53.018 --> 00:02:58.381
let me quickly show you the types of 
curry and uncurry. 

39
00:02:58.381 --> 00:03:04.243
They're very generic and I will leave you 
to puzzle over them, but I want to point 

40
00:03:04.243 --> 00:03:08.939
out one very neat thing. 
There is a very deep connection to logic 

41
00:03:08.939 --> 00:03:14.618
here, you're not responsible for this, 
but if you have studied logic Read these 

42
00:03:14.618 --> 00:03:18.577
as logical formulas where the star is 
and, and the arrow is implies. 

43
00:03:18.577 --> 00:03:23.215
And you'll see that these are actually 
true logical formulas and that hints that 

44
00:03:23.215 --> 00:03:27.931
there's actually a very deep connection, 
a very mathematical connection between 

45
00:03:27.931 --> 00:03:31.030
tuppling and currying. 
And I'm going to leave that as a 

46
00:03:31.030 --> 00:03:35.212
mysterious statement for you. 
one other thing I wanted to show you that 

47
00:03:35.212 --> 00:03:39.369
also has these logical formulas. 
Once you look at their type, is switching 

48
00:03:39.369 --> 00:03:43.257
the arguments of curried functions. 
So if you had a 2 argument curried 

49
00:03:43.257 --> 00:03:48.022
function and you wanted to partially 
apply it to the first argument, or to the 

50
00:03:48.022 --> 00:03:52.947
first argument instead of the first, you 
couldn't do that unless you took that 

51
00:03:52.947 --> 00:03:56.417
function and passed it to this function 
first instead. 

52
00:03:56.417 --> 00:04:01.087
So, f takes two curried arguments, but 
other curried of f will just take the 

53
00:04:01.087 --> 00:04:05.692
arguments in the opposite order. 
It takes an x and a y and then it calls f 

54
00:04:05.692 --> 00:04:10.222
with y and x and we've seen before 
there's syntactic sugar for this. We 

55
00:04:10.222 --> 00:04:14.419
could just write it, that way. 
Okay, so just more fun playing around 

56
00:04:14.419 --> 00:04:18.285
with combining functions. 
Hopefully I've shown you that this thing 

57
00:04:18.285 --> 00:04:22.201
is at least a little bit useful. 
And functional programmers do often 

58
00:04:22.201 --> 00:04:26.507
program with these things, in order to 
get things elegant, and pretty, and 

59
00:04:26.507 --> 00:04:30.664
arranged just how they want. 
So, that was one topic I wanted to 

60
00:04:30.664 --> 00:04:33.711
discuss. 
The other, is people often want to know, 

61
00:04:33.711 --> 00:04:38.265
isn't currying really slow? If I want to 
create all these closures to call a 

62
00:04:38.265 --> 00:04:41.245
function. 
And it turns out, that it depends, and 

63
00:04:41.245 --> 00:04:46.436
that's up to the language implementation. 
And language implementations can actually 

64
00:04:46.436 --> 00:04:51.208
make curried functions very efficient. 
So in general, both calling a function 

65
00:04:51.208 --> 00:04:55.952
with a tupple, and calling a function via 
currying with multiple arguments. 

66
00:04:55.952 --> 00:05:02.327
These are plenty fast. 
These are constant time operations. 

67
00:05:02.327 --> 00:05:10.854
You should program in a way, that, makes 
your code elegant, short, concise, and 

68
00:05:10.854 --> 00:05:13.022
correct. 
Alright. 

69
00:05:13.022 --> 00:05:16.828
Well then maybe you might want to know 
which is, is faster. 

70
00:05:16.828 --> 00:05:19.717
This is not part of the language 
definition. 

71
00:05:19.717 --> 00:05:22.797
It will depend on the language 
implementation. 

72
00:05:22.797 --> 00:05:27.758
And it turns out that the implementation 
of SML that we are using, the SML New 

73
00:05:27.758 --> 00:05:31.922
Jersey compiler, does faster with tupling 
than with currying. 

74
00:05:31.922 --> 00:05:37.231
So kind were in fact were be a bit slower 
for the function calling times and times 

75
00:05:37.231 --> 00:05:42.094
and times of time for performance 
critical application where it actually 

76
00:05:42.094 --> 00:05:46.983
matters, I should point out this is 
actually not necessarily the case, in 

77
00:05:46.983 --> 00:05:52.586
fact most of their functional programming 
language implementations out there today 

78
00:05:52.586 --> 00:05:56.522
OCaml Fsharp Haskell to better with 
currying, than with. 

79
00:05:56.522 --> 00:05:59.412
Coupling. 
Now, the optimizer might do very well 

80
00:05:59.412 --> 00:06:02.773
with both of them. 
But in those other languages, we tell 

81
00:06:02.773 --> 00:06:05.852
performance conscious programmers, use 
currying. 

82
00:06:05.852 --> 00:06:09.609
It'll work just fine. 
If you use partial application, which is 

83
00:06:09.609 --> 00:06:13.262
something up to callers. 
That might be a little bit slower. 

84
00:06:13.262 --> 00:06:17.921
But in languages where currying is always 
the norm, we tell programmers even when 

85
00:06:17.921 --> 00:06:21.812
they're learning to program, oh it's just 
the 3-argument function. 

86
00:06:21.812 --> 00:06:26.168
And the same way I lied to you at first 
and told you that tuple's version was a 

87
00:06:26.168 --> 00:06:29.744
3-argument function and then went back 
and told you the truth. 

88
00:06:29.744 --> 00:06:32.741
That's what these other languages do with 
currying. 

89
00:06:32.741 --> 00:06:36.569
Currying is the default. 
Almost everything is curried and you only 

90
00:06:36.569 --> 00:06:38.786
tuple things in those situations where 