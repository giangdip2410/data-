WEBVTT

1
00:00:00.000 --> 00:00:04.940
[SOUND]. 

2
00:00:04.940 --> 00:00:08.516
Now that we've learned anonymous 
functions, I want to show you one 

3
00:00:08.516 --> 00:00:11.142
programming pattern that's actually poor 
style. 

4
00:00:11.142 --> 00:00:15.332
It's actually an over use of anonymous 
functions where you don't need them, 

5
00:00:15.332 --> 00:00:19.299
and that's something that I like to call 
unnecessary function wrapping. 

6
00:00:19.299 --> 00:00:23.770
Although, I'm pretty sure I made up that 
particular term for it, but not the idea. 

7
00:00:23.770 --> 00:00:27.716
So, let's go over here, 
use our same higher order function we've 

8
00:00:27.716 --> 00:00:32.540
been playing around with for a long time, 
n times, and try to write one of the 

9
00:00:32.540 --> 00:00:37.051
things it's really useful for, which is 
taking the Nth tail of some list. 

10
00:00:37.051 --> 00:00:41.374
So I'm going to have N and Xs, which is 
going to be my list, and I want to N 

11
00:00:41.374 --> 00:00:46.323
times take the tail of the list, so my 
second and third argument to N times are 

12
00:00:46.323 --> 00:00:50.276
clearly going to be N and Xs. 
But for the first argument, we realize, 

13
00:00:50.276 --> 00:00:54.774
well, we just need a function right here 
that takes the tail of its argument, and 

14
00:00:54.774 --> 00:00:57.810
we just learned anonymous functions, so 
let's use them. 

15
00:00:57.810 --> 00:01:01.610
Right? 
Let's say, fun Y, tail of Y. 

16
00:01:01.610 --> 00:01:06.110
And this will work and it's correct and 
we feel good about using anonymous 

17
00:01:06.110 --> 00:01:10.610
functions, and I'm going to argue this as 
actually just a very minor bit right 

18
00:01:10.610 --> 00:01:13.550
there of, of inferior style. 
And here's why. 

19
00:01:13.550 --> 00:01:19.114
Let's look at this function we wrote and 
let's describe what it does. 

20
00:01:19.114 --> 00:01:24.678
This is a function that takes one 
argument and returns the list tail of 

21
00:01:24.678 --> 00:01:28.611
that argument. 
Is there a simpler expression, a more 

22
00:01:28.611 --> 00:01:34.017
straightforward way of writing down here 
an expression that is a function that 

23
00:01:34.017 --> 00:01:38.807
takes the tail of its argument? 
Yes, there is, and that is to just write 

24
00:01:38.807 --> 00:01:40.170
tail. 
Right? 

25
00:01:40.170 --> 00:01:44.879
Tail is a variable that, when we look it 
up in the environment, we get a function 

26
00:01:44.879 --> 00:01:48.941
that does exactly the right thing. 
The other version is wrapping that 

27
00:01:48.941 --> 00:01:53.887
perfectly good function that does exactly 
what we want with another function that's 

28
00:01:53.887 --> 00:01:56.477
going to do the same thing. 
It's just longer. 

29
00:01:56.477 --> 00:02:00.775
It's a tiny bit slower, since one 
function has to call another one, and it 

30
00:02:00.775 --> 00:02:05.072
obscures the fact that what we want to 
pass to N times is a perfectly good 

31
00:02:05.072 --> 00:02:09.800
function for taking the tail. 
So that's unnecessary function wrapping. 

32
00:02:09.800 --> 00:02:15.540
To kind of explain in general what's 
going on, let me try an analogy for you. 

33
00:02:15.540 --> 00:02:19.043
'Kay. 
We've emphasized previously, and you may 

34
00:02:19.043 --> 00:02:24.559
have seen in previous programming 
courses, that you shouldn't write things 

35
00:02:24.559 --> 00:02:29.851
like if X then true, else false. 
This is an expression that returns true 

36
00:02:29.851 --> 00:02:35.814
if X is true and false if X is false, but 
another thing that does that is just X. 

37
00:02:35.814 --> 00:02:38.945
Right? 
We don't need the if then else X is 

38
00:02:38.945 --> 00:02:44.983
already the expression that we want. And 
similarly, if you have a function like 

39
00:02:44.983 --> 00:02:48.710
take NX and return the result of calling 
F with X, 

40
00:02:48.710 --> 00:02:53.414
the expression, F, will do just as well. 
So that's the most common situation, 

41
00:02:53.414 --> 00:02:57.928
where you'll see this unnecessary 
function wrapping is when we have an 

42
00:02:57.928 --> 00:03:02.950
anonymous function that has this form, 
that all it does is pass its argument to 

43
00:03:02.950 --> 00:03:08.036
another function, then we should just use 
that function, like tail in our example, 

44
00:03:08.036 --> 00:03:10.430
in place of it. 
That's really the idea. 

45
00:03:10.430 --> 00:03:15.251
Let me show you one other related thing. 
somewhat similar, also unnecessary 

46
00:03:15.251 --> 00:03:20.261
function wrapping, but comes up a little 
less often and is a little less obvious, 

47
00:03:20.261 --> 00:03:24.206
that's what's going on. 
let me, for example, you probably don't 

48
00:03:24.206 --> 00:03:29.028
know this, in the standard library for 
ML, ML, there's a function list.rev that 

49
00:03:29.028 --> 00:03:32.269
reverses a list. 
So suppose you were going to use this a 

50
00:03:32.269 --> 00:03:36.747
lot, or you had trouble remembering, that 
it was list dot, and in some file, you 

51
00:03:36.747 --> 00:03:41.170
just wanted, your own function, rev, that 
did the same thing, but, of course, you 

52
00:03:41.170 --> 00:03:44.864
don't want to re-implement reverse, 
there's a perfectly good library 

53
00:03:44.864 --> 00:03:47.160
function. 
So you would write it like this. 

54
00:03:47.160 --> 00:03:50.119
So this is also unnecessary function 
wrapping. 

55
00:03:50.119 --> 00:03:55.202
I have a function reverse that takes in 
one argument, x's, and returns, it's body 

56
00:03:55.202 --> 00:04:00.723
is calling list.rev rev with x's. 
If we use the sort of de-sugared version 

57
00:04:00.723 --> 00:04:06.007
of this, that might be more obvious, 
since our function, rev, is not 

58
00:04:06.007 --> 00:04:10.520
recursive. 
We could have written it like this. 

59
00:04:10.520 --> 00:04:16.303
And now we see indeed this anonymous 
function here has exactly the pattern 

60
00:04:16.303 --> 00:04:19.618
that is this unnecessary function 
wrapping, 

61
00:04:19.618 --> 00:04:25.556
and indeed, a, a superior style solution 
would be to just write val rev equals 

62
00:04:25.556 --> 00:04:26.618
list.rev. 
Right. 

63
00:04:26.618 --> 00:04:31.166
This may look a little strange to you, 
but it's a great use of first class 

64
00:04:31.166 --> 00:04:34.178
functions. 
I'm defining a variable rev, and what I 

65
00:04:34.178 --> 00:04:38.419
will bind it to is the result of 
evaluating this expression list.rev. 

66
00:04:38.419 --> 00:04:43.212
So I look up list.rev in my environment, 
I get a function back, and so rev will 

67
00:04:43.212 --> 00:04:46.040
now be bound to the same function as 
list.rev. 

68
00:04:46.040 --> 00:04:49.883
So whenever you want a shorter or 
simpler, easy to remember name for a 

69
00:04:49.883 --> 00:04:54.331
function that's defined somewhere else, I 
really prefer this third version to the 

70
00:04:54.331 --> 00:04:58.944
first version because again it's a little 
simpler, it's more direct to what it is 

71
00:04:58.944 --> 00:05:03.063
you're doing and it's actually even a 
little bit faster because you're not 

72
00:05:03.063 --> 00:05:05.040
making an unnecessary function call. 