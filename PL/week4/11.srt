WEBVTT

1
00:00:00.000 --> 00:00:04.940
[SOUND] 

2
00:00:04.940 --> 00:00:10.166
Now I want to show you another famous 
higher order function that recursively 

3
00:00:10.166 --> 00:00:15.665
traverses over data structures and then 
use that to show you more examples using 

4
00:00:15.665 --> 00:00:21.163
closures and emphasize what these sort of 
iterative these higher order functions 

5
00:00:21.163 --> 00:00:25.169
are really all about. 
So it's called fold, it's very similar, 

6
00:00:25.169 --> 00:00:30.328
possibly even a synonym to similarly well 
known names like reduce or inject. 

7
00:00:30.328 --> 00:00:35.690
And the idea is to traverse a recursive 
data structure like a list, in order to 

8
00:00:35.690 --> 00:00:37.577
produce a single answer. 
Okay? 

9
00:00:37.577 --> 00:00:42.410
So the wave fold is going to work, we're 
going to define a function fold, is we're 

10
00:00:42.410 --> 00:00:47.112
going to pass in a function f. 
An initial value, which I'll call ac for 

11
00:00:47.112 --> 00:00:51.408
accumulator and a list. 
And what we're going to do, as you can 

12
00:00:51.408 --> 00:00:56.889
kind of see here, is apply f to the 
accumulator and the first element of the 

13
00:00:56.889 --> 00:00:59.564
list. 
Take that result and pass it to f with 

14
00:00:59.564 --> 00:01:03.702
the second element in the list. 
Take that result and pass it to f with 

15
00:01:03.702 --> 00:01:08.371
the third element in the list and so on. 
So you can imagine, if you imagine your 

16
00:01:08.371 --> 00:01:12.448
list laid out from left to right, that 
you really are folding over it. 

17
00:01:12.448 --> 00:01:16.526
You're going over it starting with the 
accumulator, applying f to the 

18
00:01:16.526 --> 00:01:19.718
accumulator in the first element to get 
another value. 

19
00:01:19.718 --> 00:01:24.387
Applying f to that value in the second 
element, that value in the third element 

20
00:01:24.387 --> 00:01:28.820
and so on until you reach the end of the 
list and that's your final result. 

21
00:01:28.820 --> 00:01:34.155
As co, as common a language with higher 
order functions and convenient syntax 

22
00:01:34.155 --> 00:01:37.967
like ML, I can write that function in 
about three lines. 

23
00:01:37.967 --> 00:01:43.025
take in f, then initial commuter and x's, 
if the list is empty, then the 

24
00:01:43.025 --> 00:01:46.560
accumulator is itself the result we want. 
Otherwise. 

25
00:01:46.560 --> 00:01:51.654
Compute f of accumulator in x and pass 
that, twofold, with f and the rest of the 

26
00:01:51.654 --> 00:01:54.556
list. 
Here, I'm shadowing, this x is here in my 

27
00:01:54.556 --> 00:01:57.522
pattern. 
So this is folding left over the list. 

28
00:01:57.522 --> 00:02:00.682
If we write down our list elements, left 
to right, 

29
00:02:00.682 --> 00:02:05.454
we can write a different version of fold 
that would go from right to left. 

30
00:02:05.454 --> 00:02:09.129
that version couldn't be tail recursive 
quite as well. 

31
00:02:09.129 --> 00:02:12.547
And the order doesn't matter, unless it 
matters for f. 

32
00:02:12.547 --> 00:02:17.513
So that's why, in the standard library, 
they actually do distinguish left from 

33
00:02:17.513 --> 00:02:20.151
right. 
And the type of fold tells you a lot 

34
00:02:20.151 --> 00:02:23.801
about what it does. 
If we type this into the read of l print 

35
00:02:23.801 --> 00:02:28.325
loop, what we would get is that the 
function f can take any two types alpha 

36
00:02:28.325 --> 00:02:31.299
and beta. 
Maybe they are the same, maybe they are 

37
00:02:31.299 --> 00:02:35.642
different but it has to return something 
of type alpha because the older 

38
00:02:35.642 --> 00:02:39.390
accumulator and new accumulator have to 
be values of same type. 

39
00:02:39.390 --> 00:02:42.983
That type alpha has to be the type of 
acc, the accumulator. 

40
00:02:42.983 --> 00:02:48.000
The list has the ty, the elements of type 
beta, that other argument we passed to f. 

41
00:02:48.000 --> 00:02:52.770
And then the result of the entire thing 
has the same type as the type of our 

42
00:02:52.770 --> 00:02:56.859
accumulator, and that's alpha. 
So you start with a beta list, and an 

43
00:02:56.859 --> 00:03:00.576
alpha, and an initial answer. 
You use f to fold over the list, 

44
00:03:00.576 --> 00:03:03.797
producing a new answer at each position 
in the list. 

45
00:03:03.797 --> 00:03:08.320
When you get to the end of the list, your 
final answer is that last alpha. 

46
00:03:08.320 --> 00:03:11.736
So that is fold. 
Let me talk about why we're so excited 

47
00:03:11.736 --> 00:03:15.463
about these things. 
So these iterator like functions are not 

48
00:03:15.463 --> 00:03:19.127
built into the language. 
There's just a programming pattern. 

49
00:03:19.127 --> 00:03:22.420
We just wrote it on the slide. 
It's three lines of ML. 

50
00:03:22.420 --> 00:03:26.121
Now many languages provide built in 
support for iterating over a data 

51
00:03:26.121 --> 00:03:29.558
structure and computing a result like, 
like we would do with fold. 

52
00:03:29.558 --> 00:03:32.096
And there's nothing wrong with built in 
support. 

53
00:03:32.096 --> 00:03:35.533
These things are so common. 
Maybe that's a reasonable thing to do. 

54
00:03:35.533 --> 00:03:39.975
they also provide special features like 
usually you could stop half way down the 

55
00:03:39.975 --> 00:03:42.196
list. 
Whereas fold is all the way, going to 

56
00:03:42.196 --> 00:03:47.535
always go all the way down the list. 
But when we have fold, we can just write 

57
00:03:47.535 --> 00:03:51.715
it in our language we have higher order 
functions and it's really a concept. 

58
00:03:51.715 --> 00:03:56.206
We wrote fold here over lists. 
If we had a different data structure like 

59
00:03:56.206 --> 00:04:01.010
an array or a tree or a graph or a set, 
we could write fold over that as well. 

60
00:04:01.010 --> 00:04:05.208
And then, of course, we're going to use 
fold with lots of different clients 

61
00:04:05.208 --> 00:04:09.467
passing in lots of different f. 
So what I love about this is that it's a 

62
00:04:09.467 --> 00:04:12.956
separation of concerns. 
One group of people can worry about 

63
00:04:12.956 --> 00:04:17.687
writing fold over some complicated data 
structure, lists are not complicated but 

64
00:04:17.687 --> 00:04:22.123
there are much more complicated things 
out there, and then someone else can 

65
00:04:22.123 --> 00:04:26.381
worry about how to compute over a 
particular for a particular result. 

66
00:04:26.381 --> 00:04:30.875
And then, if you change and you start 
using a different data structure other 

67
00:04:30.875 --> 00:04:34.720
than a list, you can reuse your function, 
you just need a new fold. 

68
00:04:34.720 --> 00:04:39.195
And conversely once you've written fold 
for list, lots of different people can 

69
00:04:39.195 --> 00:04:41.778
use fold for list for different 
computations. 

70
00:04:41.778 --> 00:04:46.254
So it really separates two things out 
simply by using a higher order function 

71
00:04:46.254 --> 00:04:48.626
and passing one function to another. 
Okay. 

72
00:04:48.626 --> 00:04:53.096
Enough hypothesizing and theorizing. 
Let's get to the code and show you a 

73
00:04:53.096 --> 00:04:57.995
bunch of example uses of fold since you 
may still be getting the hang of how it 

74
00:04:57.995 --> 00:05:00.444
works. 
I've purposely given all of these 

75
00:05:00.444 --> 00:05:04.180
functions non revealing names so you can 
kind of play along. 

76
00:05:04.180 --> 00:05:06.041
So here is fold up here. 
Right? 

77
00:05:06.041 --> 00:05:11.710
Remember it's going to apply f to the 
accumulator in the first one on the list, 

78
00:05:11.710 --> 00:05:16.663
get a result, apply that to with that on 
the second on the list and so on. 

79
00:05:16.663 --> 00:05:21.030
So what we do here in this first call is 
we pass in some list x's. 

80
00:05:21.030 --> 00:05:25.695
Our initial accumulator is zero, and what 
we do every time, the first argument to 

81
00:05:25.695 --> 00:05:30.302
this anonymous function is going to be 
the next, is the accumulator, the current 

82
00:05:30.302 --> 00:05:34.092
accumulator, and the second thing is the 
next element on the list. 

83
00:05:34.092 --> 00:05:38.408
You can see that right here in full. 
So what we do here at each step is we 

84
00:05:38.408 --> 00:05:43.015
take what was the accumulator, and the 
next element on the list, and we add them 

85
00:05:43.015 --> 00:05:45.194
together. 
That will be our new accumulator. 

86
00:05:45.194 --> 00:05:48.304
Then we'll get to the next one on the 
list, and we'll add that. 

87
00:05:48.304 --> 00:05:50.410
Get the next one on the list, and add 
that. 

88
00:05:50.410 --> 00:05:54.271
So when I describe it that way, it seems 
pretty clear that this is a one line 

89
00:05:54.271 --> 00:05:57.130
solution, give and fold, to summing the 
elements on a list. 

90
00:05:57.130 --> 00:06:01.525
Let's do another one. 
Here I also have a list, my initial 

91
00:06:01.525 --> 00:06:05.683
accumulator is true. 
So at each step, I am going to produce a 

92
00:06:05.683 --> 00:06:09.079
boolean. 
You can't change the type of your 

93
00:06:09.079 --> 00:06:13.861
accumulator, so the language with a 
strong type system and here is my 

94
00:06:13.861 --> 00:06:17.604
anonymous function. 
Remember x is going to be, what the 

95
00:06:17.604 --> 00:06:22.732
accumulator, fold is going to pass back 
into our closure, whatever the next 

96
00:06:22.732 --> 00:06:26.405
accumulator is and y is the next element 
on the list. 

97
00:06:26.405 --> 00:06:31.950
So what we do is we take our accumulator 
and is y greater than or equal to zero. 

98
00:06:31.950 --> 00:06:37.159
So if y is, negative, we're going to get 
false for this whole thing. 

99
00:06:37.159 --> 00:06:43.030
If x is false, we're going to get a false 
for this whole thing, and x keeps 

100
00:06:43.030 --> 00:06:49.398
updating with each element of the list. 
So what this ends up doing is, are all 

101
00:06:49.398 --> 00:06:55.801
list elements, positive? 
Excuse me non negative, if you want to be 

102
00:06:55.801 --> 00:06:58.045
picky, alright. 
Alright? 

103
00:06:58.045 --> 00:07:00.998
Okay. 
So, both those examples do not use 

104
00:07:00.998 --> 00:07:02.588
private data. 
Alright? 

105
00:07:02.588 --> 00:07:06.602
These closures we passed in, only use 
their arguments. 

106
00:07:06.602 --> 00:07:12.281
Now, lets see the real power of closures, 
which is that you can choose other 

107
00:07:12.281 --> 00:07:14.780
things. 
So, here is a call to fold. 

108
00:07:14.780 --> 00:07:17.974
x's is my list, 0's my initial 
accumulator. 

109
00:07:17.974 --> 00:07:23.753
x is always the current accumulator. 
y is the next element of the list and I 

110
00:07:23.753 --> 00:07:27.936
am adding to it. 
So I'm summing something here, but what 

111
00:07:27.936 --> 00:07:33.868
I'm adding here is if y is greater than 
or equal to low and y is less than or 

112
00:07:33.868 --> 00:07:37.188
equal to high then one else is zero. 
Okay? 

113
00:07:37.188 --> 00:07:41.474
So notice I am using private data here, 
low and high, referred to these things 

114
00:07:41.474 --> 00:07:44.592
that are only in scope here where I 
define the function. 

115
00:07:44.592 --> 00:07:47.264
But that's great. 
Closures are powerful that way. 

116
00:07:47.264 --> 00:07:53.207
And then I compute either one or zero. 
So what this is actually doing is 

117
00:07:53.207 --> 00:08:00.300
counting the number of elements between 
low and high inclusive. 

118
00:08:01.820 --> 00:08:04.537
Me. 
It's almost one line long. 

119
00:08:04.537 --> 00:08:07.960
It got a little long for me. 
Okay, here's another one. 

120
00:08:07.960 --> 00:08:13.086
this is similar to something we did in 
the previous segment, now I'm going to 

121
00:08:13.086 --> 00:08:17.945
take in list of strings and a string. 
And I'm going to call fold, I'm going to 

122
00:08:17.945 --> 00:08:23.435
produce a boolean here, starting with the 
list exis, and my closure here says x and 

123
00:08:23.435 --> 00:08:28.021
also something, so I'm doing the same 
game as I was doing previously of 

124
00:08:28.021 --> 00:08:31.702
computing is something true of every 
element of the list. 

125
00:08:31.702 --> 00:08:36.417
If you fold over in this way you're going 
to do a for all if you will, 

126
00:08:36.417 --> 00:08:42.524
are all elements of the list such that 
there size is strictly less than i, where 

127
00:08:42.524 --> 00:08:49.166
i is this variable I can bound up here 
computing ones to avoid recombination, 

128
00:08:49.166 --> 00:08:54.562
the size of the string s. 
So, what this ends up doing is computing 

129
00:08:54.562 --> 00:09:00.789
our all elements of the list, strings 
whose size are strictly less than the 

130
00:09:00.789 --> 00:09:01.917
size of s. 
Okay. 

131
00:09:01.917 --> 00:09:06.080
And I avoided recomputation like we saw 
in the previous segment. 

132
00:09:06.080 --> 00:09:12.120
one more example here of some different 
function, this one is more generic. 

133
00:09:12.120 --> 00:09:18.200
Okay. 
So f5 takes in a function g and the list 

134
00:09:18.200 --> 00:09:22.032
x's. 
And it passes x as the fold, initial 

135
00:09:22.032 --> 00:09:29.015
acumulator of true, but what it does is 
it says x and also g of y, so now call is 

136
00:09:29.015 --> 00:09:35.649
of f5 will pass in a function that says 
well this is how you decide if this 

137
00:09:35.649 --> 00:09:42.282
element to the list passes the test. 
And it's f5's job to use full to see if 

138
00:09:42.282 --> 00:09:49.003
therefore do they all pass the test? 
So this is really saying do all elements 

139
00:09:49.003 --> 00:09:52.670
of the list produce true when passed to 
g? 

140
00:09:52.670 --> 00:09:57.839
And now, given that reusable function, 
I could redefine f4 without using fold 

141
00:09:57.839 --> 00:10:00.696
directly. 
I could just use f5 as my helper 

142
00:10:00.696 --> 00:10:04.369
function. 
And all I have to do is call f5 with this 

143
00:10:04.369 --> 00:10:07.294
simple anonymous function, and the list 
x's. 

144
00:10:07.294 --> 00:10:11.240
So this is just another way to use higher 
order functions. 

145
00:10:11.240 --> 00:10:15.389
f5 is using closures here. 
Notice this g is defined where the 

146
00:10:15.389 --> 00:10:17.330
function is defined. 
Alright. 

147
00:10:17.330 --> 00:10:23.206
So that was several examples, and let me 
just remind you why I'm showing you this, 

148
00:10:23.206 --> 00:10:28.502
which is that map filter and fold do 
become much more powerful, thanks to 

149
00:10:28.502 --> 00:10:33.435
closures and lexical scope. 
We can pass in any private data that are 

150
00:10:33.435 --> 00:10:39.117
function f means, just by using scope. 
and the iterator folded itself doesn't 

151
00:10:39.117 --> 00:10:42.828
need to what data is there or even what 
type it has. 

152
00:10:42.828 --> 00:10:48.538
So our first couple of examples, f1 and 
f2 I believe didn't use private data and 

153
00:10:48.538 --> 00:10:52.035
that's fine. 
f3, f4, and f5 did and that's fine too. 

154
00:10:52.035 --> 00:10:56.674
Fold works the same way. 
It just calls f once for each element in 

155
00:10:56.674 --> 00:11:00.600
the list and f can use whatever is in 
it's environment. 

156
00:11:00.600 --> 00:11:05.639
So, now we've seen map, filter and fold. 
Probably the three most important higher 

157
00:11:05.639 --> 00:11:09.828
order functions there are. 
Of course, there are many other useful 

158
00:11:09.828 --> 00:11:12.839
ones. 
In fact, the f5 we just defined is itself 

159
00:11:12.839 --> 00:11:17.616
a very useful higher order function. 
It's easier to use, simpler to use than 

160
00:11:17.616 --> 00:11:20.627
fold. 
But we nonetheless defined it using fold. 

161
00:11:20.627 --> 00:11:25.536
And that's the end of our study of fold. 
Now we can continue to study other 

162
00:11:25.536 --> 00:11:29.005
idioms, other important ways that we can 
use closures. 