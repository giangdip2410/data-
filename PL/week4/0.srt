WEBVTT

1
00:00:00.000 --> 00:00:04.573
[MUSIC] This segment of the course is all 
about first-class functions. 

2
00:00:04.573 --> 00:00:09.930
And in this first segment, I just want to 
give you a little bit of a sense of what 

3
00:00:09.930 --> 00:00:15.157
that means, introduce a little bit of a 
terminology, and actually start by taking 

4
00:00:15.157 --> 00:00:20.319
a bit of a step back and asking what is 
this functional programming stuff that 

5
00:00:20.319 --> 00:00:24.370
we've been doing and will continue to do 
through this segment. 

6
00:00:24.370 --> 00:00:27.713
So, functional programming can mean a few 
different things. 

7
00:00:27.713 --> 00:00:31.460
To me, it really is about two concepts 
that are actually separate. 

8
00:00:31.460 --> 00:00:36.476
But for historical and somewhat good 
reasons, they've been combined together 

9
00:00:36.476 --> 00:00:39.128
and we call the result functional 
programming. 

10
00:00:39.128 --> 00:00:43.336
The first we've already studied quite a 
bit and that's avoiding mutation. 

11
00:00:43.336 --> 00:00:47.775
Not using assignment statements, not 
having data that lives in locations that 

12
00:00:47.775 --> 00:00:50.542
can change. 
We've done a lot of that, we're going to 

13
00:00:50.542 --> 00:00:54.001
continue to do that. 
And we'll even see cases where we don't 

14
00:00:54.001 --> 00:00:58.210
want that, where actually mutable state 
is a reasonable programming idiom. 

15
00:00:58.210 --> 00:01:02.366
And then the second thing, which is what 
this section of the course is all about, 

16
00:01:02.366 --> 00:01:05.795
is using functions as values. 
Passing them around and that sort of 

17
00:01:05.795 --> 00:01:09.380
thing, and that'll give you a sense very 
soon of what we mean by that. 

18
00:01:09.380 --> 00:01:13.862
Now, there are a few other things that 
people often think of when they think of 

19
00:01:13.862 --> 00:01:18.570
functional programming and these are not 
necessarily bad aspects of the definition 

20
00:01:18.570 --> 00:01:22.769
of functional programming, if you will. 
First of all, functional programming 

21
00:01:22.769 --> 00:01:26.967
often uses lots of recursion and 
recursive data structures like lists and 

22
00:01:26.967 --> 00:01:29.690
trees and we've seen that in our section 
so far. 

23
00:01:29.690 --> 00:01:34.002
You'll also often see a programming style 
or even a syntax that's much more 

24
00:01:34.002 --> 00:01:37.066
mathematical. 
the definitions we write down tend to 

25
00:01:37.066 --> 00:01:41.775
look much more like the mathematics that 
we studied in school than other styles of 

26
00:01:41.775 --> 00:01:45.203
programming tend to. 
There is something that some functional 

27
00:01:45.203 --> 00:01:48.643
programming languages such as Haskell 
have, which is laziness. 

28
00:01:48.643 --> 00:01:52.943
This is actually a technical term. 
I'm not saying that anyone is being lazy. 

29
00:01:52.943 --> 00:01:55.867
We will study laziness briefly later in 
the course. 

30
00:01:55.867 --> 00:01:59.135
Many courses would emphasize it more than 
we're going to. 

31
00:01:59.135 --> 00:02:03.075
That's just a matter of perspective. 
And then, there's a lot of definitions 

32
00:02:03.075 --> 00:02:06.775
that make a whole lot less sense. 
sometimes people think that oh, if it's 

33
00:02:06.775 --> 00:02:10.723
not object-oriented programming, or it's 
not C, maybe it's functional programming. 

34
00:02:10.723 --> 00:02:13.980
And that's pretty sloppy thinking and 
we'd like to avoid that one. 

35
00:02:13.980 --> 00:02:19.079
Now, once we know what functional 
programming is, then what is a functional 

36
00:02:19.079 --> 00:02:21.993
language? 
And I've taken to decide that this really 

37
00:02:21.993 --> 00:02:25.161
doesn't make a whole lot of sense as a 
yes or no question. 

38
00:02:25.161 --> 00:02:29.257
a functional language is one in which you 
can do functional programming. 

39
00:02:29.257 --> 00:02:33.190
But I think I can do functional 
programming, as described here, in pretty 

40
00:02:33.190 --> 00:02:36.412
much any language. 
It just might be more or less convenient. 

41
00:02:36.412 --> 00:02:40.563
It might be more or less the default. 
So, to me, a functional language is just 

42
00:02:40.563 --> 00:02:44.877
one where functional programming is the 
easy, natural, conventional way to do it. 

43
00:02:44.877 --> 00:02:48.810
All the libraries are generally written 
in a functional style, and so on. 

44
00:02:48.810 --> 00:02:51.503
Alright. 
So, if this course is not entirely about 

45
00:02:51.503 --> 00:02:54.085
functional programming, it's broader than 
that. 

46
00:02:54.085 --> 00:02:58.519
But if that's a big focus and if a big 
part of functional programming is using 

47
00:02:58.519 --> 00:03:02.897
functions as values, it's about time we 
really got started on that part of the 

48
00:03:02.897 --> 00:03:05.990
course. 
So, a first-class function is, like in 

49
00:03:05.990 --> 00:03:11.326
ML, like in many programming languages, a 
situation where functions can appear and 

50
00:03:11.326 --> 00:03:15.714
be used wherever we use other values. 
Wherever you use numbers or lists or 

51
00:03:15.714 --> 00:03:18.797
strings or trees, you could also put 
functions there. 

52
00:03:18.797 --> 00:03:21.703
So, functions can be arguments to other 
functions. 

53
00:03:21.703 --> 00:03:25.675
They can be results of functions. 
They can be a part of a tuple, you 

54
00:03:25.675 --> 00:03:28.996
combine them to variables. 
You can put them in data type 

55
00:03:28.996 --> 00:03:32.281
constructors and so on. 
So, we're not going to do a lot of code 

56
00:03:32.281 --> 00:03:36.231
in this introductory segment, but I 
thought I would show you just a little 

57
00:03:36.231 --> 00:03:40.555
bit of how this really can be done in ML. 
And, in fact, not using any features that 

58
00:03:40.555 --> 00:03:44.025
we didn't already have, just ones we 
didn't think to use this way. 

59
00:03:44.025 --> 00:03:46.641
So, here's two functions. 
One doubles its argument. 

60
00:03:46.641 --> 00:03:49.950
The other increments its argument. 
That's not very interesting. 

61
00:03:49.950 --> 00:03:52.406
But now, let's make a tuple, we're in the 
tuple, 

62
00:03:52.406 --> 00:03:55.395
this is going to be a triple so I'm going 
to have three parts. 

63
00:03:55.395 --> 00:03:58.171
What if in the first part, I put the 
function double? 

64
00:03:58.171 --> 00:04:02.335
So, I'm not calling the function, I'm not 
passing it an argument, I'm just going to 

65
00:04:02.335 --> 00:04:06.950
look double up in the environment, 
get a function back and put that in the 

66
00:04:06.950 --> 00:04:10.884
first part of my tupple. 
Similarly in the second part, how do I 

67
00:04:10.884 --> 00:04:13.851
put increment? 
And just to contrast the difference 

68
00:04:13.851 --> 00:04:18.420
between a function and the result of 
calling the function what if here I put 

69
00:04:18.420 --> 00:04:22.574
double of increment of seven. 
Now, this third position is going to call 

70
00:04:22.574 --> 00:04:26.965
increment with seven, get back eight. 
Call double with that and get sixteen, 

71
00:04:26.965 --> 00:04:29.618
alright? 
And then, we could even, down here at 

72
00:04:29.618 --> 00:04:34.278
about eighteen, we could get out using 
our old hash one operator that we used 

73
00:04:34.278 --> 00:04:38.453
before we learned pattern matching. 
Hash one of a tuple, that is going to 

74
00:04:38.453 --> 00:04:42.447
give back the double function and then we 
could call it with nine. 

75
00:04:42.447 --> 00:04:47.107
So, this is an example of first-class 
functions because I'm putting functions 

76
00:04:47.107 --> 00:04:50.859
in a tuple and then later, I'm pulling 
them out and using them. 

77
00:04:50.859 --> 00:04:56.779
So, let's make sure I got this all right. 
[SOUND] And show you what the RPL shows 

78
00:04:56.779 --> 00:05:00.391
for this. 
This will be useful to us and this over 

79
00:05:00.391 --> 00:05:03.454
here. 
and sure enough, it says, as we're used 

80
00:05:03.454 --> 00:05:06.280
to, double is a function of type int 
arrow int. 

81
00:05:06.280 --> 00:05:09.435
Increment is a function of type arrow int 
arrow int. 

82
00:05:09.435 --> 00:05:11.406
This a_tuple, 
very interesting. 

83
00:05:11.406 --> 00:05:15.350
It is a triple, where the first position 
holds some function. 

84
00:05:15.350 --> 00:05:19.884
The RPL never actually prints out 
functions, other than to write fn. 

85
00:05:19.884 --> 00:05:24.551
The second part is fn and the third part 
is sixteen, just as I promised. 

86
00:05:24.551 --> 00:05:28.560
And the type is a triple int arrow int 
star int arrow int star int. 

87
00:05:28.560 --> 00:05:32.602
And finally, eighteen, where we pulled 
out the double function from the tuple 

88
00:05:32.602 --> 00:05:35.740
and then called it with nine, did 
actually give us eighteen, 

89
00:05:35.740 --> 00:05:38.399
alright? 
So, that's a little sense of the sort of 

90
00:05:38.399 --> 00:05:42.654
thing we'll be doing. And later in this 
section, after we learn the semantics and 

91
00:05:42.654 --> 00:05:45.686
how to use first-class functions, we'll 
see useful idioms. 

92
00:05:45.686 --> 00:05:49.090
The code there was obviously on purpose, 
just a little bit silly, 

93
00:05:49.090 --> 00:05:51.625
okay? 
So, to finish up, let me just give you a 

94
00:05:51.625 --> 00:05:54.751
couple more terms. 
The most common use of first-class 

95
00:05:54.751 --> 00:05:59.469
functions is not putting them in tuples 
and pulling them out of tuples, although 

96
00:05:59.469 --> 00:06:03.302
that can be very useful. 
The most common is to pass a function as 

97
00:06:03.302 --> 00:06:07.372
an argument to another function or as the 
result of another function. 

98
00:06:07.372 --> 00:06:12.149
And when you're doing that, the function 
that takes or returns other functions is 

99
00:06:12.149 --> 00:06:14.980
called a higher-order function. 
It's just a term. 

100
00:06:14.980 --> 00:06:19.699
And higher-order functions are a 
powerful, powerful idiom for factoring 

101
00:06:19.699 --> 00:06:24.350
out common computations and we'll see 
examples in upcoming segments. 

102
00:06:24.350 --> 00:06:28.764
One other term we'll get to later in the 
section is a function closure. 

103
00:06:28.764 --> 00:06:33.613
A function closure is a function that 
uses bindings from outside the function 

104
00:06:33.613 --> 00:06:36.659
definition. 
Now, how can it do that if it's not an 

105
00:06:36.659 --> 00:06:40.016
argument or a local variable, how can it 
use something? 

106
00:06:40.016 --> 00:06:44.057
The same way we always have in ML. 
Things that are already in the 

107
00:06:44.057 --> 00:06:48.657
environment can be used by a function. 
Once you have first-class functions, 

108
00:06:48.657 --> 00:06:52.883
functions being passed around and 
returned, the way this environment 

109
00:06:52.883 --> 00:06:57.668
interacts with the functions is more 
sophisticated, more interesting, and much 

110
00:06:57.668 --> 00:07:00.776
more powerful. 
We're going to put that off just a bit 

111
00:07:00.776 --> 00:07:05.404
and talk about function closures later. 
So, to me, first-class functions means 

112
00:07:05.404 --> 00:07:08.740
functions you can pass around and put 
anywhere you want. 

113
00:07:08.740 --> 00:07:13.420
Function closures means functions that 
can use things in the environment, not 

114
00:07:13.420 --> 00:07:17.675
just arguments and local variables. 
And these are technically separate 

115
00:07:17.675 --> 00:07:22.537
concepts but because functional languages 
always support both and they're often 

116
00:07:22.537 --> 00:07:25.029
used together, use both features 
together, 

117
00:07:25.029 --> 00:07:27.886
these terms are often confused with each 
other. 

118
00:07:27.886 --> 00:07:32.566
And even though it's an important 
conceptual distinction I'm not going to 

119
00:07:32.566 --> 00:07:37.125
harp on the definitions and the 
terminology because they're so commonly 

120
00:07:37.125 --> 00:07:40.590
used incorrectly and it's frankly not 
that big of a deal. 

121
00:07:40.590 --> 00:07:43.998
So, that's our introduction. 
Hopefully you're excited about the idea 

122
00:07:43.998 --> 00:07:47.916
of first-class functions and we'll start 
learning how to use them for actual 

123
00:07:47.916 --> 00:07:50.308
interesting code even in the very next 
segment. 