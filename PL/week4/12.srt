WEBVTT

1
00:00:00.012 --> 00:00:05.507
[MUSIC] This is the first of several 
segments, where we're going to take what 

2
00:00:05.507 --> 00:00:10.742
we already learned about function 
closures, and discover additional and 

3
00:00:10.742 --> 00:00:15.922
powerful programming idiom's that, that 
semantics's will let us use. 

4
00:00:15.922 --> 00:00:18.757
So we know the semantics. 
We know lexical scope. 

5
00:00:18.757 --> 00:00:22.410
We know function closers. 
And we've already done one of the key 

6
00:00:22.410 --> 00:00:25.259
idioms. 
That is passing functions to iterators. 

7
00:00:25.259 --> 00:00:28.617
We're now going to do several more. 
You see the list here. 

8
00:00:28.617 --> 00:00:32.501
And in this segment we're going to focus 
on this combining functions. 

9
00:00:32.501 --> 00:00:36.182
This is going to be writing things like 
function composition. 

10
00:00:36.182 --> 00:00:41.236
So without further ado, how about I just 
go over to, Emax here and write function 

11
00:00:41.236 --> 00:00:44.820
composition for you. 
So, what I want to do is write function 

12
00:00:44.820 --> 00:00:48.542
compose that's going to take in two other 
functions f and g. 

13
00:00:48.542 --> 00:00:53.469
And return a function that, when you call 
it, just calls, returns f(g,x). 

14
00:00:53.469 --> 00:00:58.922
And we can do that, alright? So, f(g,x). 
And if you call compose with 2 functions, 

15
00:00:58.922 --> 00:01:03.081
and get a function back. 
That function you get back is absolutely 

16
00:01:03.081 --> 00:01:07.766
using the semantics for closures. 
So that when you call it, it can look up 

17
00:01:07.766 --> 00:01:11.923
f and g in the environment. 
That was present back when we defined 

18
00:01:11.923 --> 00:01:13.434
this function. 
Alright. 

19
00:01:13.434 --> 00:01:17.867
Function composition is a fundamental 
idea in mathematics and in computer 

20
00:01:17.867 --> 00:01:20.807
science. 
So, let's take a minute just to study it 

21
00:01:20.807 --> 00:01:23.970
a little bit. 
I like to think of its type as something 

22
00:01:23.970 --> 00:01:27.860
that takes. 
These two arguments, so a function from 

23
00:01:27.860 --> 00:01:33.731
alpha to beta, or a to b, if you will, 
that's the g, and a function from b to c, 

24
00:01:33.731 --> 00:01:37.410
that's the f, and returns a function from 
a to c. 

25
00:01:37.410 --> 00:01:44.066
And once you look at the type like that, 
it's, almost painfully clear, what the 

26
00:01:44.066 --> 00:01:48.558
function does. 
It, it pretty much has to call f of g on, 

27
00:01:48.558 --> 00:01:53.332
its argument a here, to eventually return 
This argument of type C. 

28
00:01:53.332 --> 00:01:57.082
Now, just to warn you. 
If you try this out in ML, you get the 

29
00:01:57.082 --> 00:02:01.652
REPL, which has no idea that a is the 
first letter of the alphabet, and b the 

30
00:02:01.652 --> 00:02:04.527
second or anything. 
returns this type here. 

31
00:02:04.527 --> 00:02:09.052
It's missing a couple parentheses and 
it's used different type variables for 

32
00:02:09.052 --> 00:02:12.519
different parts of the type. 
But I promise you that it's an 

33
00:02:12.519 --> 00:02:16.901
absolutely, equivalent type alright. 
Now it turns out that functioning 

34
00:02:16.901 --> 00:02:20.968
composition is nice enough, that it's 
been provided by ml and it's been 

35
00:02:20.968 --> 00:02:24.934
provided as an in-fix operator. 
The same way plus, is a function that 

36
00:02:24.934 --> 00:02:29.001
takes two arguments, but we happen to 
write it between that arguments. 

37
00:02:29.001 --> 00:02:33.378
In ml they took the lower case O, zero, 
like the, O, like this. 

38
00:02:33.378 --> 00:02:36.212
Not zero. 
O, and said that's the function 

39
00:02:36.212 --> 00:02:41.704
composition argument, so you can write f 
composed with g, and that's exactly the 

40
00:02:41.704 --> 00:02:45.815
function we Right up here. 
So let me show you an example of using 

41
00:02:45.815 --> 00:02:48.480
it. 
I'll start with the old boring way that 

42
00:02:48.480 --> 00:02:52.023
doesn't use this. 
Let's write a function, square root of 

43
00:02:52.023 --> 00:02:55.102
absolute value. 
It's going to take an integer, it's 

44
00:02:55.102 --> 00:02:59.128
actually going to have type int arrow 
real is ml's floating points. 

45
00:02:59.128 --> 00:03:04.136
And I'll I want to do Is take the 
absolute value of I and then convert that 

46
00:03:04.136 --> 00:03:10.097
to a real number, because that is what 
this other library functions, math.sqrt, 

47
00:03:10.097 --> 00:03:13.833
requires. 
All right, so this will work absolutely 

48
00:03:13.833 --> 00:03:19.221
fine, but let's write a version that 
instead uses function composition. 

49
00:03:19.221 --> 00:03:24.550
So here's a second version Where I can 
better express, better indicate to the 

50
00:03:24.550 --> 00:03:29.883
person reading my code that what I really 
am doing is composing three functions. 

51
00:03:29.883 --> 00:03:35.438
We could put more parenthesis in here but 
the order won't actually matter, function 

52
00:03:35.438 --> 00:03:39.783
composition is associative. 
And I'm just now taking the function 

53
00:03:39.783 --> 00:03:42.972
return from this higher order function 
call. 

54
00:03:42.972 --> 00:03:49.073
And applying it to i, and now you might 
notice that this has our standard pattern 

55
00:03:49.073 --> 00:03:54.902
of unnecessary function wrapping. 
So we could express even more clearly and 

56
00:03:54.902 --> 00:04:00.842
directly what we're doing by saying that 
the sqrt-of-abs is the variable, the 

57
00:04:00.842 --> 00:04:06.153
value you get by composing Map that 
square root with Real.fromInt and the 

58
00:04:06.153 --> 00:04:10.748
absolute value function. 
So that's using function composition. 

59
00:04:10.748 --> 00:04:14.944
We see that we need closures for this to 
work out correctly. 

60
00:04:14.944 --> 00:04:20.564
What I thought I might do now is point 
out that as nice as function composition 

61
00:04:20.564 --> 00:04:25.370
in that order is in math, we kind of have 
to end up reading this right to left. 

62
00:04:25.370 --> 00:04:29.888
Take the absolute value, convert to a 
real, then take the square root. 

63
00:04:29.888 --> 00:04:34.640
Which is a little bit backwards, 
especially if you're reading your code in 

64
00:04:34.640 --> 00:04:38.941
English, where most programmers are used 
to reading left to right. 

65
00:04:38.941 --> 00:04:43.882
So, in more recent years, a different 
operator has become more popular. 

66
00:04:43.882 --> 00:04:48.243
This is used a lot in f sharp, which is a 
dialect of ml, and functional programmers 

67
00:04:48.243 --> 00:04:52.422
just like to use this a bit as well, And, 
I've defined it here on the slide, but 

68
00:04:52.422 --> 00:04:56.070
I'll think I'll just go back to the code 
and redefine it for you here. 

69
00:04:56.070 --> 00:05:00.290
Now on the slide, and in f sharp, this 
operator is usually written with the pipe 

70
00:05:00.290 --> 00:05:04.634
character, and then the angle bracket. 
I discovered that in the current version, 

71
00:05:04.634 --> 00:05:09.199
of sml mode for emacs that I'm using, 
using that Pipe character, snarls it up, 

72
00:05:09.199 --> 00:05:12.610
and makes it think I'm using a different 
language feature. 

73
00:05:12.610 --> 00:05:16.608
So instead, I'm just going to use 
exclamation point, angle bracket. 

74
00:05:16.608 --> 00:05:20.055
But in either case, we can, make up our 
own infix operator. 

75
00:05:20.055 --> 00:05:24.487
The same way plus, is something that 
takes it's argument on either side, I'm 

76
00:05:24.487 --> 00:05:29.033
going to use this keyword that's kind of 
fancy and special to ml, it says I want 

77
00:05:29.033 --> 00:05:34.647
my own, infix operator, that I want to be 
written That way, and once I've done 

78
00:05:34.647 --> 00:05:40.522
this, which tells it, this is always 
going to be written between the 2 

79
00:05:40.522 --> 00:05:44.497
arguments, I can now define it as a 
function. 

80
00:05:44.497 --> 00:05:49.600
Now, this is And then a function, f, and 
then calls f with x. 

81
00:05:49.600 --> 00:05:53.951
This is really not very interesting 
semantically, it's just taking a function 

82
00:05:53.951 --> 00:05:58.230
and argument, and calling the function 
with the argument, but by putting the 

83
00:05:58.230 --> 00:06:02.832
argument on the left, it lets us write 
our square root of abs in a way that many 

84
00:06:02.832 --> 00:06:08.017
programmers find quite easy to read and 
pleasant, and it's nothing more than a 

85
00:06:08.017 --> 00:06:11.442
program idiom. 
Just say alright, use our new operator 

86
00:06:11.442 --> 00:06:14.287
with i and abs, and that will return abs 
of i. 

87
00:06:14.287 --> 00:06:18.582
And then that result can go to 
Real.frontInt, so that will get me the 

88
00:06:18.582 --> 00:06:21.352
real number that is the absolute value of 
i. 

89
00:06:21.352 --> 00:06:25.202
And then, Math.sqrt. 
And we call this a pipeline, because it 

90
00:06:25.202 --> 00:06:29.562
almost looks like we're setting up a pipe 
where we start with our. 

91
00:06:29.562 --> 00:06:34.007
Number i passing through a sequence of 
functions combining all that to get the 

92
00:06:34.007 --> 00:06:36.361
answer we want. 
So, that's kind of neat. 

93
00:06:36.361 --> 00:06:39.496
That's the pipeline operator. 
A lot of people like it. 

94
00:06:39.496 --> 00:06:43.669
It's not doing anything fancy. 
It's just programming, once we've defined 

95
00:06:43.669 --> 00:06:45.889
it with a very simple high order 
function. 

96
00:06:45.889 --> 00:06:48.818
So, I've showed you function composition 
in pipelines. 

97
00:06:48.818 --> 00:06:52.759
There are certainly more interesting 
things you can do, with combining 

98
00:06:52.759 --> 00:06:55.403
functions. 
So those are probably the most common. 

99
00:06:55.403 --> 00:06:59.162
But let's, let's do some others that we 
just think might be useful. 

100
00:06:59.162 --> 00:07:03.544
So I'm going to define a couple functions 
here I'm going to call backup functions. 

101
00:07:03.544 --> 00:07:07.849
So suppose you took in a function f and 
g, and what you wanted to do is run f, 

102
00:07:07.849 --> 00:07:11.311
but if f wasn't the right thing, then 
return the result of g. 

103
00:07:11.311 --> 00:07:15.101
So we're combining functions. 
I want to return a new function that 

104
00:07:15.101 --> 00:07:17.895
takes x. 
And what it does, is it turns out f of x, 

105
00:07:17.895 --> 00:07:20.522
the way this is written returns an 
option. 

106
00:07:20.522 --> 00:07:24.450
And if that option is none, then I want 
to call g of x. 

107
00:07:24.450 --> 00:07:29.000
Otherwise, if it's sum, let me reformat 
things here for you. 

108
00:07:29.000 --> 00:07:32.601
Sum of, sum argument y, then just return 
that y. 

109
00:07:32.601 --> 00:07:36.118
M'kay. 
So that kind of makes sense, kind of as a 

110
00:07:36.118 --> 00:07:39.983
back up. 
let me show you what that looks like in 

111
00:07:39.983 --> 00:07:43.547
terms of its type. 
Because that will be nice and revealing 

112
00:07:43.547 --> 00:07:47.093
of what's going on. 
And sure enough, if you look up backup 

113
00:07:47.093 --> 00:07:51.852
one, it says f has to be an alpha arrow 
beta option.You can pass it any type you 

114
00:07:51.852 --> 00:07:54.600
want. 
But the think back has to be an option. 

115
00:07:54.600 --> 00:07:57.663
Because we pattern match on it with none 
in some. 

116
00:07:57.663 --> 00:08:02.459
The second argument had, 
g has to take the same thing that F does 

117
00:08:02.459 --> 00:08:06.217
because we might call g with the same 
acts we called F with. 

118
00:08:06.217 --> 00:08:11.019
The result type has to not have the 
option on it because that's the result of 

119
00:08:11.019 --> 00:08:16.130
our entire function just like in the 
other branch of the case expression, we 

120
00:08:16.130 --> 00:08:19.512
return to beta. 
So in general, if you pass an F, as in 

121
00:08:19.512 --> 00:08:24.606
alpha, arrow, beta option and g as in 
alpha, arrow, beta You will get back, the 

122
00:08:24.606 --> 00:08:28.281
parentheses just aren't printed here, an 
alpha arrow beta. 

123
00:08:28.281 --> 00:08:32.414
So, it's like function composition, 
except we don't compose them. 

124
00:08:32.414 --> 00:08:37.191
We either return the result of f with the 
option stripped off, or we return the 

125
00:08:37.191 --> 00:08:40.576
result of g. 
you might prefer a version that worked 

126
00:08:40.576 --> 00:08:43.936
with exceptions instead, so let me just 
show you that. 

127
00:08:43.936 --> 00:08:48.566
I won't, try it out or anything. 
So this, f and g will both just be alpha 

128
00:08:48.566 --> 00:08:52.078
arrow betas. 
But if f, when called with x raises any 

129
00:08:52.078 --> 00:08:57.014
exception using a little pattern matching 
here in my handle expression. 

130
00:08:57.014 --> 00:09:01.239
Then call g of x instead. 
Alright? And if I show you the type of 

131
00:09:01.239 --> 00:09:05.162
that one, we'll see that f no longer, has 
the return. 

132
00:09:05.162 --> 00:09:08.012
Option. 
So those are a few examples of combining 

133
00:09:08.012 --> 00:09:10.812
functions. 
That's our next closure idiom after 

134
00:09:10.812 --> 00:09:15.517
passing data to iterators, functions to 
iterators with private data, and we'll 

135
00:09:15.517 --> 00:09:18.095
move on to our next idiom in the next 
segment. 