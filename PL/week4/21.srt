WEBVTT

1
00:00:00.000 --> 00:00:05.083
[MUSIC]

2
00:00:05.083 --> 00:00:06.871
In this optional segment,

3
00:00:06.871 --> 00:00:12.040
we'll see how to use objects in a language
like Java to simulate closures.

4
00:00:12.040 --> 00:00:13.080
It won't be pretty, but

5
00:00:13.080 --> 00:00:16.850
we will be able to successfully port
the ML code from the previous segment.

6
00:00:18.050 --> 00:00:23.690
Just to be fair to Java, the next version
of Java, Java 8, is supposed to have

7
00:00:23.690 --> 00:00:28.730
closures that are much easier to use,
and very ML-like, if you will.

8
00:00:28.730 --> 00:00:32.800
Many languages that also support
object-oriented programming these days

9
00:00:32.800 --> 00:00:34.230
also have closures.

10
00:00:34.230 --> 00:00:38.530
This is a great bit of progress for
programming languages and software.

11
00:00:38.530 --> 00:00:42.990
And you'll be able to write convenient
things using map and filter and

12
00:00:42.990 --> 00:00:46.310
length in a reasonably
object-oriented style.

13
00:00:46.310 --> 00:00:48.020
This was done for a number of reasons.

14
00:00:48.020 --> 00:00:51.100
I won't claim to speak for
the designers of Java, but

15
00:00:51.100 --> 00:00:53.090
it's going to make using
collections easier.

16
00:00:53.090 --> 00:00:56.453
It's going to encourage a style
that has less mutation.

17
00:00:56.453 --> 00:01:00.450
Which will make it much easier
to write parallel code in Java.

18
00:01:00.450 --> 00:01:04.650
So for a number of reasons,
after 15 to 20 years of living without it,

19
00:01:04.650 --> 00:01:07.260
Java programmers will have closures.

20
00:01:07.260 --> 00:01:09.360
But that's not really
the point of this segment.

21
00:01:09.360 --> 00:01:13.530
The point of this segment is how could
you take a language with classes and

22
00:01:13.530 --> 00:01:18.280
objects like the core of Java is, and
write code like the ML code we saw in

23
00:01:18.280 --> 00:01:21.590
the previous segment,
if that's what we wanted to do.

24
00:01:21.590 --> 00:01:24.040
Now, there are perfectly fine,

25
00:01:24.040 --> 00:01:28.260
decent list libraries in Java that
are not written in this style.

26
00:01:28.260 --> 00:01:32.470
They're not about map and filter and
closures and things like that.

27
00:01:32.470 --> 00:01:36.955
They're in a more object-oriented style,
they use more mutation, and that's okay.

28
00:01:36.955 --> 00:01:41.445
But we're interesting in seeing what
our ML code would look like using

29
00:01:41.445 --> 00:01:43.510
Java's language constructs.

30
00:01:44.980 --> 00:01:49.060
So the key technique to fake closures,

31
00:01:49.060 --> 00:01:52.890
if you will, is to define
interfaces with one method in them.

32
00:01:52.890 --> 00:01:57.250
because a function is a lot
like an object with one method.

33
00:01:57.250 --> 00:01:59.390
You can just call a function.

34
00:01:59.390 --> 00:02:04.061
So for example, here's a generic
interface in Java using the generic type

35
00:02:04.061 --> 00:02:06.444
parameters A and B for alpha and beta.

36
00:02:06.444 --> 00:02:08.090
It just has one method.

37
00:02:08.090 --> 00:02:11.190
So anything implementing
Func of type one and

38
00:02:11.190 --> 00:02:13.080
type two is something that is a method.

39
00:02:13.080 --> 00:02:15.910
That takes a type one and
returns a type two.

40
00:02:15.910 --> 00:02:20.480
And we'll be able to create objects
that implement that interface, and

41
00:02:20.480 --> 00:02:25.665
then those objects will act like functions
from the argument type to the result type.

42
00:02:25.665 --> 00:02:28.795
We will have to put in those objects

43
00:02:28.795 --> 00:02:33.665
fields that have whatever private
data our closure would want.

44
00:02:33.665 --> 00:02:37.161
Similarly, if we wanted a predicate,
something that would turn true or

45
00:02:37.161 --> 00:02:38.435
false given an argument.

46
00:02:38.435 --> 00:02:42.657
Here's a generic interface that for
some type A takes in an A and

47
00:02:42.657 --> 00:02:44.590
returns true or false.

48
00:02:44.590 --> 00:02:47.570
So the key is to implement
these interfaces

49
00:02:47.570 --> 00:02:51.700
with objects that have
whatever fields we need.

50
00:02:51.700 --> 00:02:52.220
So there you go.

51
00:02:53.770 --> 00:02:57.630
So now with that background, and
we'll get back to those in just a second,

52
00:02:57.630 --> 00:03:00.310
let's just start building
up our link list library.

53
00:03:00.310 --> 00:03:04.830
And we'll start pretty much as you might
expect for an object oriented library.

54
00:03:04.830 --> 00:03:06.810
We'll create a generic type, List,

55
00:03:06.810 --> 00:03:09.790
that's perameterized by the type
of the elements of the list.

56
00:03:09.790 --> 00:03:11.280
We'll have fields for head and tail.

57
00:03:11.280 --> 00:03:15.320
And we'll have a constructor here that
initializes it with the head for x and

58
00:03:15.320 --> 00:03:16.770
the tail for xs.

59
00:03:16.770 --> 00:03:20.440
Now, this constructor simply will
not work for the empty list.

60
00:03:20.440 --> 00:03:22.040
What should we do for that?

61
00:03:22.040 --> 00:03:26.260
So here I'm going to make a choice that
I'm going to regret in a couple minutes,

62
00:03:26.260 --> 00:03:29.430
which is to have null
represent the empty list.

63
00:03:29.430 --> 00:03:33.620
It's a special constant in Java, this is
fairly conventional that we'll use it for

64
00:03:33.620 --> 00:03:34.260
the empty list.

65
00:03:34.260 --> 00:03:35.980
So the empty list will not be an object.

66
00:03:35.980 --> 00:03:39.160
It will not have a class,
it'll be this special null constant.

67
00:03:39.160 --> 00:03:42.299
And we'll see in a minute where that's
going to get us into a bit of trouble.

68
00:03:43.800 --> 00:03:47.960
Okay, so now what we're going to do
is we're going to implement map,

69
00:03:47.960 --> 00:03:48.970
filter, and length.

70
00:03:48.970 --> 00:03:52.134
Those were the three functions
in our library in ML for

71
00:03:52.134 --> 00:03:54.041
this list type we've defined.

72
00:03:54.041 --> 00:03:56.650
And I'm going to make them static methods.

73
00:03:56.650 --> 00:03:59.620
And I'm doing this because
of that decision for null.

74
00:03:59.620 --> 00:04:03.913
Okay, so you see the code here,
but it'll be easier to read and

75
00:04:03.913 --> 00:04:06.516
highlight if I flip over here to emax.

76
00:04:06.516 --> 00:04:09.900
All the Java code I've already
shown you is up above.

77
00:04:09.900 --> 00:04:12.050
And here is my method for map.

78
00:04:12.050 --> 00:04:14.353
So this is the entire thing here,
all right?

79
00:04:14.353 --> 00:04:18.430
So static method, it is polymorphic.

80
00:04:18.430 --> 00:04:21.030
It is generic in two types, alpha and

81
00:04:21.030 --> 00:04:25.800
beta, because sure enough,
the result type is a list of betas.

82
00:04:25.800 --> 00:04:28.820
And one of the arguments
is a list of alphas.

83
00:04:28.820 --> 00:04:33.404
The other argument is one of
these Funcs from alpha to beta.

84
00:04:33.404 --> 00:04:36.696
Remember that interface
that just has one method m.

85
00:04:36.696 --> 00:04:41.450
And that method takes an A, or
an alpha, and returns a B, or a beta.

86
00:04:41.450 --> 00:04:43.945
So given these two arguments, and

87
00:04:43.945 --> 00:04:46.970
that I want to return
the appropriate list of betas.

88
00:04:46.970 --> 00:04:50.861
At this point I can pretty much
write the code like I do in ML.

89
00:04:50.861 --> 00:04:55.859
If xs is null, the empty list,
return null, the empty list.

90
00:04:55.859 --> 00:04:59.330
Otherwise, return a new list of betas.

91
00:04:59.330 --> 00:05:05.500
And I call the constructor,
I build my new list out of f.m(xs.head).

92
00:05:05.500 --> 00:05:07.110
So let's talk about that.

93
00:05:07.110 --> 00:05:08.960
f is this function, that's an interface.

94
00:05:08.960 --> 00:05:10.690
It has one method, m.

95
00:05:10.690 --> 00:05:15.015
I pass it an appropriate alpha,
I get back the appropriate beta.

96
00:05:15.015 --> 00:05:20.100
And then let's just recursively
call map with the same object for

97
00:05:20.100 --> 00:05:26.393
the first argument and xs.tail, pretty
much like the ML code does, all right?

98
00:05:26.393 --> 00:05:27.930
So that's pretty nice.

99
00:05:27.930 --> 00:05:30.560
Now you might argue,
in Java we don't encourage so

100
00:05:30.560 --> 00:05:34.590
much recursion because recursion is
usually not as efficient in Java.

101
00:05:34.590 --> 00:05:38.050
Particularly we do not have tail calls and
things like that.

102
00:05:38.050 --> 00:05:41.050
I would argue this is better
than the alternative.

103
00:05:41.050 --> 00:05:44.660
I encourage you to code up the version
on you own that uses a while loop

104
00:05:44.660 --> 00:05:46.050
instead of recursion.

105
00:05:46.050 --> 00:05:47.970
Keep the pointer to the previous element.

106
00:05:47.970 --> 00:05:49.200
It's a bit of a mess.

107
00:05:49.200 --> 00:05:53.588
So I find this much easier to explain,
reason about I prefer this version.

108
00:05:53.588 --> 00:05:55.480
All right, so that's map.

109
00:05:55.480 --> 00:05:58.060
Filter is fairly similar.

110
00:05:58.060 --> 00:06:02.240
Filter takes a list of alphas and
returns a list of alphas.

111
00:06:02.240 --> 00:06:04.846
So it's only generic over one type alpha.

112
00:06:04.846 --> 00:06:07.659
Its argument is not a Func
from alpha to beta,

113
00:06:07.659 --> 00:06:11.224
it's an implementation of
the interface Pred of alpha.

114
00:06:11.224 --> 00:06:13.025
But otherwise it's essentially filtering.

115
00:06:13.025 --> 00:06:17.934
Again, the body of the function, once you
survive the complicated first line without

116
00:06:17.934 --> 00:06:20.610
any type inference, is not too bad.

117
00:06:20.610 --> 00:06:23.050
If we have the empty list,
return the empty list.

118
00:06:23.050 --> 00:06:27.776
Otherwise, if taking this object,
calling it's m method on the first

119
00:06:27.776 --> 00:06:32.680
element of the list gives back true,
then we want xs.head in our result.

120
00:06:32.680 --> 00:06:35.930
So we return the new list
of alpha with xs.head.

121
00:06:35.930 --> 00:06:40.459
And then calling a recursive call to
filter with the same Pred object and

122
00:06:40.459 --> 00:06:41.250
xs.tail.

123
00:06:41.250 --> 00:06:44.011
Otherwise, just filter(f,xs.tail).

124
00:06:44.011 --> 00:06:47.148
And then finally, for length,
that's the third function we needed.

125
00:06:47.148 --> 00:06:49.878
I could again produce
a recursive solution but

126
00:06:49.878 --> 00:06:52.960
here actually the while
loop version isn't so bad.

127
00:06:52.960 --> 00:06:57.410
So I decided in porting my code to
go ahead and just say static method,

128
00:06:57.410 --> 00:07:00.100
return an alpha, length,
take a list of alphas.

129
00:07:00.100 --> 00:07:07.570
No closure needed, walk down the list
setting xs = xs.tail, incrementing

130
00:07:07.570 --> 00:07:12.830
variable ans, mutation, imperative update,
and then just return ans, okay?

131
00:07:12.830 --> 00:07:14.069
So that is my library.

132
00:07:15.550 --> 00:07:19.950
Let's flip back to the slides here and

133
00:07:19.950 --> 00:07:22.290
talk about why I made
these static methods.

134
00:07:23.310 --> 00:07:28.440
So a more object-oriented approach would
be to make these instance methods.

135
00:07:28.440 --> 00:07:32.660
That the class would have methods map,
filter, and length that look like this.

136
00:07:32.660 --> 00:07:37.650
They wouldn't take list arguments
because the enclosing object, this,

137
00:07:37.650 --> 00:07:39.190
would be the list.

138
00:07:39.190 --> 00:07:44.683
So they would just take a function
that took an element of type T,

139
00:07:44.683 --> 00:07:47.856
the type of the list and returned a B.

140
00:07:47.856 --> 00:07:49.618
And then we would make a list of Bs.

141
00:07:49.618 --> 00:07:52.550
Similarly, filter will take
a predicate over Ts and

142
00:07:52.550 --> 00:07:55.690
length would take no arguments and
just return an int.

143
00:07:55.690 --> 00:08:00.040
The reason why this doesn't work very
well is that it interacts poorly with our

144
00:08:00.040 --> 00:08:03.370
decision to represent
the empty list with null.

145
00:08:03.370 --> 00:08:09.275
Now clients, users of our library,
will not be able to take a list xs and

146
00:08:09.275 --> 00:08:14.350
say xs.map or
xs.filter if that list might be empty.

147
00:08:14.350 --> 00:08:17.990
Because if you try to call a method on
null, you get a null pointer exception.

148
00:08:17.990 --> 00:08:22.007
I think every Java programmer ever has
suffered through null pointer exceptions.

149
00:08:22.007 --> 00:08:25.865
And we would force every
client to check for null and

150
00:08:25.865 --> 00:08:31.850
deal with the null cases themselves
before calling map filter a length.

151
00:08:31.850 --> 00:08:35.620
Whereas our static methods could
handle the null case for them.

152
00:08:35.620 --> 00:08:38.640
So it turns out, this is not picking
on object-oriented programming.

153
00:08:38.640 --> 00:08:41.410
The real problem here was
our choice of using null.

154
00:08:41.410 --> 00:08:45.660
In fact, a more object-oriented
approach would be to not use null for

155
00:08:45.660 --> 00:08:46.770
the empty list.

156
00:08:46.770 --> 00:08:52.340
To instead have two
subclasses of the list class,

157
00:08:52.340 --> 00:08:56.000
one for empty lists and
one for non-empty lists.

158
00:08:56.000 --> 00:08:59.740
I have not written that code for you but
what you do is you take the empty list

159
00:08:59.740 --> 00:09:03.710
subclass, you implement map,
filter, and length quite easily.

160
00:09:03.710 --> 00:09:06.680
Map and
filter just return another empty list.

161
00:09:06.680 --> 00:09:08.460
Length returns zero.

162
00:09:08.460 --> 00:09:11.869
And then everything works correctly.

163
00:09:11.869 --> 00:09:15.460
And there is no problem with it,
and I actually prefer that.

164
00:09:15.460 --> 00:09:18.700
In my opinion, if you want to
do object-oriented programming,

165
00:09:18.700 --> 00:09:23.040
you need to rid yourself of
the bad habit of leaning on null

166
00:09:23.040 --> 00:09:25.899
when it gets you into trouble for
a code like we're writing here.

167
00:09:26.970 --> 00:09:28.723
All right, so now let's finish the story.

168
00:09:28.723 --> 00:09:32.743
If you remember our ML code,
we also had some clients of our library.

169
00:09:32.743 --> 00:09:37.378
We wrote two functions,
one that doubled all the elements and

170
00:09:37.378 --> 00:09:39.350
a list mapping across it.

171
00:09:39.350 --> 00:09:41.436
And the other that counts
how many ends are in it.

172
00:09:41.436 --> 00:09:45.357
Here is the code and
it is admittedly a bit of a mess.

173
00:09:45.357 --> 00:09:49.000
So let me explain what's going on.

174
00:09:49.000 --> 00:09:52.660
When we want to call doubleAll,
we want to define a doubleAll method,

175
00:09:52.660 --> 00:09:54.518
I'm making it a static method here.

176
00:09:54.518 --> 00:09:59.130
It wants to take a list of INTs or
integers and return a list of integers.

177
00:09:59.130 --> 00:10:03.406
All it's going to do when you
call it is call list.map with xs.

178
00:10:03.406 --> 00:10:07.418
And now what I need to do is pass
in the appropriate object that is

179
00:10:07.418 --> 00:10:08.944
acting like a closure.

180
00:10:08.944 --> 00:10:12.930
So what I need to do is I need to make
a new instance of that interface.

181
00:10:12.930 --> 00:10:17.278
And I'm using here
an anonymous inner class.

182
00:10:17.278 --> 00:10:21.494
This, if you've never seen this syntax,
it's mostly just syntactic sugar for

183
00:10:21.494 --> 00:10:24.038
defining a class that
implements an interface.

184
00:10:24.038 --> 00:10:27.650
And then providing an implementation
of the appropriate method.

185
00:10:27.650 --> 00:10:32.110
But right here I'm saying,
make a new object

186
00:10:32.110 --> 00:10:36.990
that implements the Func interface for
arguments integer and integer.

187
00:10:36.990 --> 00:10:41.720
And let its method m take in
an integer x and return x times 2.

188
00:10:41.720 --> 00:10:44.220
So a lot of clumsy syntax,
but it gets the job done, and

189
00:10:44.220 --> 00:10:46.630
that will double all
the elements in this list.

190
00:10:46.630 --> 00:10:50.230
As for counting the ns,
I can write the same code I wrote in ML.

191
00:10:50.230 --> 00:10:55.900
I want to take the length of filtering
to include only numbers that equal n.

192
00:10:55.900 --> 00:11:00.900
I do the same thing where now I create
an implementation of the Pred of integer

193
00:11:00.900 --> 00:11:01.990
interface.

194
00:11:01.990 --> 00:11:07.695
And the body of my one method m
takes an x and just asks if x=n.

195
00:11:07.695 --> 00:11:11.916
The one thing that's neat here,
is in Java you can use this

196
00:11:11.916 --> 00:11:16.420
n that is in scope here but
only because it's declared final.

197
00:11:16.420 --> 00:11:19.590
Java will not let you do
this if n can be updated and

198
00:11:19.590 --> 00:11:21.980
it's a longer story than
I want to get into here.

199
00:11:21.980 --> 00:11:24.387
But there are good reasons for it.

200
00:11:24.387 --> 00:11:26.340
And so that's the end of our story.

201
00:11:26.340 --> 00:11:31.621
So essentially what our clients do is
if you want to map from a List<foo>

202
00:11:31.621 --> 00:11:38.042
to a List<Bar> you define a class c that
implements the interface Func<Bar, Foo>.

203
00:11:38.042 --> 00:11:40.795
And use its fields to
hold any private data.

204
00:11:40.795 --> 00:11:43.004
Because we didn't need
any of those fields,

205
00:11:43.004 --> 00:11:47.150
we just used this anonymous inner class,
which is mostly syntactic sugar.

206
00:11:47.150 --> 00:11:50.808
And then we pass the resulting
object to map, all right?

207
00:11:50.808 --> 00:11:54.180
The count ns example is more
interesting because we did need that

208
00:11:54.180 --> 00:11:55.540
n in our environment.

209
00:11:55.540 --> 00:11:58.110
We could have created
a class with a field.

210
00:11:58.110 --> 00:12:01.660
Instead, we did that trick that
if you put final, you're okay.

211
00:12:01.660 --> 00:12:03.660
All right,
that's your advanced wizardry for

212
00:12:03.660 --> 00:12:08.120
Java closures,
faking closures in Java by using objects.