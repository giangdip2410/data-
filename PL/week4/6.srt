WEBVTT

1
00:00:00.000 --> 00:00:05.647
[SOUND] We've now seen a number of 
examples of first class functions, 

2
00:00:05.647 --> 00:00:12.113
including my favorites, map and filter. 
But all of our examples so far have been 

3
00:00:12.113 --> 00:00:17.924
similar enough that I want to emphasize 
now just how general first class 

4
00:00:17.924 --> 00:00:21.346
functions are. 
So, so far our examples, N times, map, 

5
00:00:21.346 --> 00:00:26.613
filter and probably a couple others, have 
all just had one function that took one 

6
00:00:26.613 --> 00:00:31.750
other function as an argument and then 
recursively processed numbers and lists. 

7
00:00:31.750 --> 00:00:36.887
So I just want to remind you that we can 
use functions wherever we can use any 

8
00:00:36.887 --> 00:00:40.594
kind of expression. 
This is actually a useful thing to do. 

9
00:00:40.594 --> 00:00:45.536
So a couple things I won't show you 
examples of in this segment are passing 

10
00:00:45.536 --> 00:00:48.528
multiple functions as arguments to a 
function. 

11
00:00:48.528 --> 00:00:52.560
The same way we passing one function that 
I've been calling F. 

12
00:00:52.560 --> 00:00:55.158
To abstract over some sort of 
computation. 

13
00:00:55.158 --> 00:01:00.107
If you had two different computations you 
wanted to abstract over. It would make 

14
00:01:00.107 --> 00:01:04.190
perfect sense to pass in, have callers 
pass two different functions. 

15
00:01:04.190 --> 00:01:08.455
So that's the first thing we can do with 
the first class functions we haven't seen 

16
00:01:08.455 --> 00:01:10.818
so far. 
Another one is we can put functions in 

17
00:01:10.818 --> 00:01:13.182
data structures in tuples or lists or 
records. 

18
00:01:13.182 --> 00:01:17.344
And I'll show you an idiom that uses that 
later in this section of the course, 

19
00:01:17.344 --> 00:01:20.890
but we're not going to do it quite now, 
because we want to have some other 

20
00:01:20.890 --> 00:01:23.100
features and study some other things 
first. 

21
00:01:23.100 --> 00:01:27.393
But two things I am going to do in this 
segment are have functions return other 

22
00:01:27.393 --> 00:01:30.774
functions as results, 
just a silly example to show you how that 

23
00:01:30.774 --> 00:01:32.921
works. 
And then, we're going to write a high 

24
00:01:32.921 --> 00:01:37.375
order function over a data structure that 
is not a list, that's actually one of our 

25
00:01:37.375 --> 00:01:39.218
own data type findings. 
All right. 

26
00:01:39.218 --> 00:01:43.846
So let's do the returning functions 
first, and how about I just show you the 

27
00:01:43.846 --> 00:01:47.561
code to start with. 
So here is a function that actually takes 

28
00:01:47.561 --> 00:01:52.128
a function and also returns a function. 
So it takes in an argument, F, and it 

29
00:01:52.128 --> 00:01:55.416
calls F with seven, that's how I know 
it's an argument. 

30
00:01:55.416 --> 00:02:00.348
So in fact, for this part to type check, 
I can tell you that this function overall 

31
00:02:00.348 --> 00:02:04.550
has to take in an int arrow bool, that, 
that needs to be the type of F. 

32
00:02:04.550 --> 00:02:07.605
All right. 
But then, if you look at the then branch 

33
00:02:07.605 --> 00:02:10.966
and the else branch, in each case, it 
returns a function. 

34
00:02:10.966 --> 00:02:15.487
It turns out an anonymous function. 
Although you could have any expression 

35
00:02:15.487 --> 00:02:20.131
there that evaluated to a function, and 
in both cases, since we know then and 

36
00:02:20.131 --> 00:02:24.897
else always have to have the same type, 
we have functions of the same type, and 

37
00:02:24.897 --> 00:02:28.197
in fact, this function always returns an 
int arrow int. 

38
00:02:28.197 --> 00:02:32.963
So the function binding for double or 
triple defines a function that takes in 

39
00:02:32.963 --> 00:02:35.835
an int arrow bool and returns an int 
arrow int. 

40
00:02:35.835 --> 00:02:39.532
Oops, sorry about that. 
So let me show a couple of uses of this. 

41
00:02:39.532 --> 00:02:43.532
here's, I'm going to write down an 
expression that's going to end up 

42
00:02:43.532 --> 00:02:47.179
returning the first function that given X 
returns two times X. 

43
00:02:47.179 --> 00:02:51.944
So I'll bind this to the variable double. 
If I, all I have to do is call double or 

44
00:02:51.944 --> 00:02:56.238
triple with some argument that will cause 
F of seven to evaluate to true. 

45
00:02:56.238 --> 00:03:00.355
So there's any number of them but how 
about X minus three equals four. 

46
00:03:00.355 --> 00:03:02.590
Okay? 
If I called out I'm going to end up 

47
00:03:02.590 --> 00:03:06.590
getting the double function back. 
Notice that double is not a number. 

48
00:03:06.590 --> 00:03:10.120
It's a function, because double or triple 
returns a function. 

49
00:03:10.120 --> 00:03:14.844
We could take that and then call it, or 
we could take another call to double or 

50
00:03:14.844 --> 00:03:18.731
triple, maybe something that returns 
false, like fun X, X equals 42, 

51
00:03:18.731 --> 00:03:21.662
that will not return true when applied to 
7. 

52
00:03:21.662 --> 00:03:26.028
If we could just take that entire 
expression which will end up being the 

53
00:03:26.028 --> 00:03:30.692
function that takes its argument an 
multiplies it by three and if I call that 

54
00:03:30.692 --> 00:03:34.640
with 3, I'll end up with 3 times 3, which 
is 9. 

55
00:03:34.640 --> 00:03:37.340
Okay? 
So how about we try all that out real 

56
00:03:37.340 --> 00:03:39.476
quick? 
Use generalizing dot SML. 

57
00:03:39.476 --> 00:03:43.684
And sure enough, double or triple is just 
about the type I told you. 

58
00:03:43.684 --> 00:03:48.332
We'll get back to that in just a second. 
Double is indeed an int arrow int, 

59
00:03:48.332 --> 00:03:53.232
and to make sure it's the function we 
think it is, yes indeed, double zero four 

60
00:03:53.232 --> 00:03:58.320
returned eight, and this last expression 
I wrote down did indeed evaluate to nine. 

61
00:03:58.320 --> 00:04:03.371
Alright, so now the only remaining thing 
I want to talk about here is how I said 

62
00:04:03.371 --> 00:04:08.486
the type of double or triple was this, 
taken int arrow bool, returning int arrow 

63
00:04:08.486 --> 00:04:11.516
int. 
And the REPL said this type, and just 

64
00:04:11.516 --> 00:04:14.547
left off the parentheses around the 
result type. 

65
00:04:14.547 --> 00:04:19.662
It always does that, the REPL never 
prints parentheses it does not have to 

66
00:04:19.662 --> 00:04:23.008
and it turns out that those parentheses 
are optional. 

67
00:04:23.008 --> 00:04:27.681
So to see that let me show you the 
general rule which I have down here at 

68
00:04:27.681 --> 00:04:32.167
the bottom of this slide. 
When you see a type like T, with multiple 

69
00:04:32.167 --> 00:04:37.211
arrows like this, like T1 arrow, T2 
arrow, T3 arrow, T4, the implicit 

70
00:04:37.211 --> 00:04:42.641
parenthesis are always on the right. 
So this for example would be a function 

71
00:04:42.641 --> 00:04:47.051
that takes a T1 and returns another 
function that takes a T2, that itself 

72
00:04:47.051 --> 00:04:50.873
returns another function that takes a T3 
and then returns a T4. 

73
00:04:50.873 --> 00:04:55.342
So when you're first seeing functions 
that return functions, you really wish 

74
00:04:55.342 --> 00:04:58.164
the REPL would put in those parentheses 
for you. 

75
00:04:58.164 --> 00:05:02.104
It's not going to, so you have to put 
them in yourself in your head. 

76
00:05:02.104 --> 00:05:06.926
And you get used to this fairly quickly 
and then you end up liking, in fact, the 

77
00:05:06.926 --> 00:05:10.160
conciseness of leaving off the 
unnecessary parentheses. 

78
00:05:10.160 --> 00:05:13.949
Alright, so that was functions returning 
other functions. 

79
00:05:13.949 --> 00:05:19.227
Now let me remind you that high-order 
functions are not just good for numbers 

80
00:05:19.227 --> 00:05:23.363
and lists. 
They're a great way to process, for any 

81
00:05:23.363 --> 00:05:28.598
sort of recursive data structure, where 
you might want to do the same sort of 

82
00:05:28.598 --> 00:05:33.017
recursive traversal with many different 
possible, computations. 

83
00:05:33.017 --> 00:05:37.572
So for an example of that, let me go back 
over here and scroll down. 

84
00:05:37.572 --> 00:05:42.807
I have our old friend, this data type 
binding for arithmetic expressions, and 

85
00:05:42.807 --> 00:05:48.042
suppose I give you a homework problem 
like, given an X, one of these things, is 

86
00:05:48.042 --> 00:05:52.964
every constant in it an even number? 
You could write that recursive function, 

87
00:05:52.964 --> 00:05:57.788
but suppose I had another homework 
question that said is every constant in 

88
00:05:57.788 --> 00:06:01.070
it less than ten. 
And you could write that as well but it 

89
00:06:01.070 --> 00:06:05.530
would be very, very similar and if you 
had a bunch of these traversals that were 

90
00:06:05.530 --> 00:06:08.430
all of the form is something true of 
every constant. 

91
00:06:08.430 --> 00:06:13.227
It would be a great idea to abstract that 
kind of traversal, that kind of 

92
00:06:13.227 --> 00:06:16.644
processing of the data, into a higher 
order function. 

93
00:06:16.644 --> 00:06:19.930
So let me, show you how may, might, we 
might do that. 

94
00:06:19.930 --> 00:06:23.019
I might write a function true of all 
constants. 

95
00:06:23.019 --> 00:06:27.751
It's going to take in a function and an 
E, and it's going to say, does F return 

96
00:06:27.751 --> 00:06:29.123
true. 
For every constant. 

97
00:06:29.123 --> 00:06:33.186
So it's a lot like a filter, in the sense 
that we're going to call F on every 

98
00:06:33.186 --> 00:06:36.150
constant in here. 
But it's not a filter, it's going to, the 

99
00:06:36.150 --> 00:06:38.621
whole thing is going to return true or 
false. 

100
00:06:38.621 --> 00:06:42.410
So if our entire expression is a 
constant, then I just want to call F. 

101
00:06:42.410 --> 00:06:47.477
On that constant and all the other cases 
are just recursively calling true of all 

102
00:06:47.477 --> 00:06:51.864
constants on the sub-expressions, so that 
we can find all the constants. 

103
00:06:51.864 --> 00:06:56.931
And this is the sort of thing that's fine 
to write out once but it'd be a pain to 

104
00:06:56.931 --> 00:07:01.813
write it out over and over again for all 
the different questions we might have 

105
00:07:01.813 --> 00:07:06.714
about the constants and expressions. 
So it's great that we're abstracting it 

106
00:07:06.714 --> 00:07:11.819
into a higher order function that then 
we'll be able to use multiple times. 

107
00:07:11.819 --> 00:07:13.861
Okay? 
And I think that's right. 

108
00:07:13.861 --> 00:07:19.102
And then it's such a pain to write this 
out. I'm even going to copy and paste 

109
00:07:19.102 --> 00:07:22.030
just a little bit and write multiply 
there. 

110
00:07:22.030 --> 00:07:27.515
And now, if I wrote this once, and I 
wanted to write the function that I 

111
00:07:27.515 --> 00:07:32.383
started with, all even. 
Take an expression, are all the constants 

112
00:07:32.383 --> 00:07:35.860
in it even? 
Then I would just say, true of all 

113
00:07:35.860 --> 00:07:41.886
constants, and pass in a little function 
that asks if the argument is even, and 

114
00:07:41.886 --> 00:07:46.960
call that with E. 
And let's see if I got all that right. 

115
00:07:49.620 --> 00:07:55.293
[SOUND]. 
And I at least got the types right. 

116
00:07:55.293 --> 00:08:00.312
all even is indeed a function that takes 
in an X and returns a bool. 

117
00:08:00.312 --> 00:08:03.210
Yes or no, are all the, the constants 
even? 

118
00:08:03.210 --> 00:08:08.016
True of all constants is one of those 
high order functions that has nice type 

119
00:08:08.016 --> 00:08:11.636
that it really kind of explains a little 
bit what's going on. 

120
00:08:11.636 --> 00:08:16.325
Although not completely, you still need 
documentation for the function. It takes 

121
00:08:16.325 --> 00:08:21.804
in an X and an int arrow bool, because we 
know that we take that function argument. 

122
00:08:21.804 --> 00:08:27.080
We apply it to constants, and then the 
entire thing, the result type is bool. 

123
00:08:27.080 --> 00:08:32.490
Yes or no, the and also is combined to 
return true or false based on whether all 

124
00:08:32.490 --> 00:08:37.090
the constants, are true according to this 
int arrow bool argument. 

125
00:08:37.090 --> 00:08:41.622
So when you have these functions that 
have return type bool like this, that 

126
00:08:41.622 --> 00:08:44.583
process some data, 
I like to call them predicates. 

127
00:08:44.583 --> 00:08:48.873
It's a nice mathematical world. 
The predicate is something that returns 

128
00:08:48.873 --> 00:08:53.042
true or false for something, 
and this is an example of a higher order 

129
00:08:53.042 --> 00:08:57.514
predicate. It takes in, it abstracts over 
that computation, says give me any 

130
00:08:57.514 --> 00:09:01.805
integer bool and I'll give you a 
predicate that uses that int arrow bool. 