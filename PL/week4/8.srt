WEBVTT

1
00:00:00.000 --> 00:00:04.408
[MUSIC] Okay, I want to continue our 
discussion of lexical scope. 

2
00:00:04.408 --> 00:00:08.885
Now, I am going to pass into the 
discussion, functions that take and 

3
00:00:08.885 --> 00:00:12.880
return there functions. 
So, the rule is not going to change. 

4
00:00:12.880 --> 00:00:18.321
The rule is the way always evaluate the 
function body in the environment where 

5
00:00:18.321 --> 00:00:22.867
the function was defined. 
At the point we created that function, we 

6
00:00:22.867 --> 00:00:26.862
made a closure with the environment, we 
had at that moment. 

7
00:00:26.862 --> 00:00:31.340
And that's the environment we used when 
we later called the function. 

8
00:00:31.340 --> 00:00:35.297
So, nothing is going to change here 
except what the environment is, is going 

9
00:00:35.297 --> 00:00:39.519
to be much more interesting because we're 
going to have nested let expressions, 

10
00:00:39.519 --> 00:00:42.790
we're going to take functions, we're 
going to return functions. 

11
00:00:42.790 --> 00:00:46.484
So, in this segment, I'm going to do two 
examples that are a little bit 

12
00:00:46.484 --> 00:00:50.178
complicated and are silly, and they're 
not going to motivate the semantics. 

13
00:00:50.178 --> 00:00:54.452
And then in later segments, we'll get to 
why you want the semantics and how it 

14
00:00:54.452 --> 00:00:56.252
lets you do powerful things, 
okay? 

15
00:00:56.252 --> 00:00:59.601
So, let's go to the code. here's our 
first example. 

16
00:00:59.601 --> 00:01:04.753
Let's just walk through it line by line. 
So, we start with an environment where x 

17
00:01:04.753 --> 00:01:09.713
is one, this is going to turn out to be 
irrelevant, because we're going to end up 

18
00:01:09.713 --> 00:01:13.320
shadowing x anywhere before we could 
possibly use it. 

19
00:01:13.320 --> 00:01:18.371
Then on this next line, we're defining a 
function y and this, oh, sorry function 

20
00:01:18.371 --> 00:01:20.638
f. 
And this function f returns this 

21
00:01:20.638 --> 00:01:24.847
anonymous function right here. 
So, let's just look at this function. 

22
00:01:24.847 --> 00:01:29.769
And the great thing about lexical scope 
is we can figure out what this function 

23
00:01:29.769 --> 00:01:35.080
does completely separate from the rest of 
the file and how it's potentially called. 

24
00:01:35.080 --> 00:01:42.085
So, the function f takes an argument y, 
creates a local variable x that holds y + 

25
00:01:42.085 --> 00:01:45.492
1. 
So, that's going to shadow in here, this 

26
00:01:45.492 --> 00:01:51.196
outer x, that would have been in the 
environment but, of course, it's shadowed 

27
00:01:51.196 --> 00:01:56.346
in the body of this let expression. 
We then return this function, 

28
00:01:56.346 --> 00:02:00.150
alright? 
So whenever you call f with some y, this 

29
00:02:00.150 --> 00:02:05.933
is going to take z and return in terms of 
f's argument, 2y + 1, 

30
00:02:05.933 --> 00:02:10.133
right? 
Because x is y + 1 and we're adding x and 

31
00:02:10.133 --> 00:02:14.120
y and z together. 
That is what it will always do because 

32
00:02:14.120 --> 00:02:19.577
the environment where this function was 
defined had whatever y maps to based on 

33
00:02:19.577 --> 00:02:25.873
the call to f and then x-mapping 2y + 1. 
So let's see that in action with a use of 

34
00:02:25.873 --> 00:02:29.072
f and a use of the function that's 
returned. 

35
00:02:29.072 --> 00:02:34.380
Down here, I'm going to have val x = 3. 
This will again be irrelevant. 

36
00:02:34.380 --> 00:02:37.506
I'm just putting it here to show that 
it's irrelevant. 

37
00:02:37.506 --> 00:02:43.177
[SOUND] And the reason why it's 
irrelevant is right here I call f with 

38
00:02:43.177 --> 00:02:43.905
four, 
okay? 

39
00:02:43.905 --> 00:02:49.503
So, this is going to return a function 
[SOUND] that adds 9 to its argument. 

40
00:02:49.503 --> 00:02:55.320
[SOUND] The reason why it's 9 is because 
2Y + 1, where y is four, is nine. 

41
00:02:55.320 --> 00:03:00.191
We call f with four, so we go up to the 
body of f right here, 

42
00:03:00.191 --> 00:03:06.768
y is four, we create an environment where 
y is four and x is five and we return a 

43
00:03:06.768 --> 00:03:13.020
function that when called will use that 
environment, extended with whatever z 

44
00:03:13.020 --> 00:03:18.436
maps to. 
So sure enough, right here where I call 

45
00:03:18.436 --> 00:03:27.480
g, the function returned up here, 
when I call g with six, I will get 15 

46
00:03:28.560 --> 00:03:34.274
because that is 9 + 6. 
The fact that this y is five here, also 

47
00:03:34.274 --> 00:03:38.580
irrelevant. 
The same way that we're not going to use 

48
00:03:38.580 --> 00:03:44.625
the fact that X is three, when we 
evaluate this x plus y plus z, we're not 

49
00:03:44.625 --> 00:03:50.340
going to use this y = 5. 
When we evaluate this x plus y plus z, we 

50
00:03:50.340 --> 00:03:54.563
use the environment where the function 
was created, 

51
00:03:54.563 --> 00:03:58.831
y is four, x is five. 
If we had another call to f down here 

52
00:03:58.831 --> 00:04:03.711
with a different argument, that would 
create a different closure with a 

53
00:04:03.711 --> 00:04:08.796
different environment, one where x was, 
oh, sorry, y was eight, and x was nine, 

54
00:04:08.796 --> 00:04:14.569
so that would return a function that 
always added 17 to its argument, okay? 

55
00:04:14.569 --> 00:04:18.967
So, that's our first example, let us now 
go to our second example. 

56
00:04:18.967 --> 00:04:24.053
In the second example, we're going to 
pass in a function to a function rather 

57
00:04:24.053 --> 00:04:26.940
then returning a function from a 
function, 

58
00:04:28.340 --> 00:04:31.660
alright? 
So, here is our function f that takes a 

59
00:04:31.660 --> 00:04:34.910
function g. 
And all it does is call g with two. 

60
00:04:34.910 --> 00:04:38.230
the rest of this is more irrelevant 
clutter. 

61
00:04:38.230 --> 00:04:40.844
And, in fact, 
let's look at function F. 

62
00:04:40.844 --> 00:04:46.566
And again, the advantage of lexical scope 
is we can understand a function just by 

63
00:04:46.566 --> 00:04:50.593
looking at its definition and what is in 
its environment. 

64
00:04:50.593 --> 00:04:55.477
We never have to look at how it's called. 
So, if I look at this function, I say, 

65
00:04:55.477 --> 00:04:58.238
oh, it takes a function g and it calls it 
with two. 

66
00:04:58.238 --> 00:05:02.380
And, in fact, the rest of this is, I 
mean, I'm just defining a variable that's 

67
00:05:02.380 --> 00:05:06.521
never used so I would very naturally just 
come in here and delete all these. 

68
00:05:06.521 --> 00:05:10.718
I'm, and, it just, I'm commenting it out 
here so you can still see it, but that 

69
00:05:10.718 --> 00:05:15.025
should be exactly the same function, a 
function that takes its argument and 

70
00:05:15.025 --> 00:05:19.221
calls it with two, is the same as a 
function that defines a local variable x 

71
00:05:19.221 --> 00:05:23.207
to be three and then calls g with two. 
So, the great thing about lexical scope 

72
00:05:23.207 --> 00:05:27.126
is you can do this kind of code 
maintenance and know that its never going 

73
00:05:27.126 --> 00:05:31.975
to change how the function behaves. 
Let's see that by following through with 

74
00:05:31.975 --> 00:05:35.670
an actual call. 
So here, I have val x = 4. 

75
00:05:35.670 --> 00:05:41.258
And now, I create a little function here, 
h. So, this function is always going to 

76
00:05:41.258 --> 00:05:43.407
add four to its arguement. 
Why? 

77
00:05:43.407 --> 00:05:48.923
because it's the same thing at top level. 
When I create this binding h, I create a 

78
00:05:48.923 --> 00:05:53.723
closure that has it, the current 
environment where the function was 

79
00:05:53.723 --> 00:05:56.589
defined. 
And then at this point, we have an 

80
00:05:56.589 --> 00:06:02.392
evironment where x is four, so h is bound 
to a function that will always add four 

81
00:06:02.392 --> 00:06:06.982
to its arguement. 
So now, we got to the exciting last line 

82
00:06:06.982 --> 00:06:12.293
where we're going to call f with h. 
So, I'm going to look up f and I'm going 

83
00:06:12.293 --> 00:06:17.689
to get this function that always calls 
its argument with two. 

84
00:06:17.689 --> 00:06:23.843
And I'm going to pass in h, which is a 
function that always adds four to its 

85
00:06:23.843 --> 00:06:26.119
argument. 
So, I will get six, 

86
00:06:26.119 --> 00:06:31.228
I will not get seven. 
Seven is what you would get if you passed 

87
00:06:31.228 --> 00:06:33.613
in this code, which has body xy. 
+ y. 

88
00:06:33.613 --> 00:06:38.860
And then here said, oh, now, I want to 
look up x in this environment. 

89
00:06:38.860 --> 00:06:43.550
But that's wrong. 
We always look up x in the body where the 

90
00:06:43.550 --> 00:06:49.353
function we're calling was defined. 
And here, we pass for g the function h, 

91
00:06:49.353 --> 00:06:54.281
that's this function. 
We looked up h in the environment, we got 

92
00:06:54.281 --> 00:06:58.972
this function that adds four to its 
argument and so we get six, 

93
00:06:58.972 --> 00:07:01.133
alright? 
So, those are our two complicated 

94
00:07:01.133 --> 00:07:03.871
examples. 
If you don't believe me, feel free to go 

95
00:07:03.871 --> 00:07:07.615
back through them more slowly. 
Try them in the read–eval–print loop. 

96
00:07:07.615 --> 00:07:11.303
See what the different variables are 
bound to at different points. 

97
00:07:11.303 --> 00:07:15.885
The remaining slides here have the exact 
same examples and a little bit more text 

98
00:07:15.885 --> 00:07:19.238
to walk you through it. 
So, this was the first example we did 

99
00:07:19.238 --> 00:07:24.155
when we ended up with 16, and this is the 
second example where we ended up with six 

100
00:07:24.155 --> 00:07:26.689
bound to z. 
So now, that we hopefully understand 

101
00:07:26.689 --> 00:07:30.954
lexical scope and believe me that we 
didn't change the rule in this segment, 

102
00:07:30.954 --> 00:07:34.953
it's the same rule we had before, 
we can move on to discussing why you want 

103
00:07:34.953 --> 00:07:37.299
the semantics for your programming 
language. 