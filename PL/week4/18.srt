WEBVTT

1
00:00:00.012 --> 00:00:06.183
[MUSIC] There's just one more topic you 
need for Homework 3 and that's a little 

2
00:00:06.183 --> 00:00:10.960
bit of guidance on how to find functions 
in ML standard library. 

3
00:00:10.960 --> 00:00:16.677
So this doesn't really have a lot to do 
with the rest of the section other than 

4
00:00:16.677 --> 00:00:22.478
the standard library does have a lot of 
useful and in good style high order 

5
00:00:22.478 --> 00:00:25.907
functions. 
Well we decided to make it a small part 

6
00:00:25.907 --> 00:00:31.277
of Homework3 because learning how, new 
programming languages and how to use them 

7
00:00:31.277 --> 00:00:34.747
does involve learning how to find things 
in libraries. 

8
00:00:34.747 --> 00:00:38.662
So ML like most programming languages has 
a standard library. 

9
00:00:38.662 --> 00:00:41.402
This is just code that is always 
provided. 

10
00:00:41.402 --> 00:00:45.021
in a particular way with any 
implementation of the language. 

11
00:00:45.021 --> 00:00:49.117
I like to make this distinction that 
there are two sorts of things that you 

12
00:00:49.117 --> 00:00:53.321
put in a standard library when you're 
designing your programming language. 

13
00:00:53.321 --> 00:00:56.182
First, you put things that if you do not 
put them. 

14
00:00:56.182 --> 00:00:59.210
Noone using your language, will be able 
to do things. 

15
00:00:59.210 --> 00:01:03.504
If you don't give a way to open a file, 
on the computer the program is running 

16
00:01:03.504 --> 00:01:06.644
on, you can't write code that will do it 
some other way. 

17
00:01:06.644 --> 00:01:11.235
You need libraries for setting timers, 
libraries for accessing the network, 

18
00:01:11.235 --> 00:01:16.002
libraries for printing things out. 
These are things that you can't build out 

19
00:01:16.002 --> 00:01:19.332
of other pieces like lists and numbers 
and strength. 

20
00:01:19.332 --> 00:01:24.207
The other thing you put in a standard 
library is actually optional relatively 

21
00:01:24.207 --> 00:01:27.397
speaking. 
These are just things that are so common 

22
00:01:27.397 --> 00:01:30.612
that having a standard definition is 
appropriate. 

23
00:01:30.612 --> 00:01:35.847
Since ML programmers are going to use 
List.map, if we define it in the library, 

24
00:01:35.847 --> 00:01:40.836
in 1 place, with 1 name, with 1 set of 
arguments in a particular order, then 

25
00:01:40.836 --> 00:01:45.874
everyone can use it, and we can all read 
each others code more easily, and we 

26
00:01:45.874 --> 00:01:51.082
don't all have to rewrite the same 
function for every program we're writing. 

27
00:01:51.082 --> 00:01:54.335
So those are the two things one puts in a 
standard library. 

28
00:01:54.335 --> 00:01:58.406
And as I mentioned, you should be 
comfortable in any language seeking out 

29
00:01:58.406 --> 00:02:01.706
documentation and gaining some intuition 
on where to look. 

30
00:02:01.706 --> 00:02:06.010
it doesn't make sense to always every 
time you need a function expect that 

31
00:02:06.010 --> 00:02:10.386
someone like a course instructor will 
tell you exactly what function to use and 

32
00:02:10.386 --> 00:02:12.321
where to look for it. 
For it. 

33
00:02:12.321 --> 00:02:15.237
Okay. 
So standard ML has documentation for its 

34
00:02:15.237 --> 00:02:20.392
standard library, it's actually quite a 
but more primitive than the documentation 

35
00:02:20.392 --> 00:02:25.277
for most modern programming languages. 
But it will meet our needs, and it's at 

36
00:02:25.277 --> 00:02:27.457
this URL you will see here. 
Here. 

37
00:02:27.457 --> 00:02:31.437
Now, it's organized into things called 
structures and signatures. 

38
00:02:31.437 --> 00:02:36.152
This is using ML's module system, which 
we're going to study just a little bit in 

39
00:02:36.152 --> 00:02:39.312
the next section. 
But we can use the library before we 

40
00:02:39.312 --> 00:02:42.062
really understand structures and 
signatures. 

41
00:02:42.062 --> 00:02:45.992
And on homework 3 you just need to look 
things up in a few places. 

42
00:02:45.992 --> 00:02:50.923
Things related to strings, characters so 
the char structure, lists, and they've 

43
00:02:50.923 --> 00:02:54.975
separated out list pair. 
Those are functions that operate over two 

44
00:02:54.975 --> 00:02:58.558
different lists. 
'Kay, once you find something the way you 

45
00:02:58.558 --> 00:03:02.902
use it is exactly like we have been using 
library functions already. 

46
00:03:02.902 --> 00:03:07.552
Whatever structure it's in, you write the 
name of the structure then a dot, and 

47
00:03:07.552 --> 00:03:11.842
then the function, so List.map, 
String.issubstring, or anything else. 

48
00:03:11.842 --> 00:03:16.307
So I do have a web browser open here. 
This is the URL I've pointed you to, and 

49
00:03:16.307 --> 00:03:20.907
there's a nice long list of things. 
There's functions for Arrays, some things 

50
00:03:20.907 --> 00:03:24.818
for the Command Line. 
Some things for oh, INetSock is probably 

51
00:03:24.818 --> 00:03:28.727
for accessing the network. 
One of the ones that we'll be interested 

52
00:03:28.727 --> 00:03:32.405
in is the List structure where we have 
lots of stuff over lists. 

53
00:03:32.405 --> 00:03:35.649
It gives a little synopsis of what this 
module is about. 

54
00:03:35.649 --> 00:03:40.362
and then it lists all the different 
functions that are defined, just like the 

55
00:03:40.362 --> 00:03:44.296
REPL would print them out. 
And the below that it has the actual 

56
00:03:44.296 --> 00:03:48.168
documentation. 
Giving the documentation of the semantics 

57
00:03:48.168 --> 00:03:52.782
of what these functions will do. 
So, for example, I never told you there 

58
00:03:52.782 --> 00:03:57.183
is a function last, that takes a list l 
and returns last element of l. 

59
00:03:57.183 --> 00:04:00.653
It raises a particular exception if the 
list is empty. 

60
00:04:00.653 --> 00:04:02.772
And so on and so forth. 
Okay. 

61
00:04:02.772 --> 00:04:07.974
So that's the documentation. 
There is no full substitute for proper 

62
00:04:07.974 --> 00:04:13.484
written documentation about how a library 
should be used, in that form. 

63
00:04:13.484 --> 00:04:16.661
But I wanted to point out one other 
thing. 

64
00:04:16.661 --> 00:04:22.711
Which is, when you're programming with a 
REPL you can often save yourself a little 

65
00:04:22.711 --> 00:04:28.086
bit of time by using the REPL to remind 
yourself some useful partial information 

66
00:04:28.086 --> 00:04:32.052
about how things work. 
Like what functions are defined. 

67
00:04:32.052 --> 00:04:35.011
what their types are what the order of 
arguments are. 

68
00:04:35.011 --> 00:04:39.376
And today I'm going to show this I'm not 
showing you anything new feature of the 

69
00:04:39.376 --> 00:04:43.680
REPL I'm just pointing out that you can 
use it for this purpose which you might 

70
00:04:43.680 --> 00:04:48.095
not have thought of and it's so useful to 
do that that some REPLs have gone to the 

71
00:04:48.095 --> 00:04:52.471
next step and they actually have added 
special commands that let you access the 

72
00:04:52.471 --> 00:04:57.902
full documentation. 
For libraries written in the language, 

73
00:04:57.902 --> 00:05:03.492
ML's REPL does not have that to my 
knowledge, so I just use it in sort of 

74
00:05:03.492 --> 00:05:07.812
the way REPL's can always do, I just use 
it to look things up. 

75
00:05:07.812 --> 00:05:13.562
So here's my REPL and I know that if I 
type, if I have a function defined like f 

76
00:05:13.562 --> 00:05:17.670
n = x + 1, if I just type F. 
I say, oh, that's a function, and it's 

77
00:05:17.670 --> 00:05:21.132
typed int arrow int. 
Well guess what? If I type List.map, it 

78
00:05:21.132 --> 00:05:24.015
nicely reminds me the type of List.map. 
Oh, look. 

79
00:05:24.015 --> 00:05:28.598
The 2 arguments are curried, not tupled. 
Maybe that's why I was getting an error 

80
00:05:28.598 --> 00:05:31.481
message, so this is just a convenient 
thing to do. 

81
00:05:31.481 --> 00:05:35.540
You can even guess, oh. 
List.last, was that, was that the name of 

82
00:05:35.540 --> 00:05:39.901
the function? Oh, yes, it was. 
Right? You can kind of guess at function 

83
00:05:39.901 --> 00:05:43.584
names if you want. 
if you think it's called fold left, it 

84
00:05:43.584 --> 00:05:47.435
turns out you're wrong. 
You get and unbound variable that's not 

85
00:05:47.435 --> 00:05:50.850
in the library. 
You're like, oh, is it called fold? No, 

86
00:05:50.850 --> 00:05:54.458
it turns out it's called fold L. 
Now at some point you should stop 

87
00:05:54.458 --> 00:05:57.963
guessing and messing around, and you 
should look up the documentation. 

88
00:05:57.963 --> 00:06:02.067
But you know, this is fairly convenient. 
It turns out with one other trick, I'm 

89
00:06:02.067 --> 00:06:05.753
not going to explain why this works, you 
can actually get the REPL to print out 

90
00:06:05.753 --> 00:06:09.357
all the bindings. 
for a particular structure and once we 

91
00:06:09.357 --> 00:06:13.392
know a little bit more about the module 
system this might make more sense. 

92
00:06:13.392 --> 00:06:17.622
So for example, if you knew there was a 
list structure, and you just wanted to 

93
00:06:17.622 --> 00:06:21.957
without going to your web browser look up 
everything, you can write the keyword 

94
00:06:21.957 --> 00:06:25.812
structure, this is all ML code it's just 
features I haven't shown you. 

95
00:06:25.812 --> 00:06:30.912
x = list And this is not very useful, it 
tells you that the signature, which is 

96
00:06:30.912 --> 00:06:34.362
kind of the type of a structure is listed 
all capitals. 

97
00:06:34.362 --> 00:06:38.892
And now if I say signature, spelled out 
English word, acts equals list. 

98
00:06:38.892 --> 00:06:43.677
So I'm putting here whatever was after 
the colon on the previous line and hit 

99
00:06:43.677 --> 00:06:46.849
return. 
While it prints out all that first part. 

100
00:06:46.849 --> 00:06:51.093
Now I can't go that next step, I don't 
get that actual documentation but you 

101
00:06:51.093 --> 00:06:54.679
might still find this useful. 
Anyway that's your brief guide to 

102
00:06:54.679 --> 00:06:59.257
programming against libraries and that 
should be everything you need to complete 

103
00:06:59.257 --> 00:06:59.766
Homework 3. 