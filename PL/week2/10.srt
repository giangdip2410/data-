WEBVTT

1
00:00:03.940 --> 00:00:06.210
Alright. In this segment,

2
00:00:06.210 --> 00:00:09.905
I want to show you how to define functions inside of other functions.

3
00:00:09.905 --> 00:00:15.060
When it's good style to do that and how to do it in a way that's good style.

4
00:00:15.060 --> 00:00:16.645
And the neat thing about this segment,

5
00:00:16.645 --> 00:00:18.480
what I find really exciting is I don't have to

6
00:00:18.480 --> 00:00:20.910
teach you any new language constructs to do this.

7
00:00:20.910 --> 00:00:22.770
All I have to do is point out to you that

8
00:00:22.770 --> 00:00:26.895
the let-expressions we've already learned about have everything that we need.

9
00:00:26.895 --> 00:00:31.245
And the key point is that the bindings in a let-expression

10
00:00:31.245 --> 00:00:33.510
are any bindings in the language and we've

11
00:00:33.510 --> 00:00:36.025
already learned that functions are just bindings.

12
00:00:36.025 --> 00:00:40.530
So anywhere we have a let-expression we could have some of

13
00:00:40.530 --> 00:00:46.230
those bindings b functions that then can only be used inside that let expression.

14
00:00:46.230 --> 00:00:48.570
There's a very natural idea and it's actually pretty

15
00:00:48.570 --> 00:00:51.625
surprising that more languages don't have something like this.

16
00:00:51.625 --> 00:00:57.235
So why don't I show you an example and why don't I start this example without using let.

17
00:00:57.235 --> 00:00:59.460
Just do this the old fashioned way of having

18
00:00:59.460 --> 00:01:03.615
a helper function not defined inside of the function that it's helping.

19
00:01:03.615 --> 00:01:08.190
So suppose that I define a little helper function count,

20
00:01:08.190 --> 00:01:11.610
all this is going to do is take two integers from int to and

21
00:01:11.610 --> 00:01:15.465
return a list of the integers between them.

22
00:01:15.465 --> 00:01:17.279
So I'm going to do this inclusive,

23
00:01:17.279 --> 00:01:18.595
so from equals to.

24
00:01:18.595 --> 00:01:23.320
How about the one element list holding to or equivalently holding from.

25
00:01:23.320 --> 00:01:26.900
Otherwise let's start with from and cons that on

26
00:01:26.900 --> 00:01:31.165
to the recursive call from plus one and to.

27
00:01:31.165 --> 00:01:35.189
So if you call this with arguments like three and six,

28
00:01:35.189 --> 00:01:38.660
you would end up with the list 3 4 5 6 something like that.

29
00:01:38.660 --> 00:01:41.910
Okay? But that's not the function I actually wanted.

30
00:01:41.910 --> 00:01:43.380
That was just a helper function.

31
00:01:43.380 --> 00:01:46.985
What I actually wanted was a function that counts up from one.

32
00:01:46.985 --> 00:01:52.260
So it just takes a single argument x of type int and while this is really

33
00:01:52.260 --> 00:01:58.095
easy now with our helper function just counts from one to x.

34
00:01:58.095 --> 00:01:59.460
So let's make sure that works,

35
00:01:59.460 --> 00:02:02.900
that I got that right.

36
00:02:02.900 --> 00:02:06.950
Okay looks like I've got two functions there count and

37
00:02:06.950 --> 00:02:10.580
count up from one and I got the right answer.

38
00:02:10.580 --> 00:02:12.220
All right. Now this is fine.

39
00:02:12.220 --> 00:02:14.285
This is good functional programming.

40
00:02:14.285 --> 00:02:19.140
Unless this count function should really be private to count up from one.

41
00:02:19.140 --> 00:02:21.410
I don't want the rest of the world to be bothered with

42
00:02:21.410 --> 00:02:24.295
it or to know how it's implemented or anything like that.

43
00:02:24.295 --> 00:02:26.740
Then I can use a let-expression for that.

44
00:02:26.740 --> 00:02:29.135
So I could just say let, in,

45
00:02:29.135 --> 00:02:33.380
end and then literally pick this up and

46
00:02:33.380 --> 00:02:37.970
say I only want this count function to be in scope,

47
00:02:37.970 --> 00:02:40.985
to be in the environment over here.

48
00:02:40.985 --> 00:02:45.750
So now count can be used recursively because that's how function bindings work.

49
00:02:45.750 --> 00:02:49.045
It could be used for any later bindings in this let expression.

50
00:02:49.045 --> 00:02:50.395
I don't happen to have any.

51
00:02:50.395 --> 00:02:51.835
And it can be used in the body.

52
00:02:51.835 --> 00:02:54.405
So this will also work just fine.

53
00:02:54.405 --> 00:03:00.950
And if I go over here to my REPL and restart and use the file again,

54
00:03:00.950 --> 00:03:04.250
you'll see that there is no count function at the top level.

55
00:03:04.250 --> 00:03:08.000
If I try to count it's just not there but it's still

56
00:03:08.000 --> 00:03:13.390
a perfectly fine helper function being used to implement count up from one.

57
00:03:13.390 --> 00:03:15.010
Okay. So that seems good.

58
00:03:15.010 --> 00:03:18.530
That seems like good style if we wanted count to be private.

59
00:03:18.530 --> 00:03:21.080
But now let me show you something even better,

60
00:03:21.080 --> 00:03:24.910
even more fascinating and quite natural once you get used to it.

61
00:03:24.910 --> 00:03:32.735
And that is to recognize that here where I defined count there's no reason to have a to.

62
00:03:32.735 --> 00:03:35.615
Let's look at how this to variable is used

63
00:03:35.615 --> 00:03:39.290
when we call count up from one with some value for x.

64
00:03:39.290 --> 00:03:42.410
Suppose we call it with seven like we just tried out.

65
00:03:42.410 --> 00:03:44.390
Well then x is going to be seven.

66
00:03:44.390 --> 00:03:47.530
So we're going to call count where to is seven.

67
00:03:47.530 --> 00:03:49.905
We'll say that one is not equal to seven

68
00:03:49.905 --> 00:03:52.310
and so on then we'll do a recursive call where we

69
00:03:52.310 --> 00:03:57.655
increment from but to is seven on the recursive call. Just like it was before.

70
00:03:57.655 --> 00:04:02.185
In fact every time we call count recursively to is going to be seven.

71
00:04:02.185 --> 00:04:07.190
And yet why should we have to pass that around when we already

72
00:04:07.190 --> 00:04:12.950
have a variable that's a perfectly good value that we need, namely x?

73
00:04:12.950 --> 00:04:16.490
What if I used x everywhere I was using to?

74
00:04:16.490 --> 00:04:19.070
That makes perfect sense because here in

75
00:04:19.070 --> 00:04:22.910
this let-expression and therefore in this function binding,

76
00:04:22.910 --> 00:04:27.040
x is in my environment it's a parameter out here so I can use it.

77
00:04:27.040 --> 00:04:31.950
Even this helper function can use x so this code will work just fine.

78
00:04:31.950 --> 00:04:34.295
But now we have some really strange style

79
00:04:34.295 --> 00:04:37.605
because I have this argument to that I'm never using.

80
00:04:37.605 --> 00:04:40.660
So let's get rid of it. Let's get rid of it here,

81
00:04:40.660 --> 00:04:44.379
let's get rid of it in our call and then sometimes people forget to do this,

82
00:04:44.379 --> 00:04:47.200
you better get rid of it in the recursive call too.

83
00:04:47.200 --> 00:04:51.110
So you don't have to write it in terms of to and then get rid of it once you get used to

84
00:04:51.110 --> 00:04:55.165
this style of programming and recognizing that you can use variables in the environment.

85
00:04:55.165 --> 00:04:58.820
We could have just written this version of count like this to begin with.

86
00:04:58.820 --> 00:05:01.280
Okay. Now let's make sure we got that right.

87
00:05:01.280 --> 00:05:03.130
That's the final version I wanted to show you.

88
00:05:03.130 --> 00:05:06.390
I've restarted reinclude my file.

89
00:05:06.390 --> 00:05:09.495
And let's try it out on seven, still works great.

90
00:05:09.495 --> 00:05:11.720
Notice count is still of course not in

91
00:05:11.720 --> 00:05:16.035
the environment outside of the function that defined it.

92
00:05:16.035 --> 00:05:18.580
So that's the code I wanted to show you.

93
00:05:18.580 --> 00:05:23.940
Now let's just go back to the slides and emphasize a couple of things about this.

94
00:05:23.940 --> 00:05:28.245
This is the version I showed you where we do have a local function,

95
00:05:28.245 --> 00:05:31.455
a nested function, definition count is inside of count from one.

96
00:05:31.455 --> 00:05:34.440
But I'm still using this unnecessary to parameter.

97
00:05:34.440 --> 00:05:38.425
Okay? So that's a good starting point to understand why this works and

98
00:05:38.425 --> 00:05:40.520
understand that this is good style if

99
00:05:40.520 --> 00:05:43.375
count is only going to be used by count up from one.

100
00:05:43.375 --> 00:05:45.770
But if you want count to be usable in larger parts of

101
00:05:45.770 --> 00:05:49.910
your program then you should put it somewhere where other code can use it.

102
00:05:49.910 --> 00:05:52.940
Then the second version I showed you was this fancy version,

103
00:05:52.940 --> 00:05:56.050
if you will, where count doesn't have a to parameter.

104
00:05:56.050 --> 00:05:59.360
For this to work it's going to have to be defined in some scope where you

105
00:05:59.360 --> 00:06:03.605
have the variable x so that you can use that in place of to.

106
00:06:03.605 --> 00:06:07.580
And I just can't emphasize enough that this is using all the rules we've already learned.

107
00:06:07.580 --> 00:06:11.540
We're just going to look x up in the environment where we defined

108
00:06:11.540 --> 00:06:16.890
this function count and it's there and it has the value we need, so we just use it.

109
00:06:16.890 --> 00:06:19.300
So when you can do this you really should.

110
00:06:19.300 --> 00:06:23.535
It's certainly poor style to pass extra parameters that you don't need.

111
00:06:23.535 --> 00:06:27.209
Why have a to argument when x will work just fine?

112
00:06:27.209 --> 00:06:29.375
All right? So taking a step back

113
00:06:29.375 --> 00:06:31.940
when should you use nested functions and when shouldn't you?

114
00:06:31.940 --> 00:06:36.125
Well nested functions are great style if you want to make sure

115
00:06:36.125 --> 00:06:41.670
that the function you're defining is only going to be used there in that let-expression.

116
00:06:41.670 --> 00:06:45.400
If it's not going to be useful elsewhere it just keeps your code cleaner to do that.

117
00:06:45.400 --> 00:06:47.720
If you're worried that other code might misuse it in

118
00:06:47.720 --> 00:06:50.780
some way like you need to call the function in a certain way

119
00:06:50.780 --> 00:06:53.030
for it to work correctly then limiting

120
00:06:53.030 --> 00:06:56.890
the scope of where it can be used makes it easier to check that.

121
00:06:56.890 --> 00:06:58.910
And in fact it makes it much easier to deal with

122
00:06:58.910 --> 00:07:02.258
any changes you might make to that function in the future.

123
00:07:02.258 --> 00:07:06.710
When you're maintaining your code you change a function you need to check all the uses of

124
00:07:06.710 --> 00:07:08.900
that function and if you restrict where

125
00:07:08.900 --> 00:07:12.645
the function can be used that process can be a lot easier.

126
00:07:12.645 --> 00:07:15.760
Now that said nested functions are not always the right thing.

127
00:07:15.760 --> 00:07:19.055
And so this is a real fundamental tradeoff when you're developing software.

128
00:07:19.055 --> 00:07:20.660
You want to put your functions in

129
00:07:20.660 --> 00:07:23.945
a narrow enough scope that you can restrict how they're used

130
00:07:23.945 --> 00:07:29.900
but a wide enough scope that they can be reused as much as is helpful in your program.

131
00:07:29.900 --> 00:07:32.840
But in any case we've now seen in ML now how to define

132
00:07:32.840 --> 00:07:38.000
nested functions and how to do them in a way that's quite convenient and good style.