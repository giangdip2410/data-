WEBVTT

1
00:00:00.000 --> 00:00:06.167
[SOUND] In this segment I want to talk 
about how its a really valuable thing 

2
00:00:06.167 --> 00:00:12.664
that an ML we don't have mutation for 
most forms of data the ones you create a 

3
00:00:12.664 --> 00:00:19.078
topple or a list or a variable there is 
no way to change the contents of that 

4
00:00:19.078 --> 00:00:21.547
data. 
So this is going to feel like a little 

5
00:00:21.547 --> 00:00:25.136
bit of a strange segment, but it's 
actually a big idea in the course, 

6
00:00:25.136 --> 00:00:27.668
because I'm not going to teach you 
anything new. 

7
00:00:27.668 --> 00:00:31.151
I've already shown you all the features 
you need for homework one. 

8
00:00:31.151 --> 00:00:34.950
Instead, we're going to focus on a 
non-feature; something that ML doesn't 

9
00:00:34.950 --> 00:00:37.219
have. 
So how can the lack of something in a 

10
00:00:37.219 --> 00:00:39.963
programming language be important for 
that language? 

11
00:00:39.963 --> 00:00:44.079
Naively, you might think, well you should 
always give programmers more and more 

12
00:00:44.079 --> 00:00:47.720
stuff they can use, and then they can 
decide whether to use it or not. 

13
00:00:47.720 --> 00:00:53.320
But when you have a lack of a feature in 
your language, that when you're writing 

14
00:00:53.320 --> 00:00:57.660
code, you know that no one using your 
code will use that thing. 

15
00:00:57.660 --> 00:00:59.186
Because it can't. 
Right. 

16
00:00:59.186 --> 00:01:03.284
And that will make it easier for you to 
write your code correctly and to 

17
00:01:03.284 --> 00:01:05.922
understand the results that your code 
produces. 

18
00:01:05.922 --> 00:01:10.413
So, in fact, one of the major things that 
makes functional programming functional 

19
00:01:10.413 --> 00:01:14.903
programming, is that when you create some 
data, like a pair or a list, there is no 

20
00:01:14.903 --> 00:01:17.878
way to subsequently change the contents 
of that data. 

21
00:01:17.878 --> 00:01:22.481
You have to make a new piece of data that 
has some different values in it, alright. 

22
00:01:22.481 --> 00:01:25.400
So let me show you why this can be a 
valuable thing. 

23
00:01:25.400 --> 00:01:28.465
Let's start with a somewhat simple 
example. 

24
00:01:28.465 --> 00:01:31.667
I'm showing you 
A function that does this before. 

25
00:01:31.667 --> 00:01:35.250
This is a sort pair function. 
So it takes an int star int, and it 

26
00:01:35.250 --> 00:01:38.889
returns an int star int. 
If you call it with three comma four, you 

27
00:01:38.889 --> 00:01:43.088
get back three comma four, but if you 
call it with four comma three, you get 

28
00:01:43.088 --> 00:01:47.175
back three comma four, because it always 
sorts the two things in the pair. 

29
00:01:47.175 --> 00:01:51.710
So here are two versions of the function. 
And in the first version, when the first 

30
00:01:51.710 --> 00:01:55.964
component of the pair is less than the 
second component of the pair, we just 

31
00:01:55.964 --> 00:01:59.100
return the pair, because that's already a 
correct answer. 

32
00:01:59.100 --> 00:02:03.362
Whereas in the second version of the 
code, we make essentially a copy of the 

33
00:02:03.362 --> 00:02:05.885
pair. 
We return a new pair that has the first 

34
00:02:05.885 --> 00:02:09.980
of pair in the first part and the second 
part of pair in the second part. 

35
00:02:09.980 --> 00:02:14.711
So suppose that you had, say the second 
version, and you wanted to maintain it, 

36
00:02:14.711 --> 00:02:19.196
edit your code, evolve your code to be 
the first version instead because that 

37
00:02:19.196 --> 00:02:21.900
seems simpler or more efficient or 
whatever. 

38
00:02:21.900 --> 00:02:26.957
Is it possible that some client, some 
user of your function would break because 

39
00:02:26.957 --> 00:02:30.734
of that change you made? 
And in ML the answer is no, the two 

40
00:02:30.734 --> 00:02:35.855
versions of these functions cannot be 
distinguished by any code in the language 

41
00:02:35.855 --> 00:02:40.144
that uses those functions. 
You can argue the first is better styled 

42
00:02:40.144 --> 00:02:44.690
but you can't argue that they make any 
difference to users of the code. 

43
00:02:44.690 --> 00:02:50.145
But if your language allows you to 
mutate, to update the contents of pairs, 

44
00:02:50.145 --> 00:02:54.972
this isn't the case. 
Suppose that we bound to x the pair 3 

45
00:02:54.972 --> 00:03:00.240
comma 4, and then we bound to y the 
result of sorting that pair. 

46
00:03:00.240 --> 00:03:04.876
Now, there's two possibilities. 
We, if we don't know how sort pair is 

47
00:03:04.876 --> 00:03:08.109
implemented. 
Maybe, as you see in this picture over on 

48
00:03:08.109 --> 00:03:10.915
the right. 
Y refers to that same pair that was 

49
00:03:10.915 --> 00:03:13.844
passed to x. 
So x and y are now what are usually 

50
00:03:13.844 --> 00:03:16.589
called aliases in most programming 
languages. 

51
00:03:16.589 --> 00:03:20.127
Or the second possibility is that x and y 
are not aliases. 

52
00:03:20.127 --> 00:03:23.055
That y points to some different pair, 3, 
4. 

53
00:03:23.055 --> 00:03:26.960
In ML, it doesn't matter. 
But if there were some way in ML to 

54
00:03:26.960 --> 00:03:32.383
mutate, say hash one of x to change it so 
instead of holding three, it holds five. 

55
00:03:32.383 --> 00:03:37.423
Now we have a very difficult question. 
Does that change from three to five 

56
00:03:37.423 --> 00:03:42.419
affect what y refers to, or doesn't it? 
It depends now whether x and y are 

57
00:03:42.419 --> 00:03:45.841
aliases. 
If you don't have mutation then you can't 

58
00:03:45.841 --> 00:03:51.042
tell if things are aliases or copies. 
This makes it easier to implement sort 

59
00:03:51.042 --> 00:03:54.122
pair. 
It makes it easier to use sort pair and 

60
00:03:54.122 --> 00:03:58.502
reason about the results. 
And it even, can even make it easier to 

61
00:03:58.502 --> 00:04:03.978
implement languages like ML efficiently. 
So let me show you a more interesting 

62
00:04:03.978 --> 00:04:07.272
example where I'm going to go from pairs 
now, to lists. 

63
00:04:07.272 --> 00:04:11.420
And let's use one of my favorite 
functions in the whole course, list 

64
00:04:11.420 --> 00:04:14.348
append. 
This was this elegant recursive function, 

65
00:04:14.348 --> 00:04:18.740
that takes two lists, x's and y's, and 
returns a new list, that is all the 

66
00:04:18.740 --> 00:04:21.668
contents of x's, appended to the contents 
of y's. 

67
00:04:21.668 --> 00:04:26.609
Alright, and now we might ask ourselves, 
if I have the list 2 comma 4, and the 

68
00:04:26.609 --> 00:04:31.497
list five through zero and I append them. 
What if any a listing do I have. 

69
00:04:31.497 --> 00:04:37.765
Do I have a situation like here in this 
top picture where x holds the list 2, 4, 

70
00:04:37.765 --> 00:04:45.227
y holds the list 5 3, 0, and z does hold 
the list 2, 4, 5, 3, 0, but part of that 

71
00:04:45.227 --> 00:04:50.749
list alias is y, or does this append 
function in fact make an entirely new 

72
00:04:50.749 --> 00:04:53.950
list for z? 
Well once again, clients can't tell so 

73
00:04:53.950 --> 00:04:59.087
you can implement a pendent in either way 
and it will behave the same way in your 

74
00:04:59.087 --> 00:05:04.223
program even though this bottom version 
takes up a little more space it turns out 

75
00:05:04.223 --> 00:05:06.980
the code up here implements the top 
picture. 

76
00:05:06.980 --> 00:05:10.227
Because when x's is empty, when just 
return y's. 

77
00:05:10.227 --> 00:05:14.855
We don't copy y's, we just return what 
would become an alias to y's. 

78
00:05:14.855 --> 00:05:20.037
So here we're actually saving space. 
And the languages where you can update 

79
00:05:20.037 --> 00:05:24.113
the elements in the list this is usually 
a really bad idea. 

80
00:05:24.113 --> 00:05:29.640
Because if someone comes along and does 
some notation on this list z, it can end 

81
00:05:29.640 --> 00:05:34.131
up affecting the list y. 
Which may very well not be what you want. 

82
00:05:34.131 --> 00:05:38.000
So once again. 
The lack of notation is what's helping us 

83
00:05:38.000 --> 00:05:41.410
not have to worry about all this. 
All right. 

84
00:05:41.410 --> 00:05:46.168
So, in M L, it turns out that we create 
aliases all of the time, and we don't 

85
00:05:46.168 --> 00:05:49.848
even think about it. 
And that's okay, because you can never 

86
00:05:49.848 --> 00:05:53.972
tell if two things are aliases, or two 
copies of identical values. 

87
00:05:53.972 --> 00:05:59.111
Are they pointing to the same pair three 
comma four, or two copies of three comma 

88
00:05:59.111 --> 00:06:02.030
four? 
And in fact, the tail operation for lists 

89
00:06:02.030 --> 00:06:06.217
is probably a great example. 
It's a very fast operation because it 

90
00:06:06.217 --> 00:06:11.230
just returns an alias to the tail of the 
list that was passed as it's argument. 

91
00:06:11.230 --> 00:06:15.751
Ml programs would be much less efficient 
if the tail function made a copy of the 

92
00:06:15.751 --> 00:06:19.659
entire list minus the first element. 
So when you're writing functional 

93
00:06:19.659 --> 00:06:24.014
programs, you don't worry about these 
aliases, you just focus on your algorithm 

94
00:06:24.014 --> 00:06:28.428
because you know there's no mutation. 
In languages that have mutable data, 

95
00:06:28.428 --> 00:06:33.583
which is pretty much every nonfunctional 
language, for example Java, programmers 

96
00:06:33.583 --> 00:06:37.041
are absolutely obsessed with the identity 
of objects. 

97
00:06:37.041 --> 00:06:40.108
Am I making a copy here? 
Am I creating an alias? 

98
00:06:40.108 --> 00:06:45.263
Are these two things reference equal or 
do they just answer true to the equals 

99
00:06:45.263 --> 00:06:48.061
method. 
And I'm not picking on them for being 

100
00:06:48.061 --> 00:06:50.587
obsessed. 
In fact, I think they have to be 

101
00:06:50.587 --> 00:06:55.270
obsessed, because any time you have 
aliases, the assignment statement affects 

102
00:06:55.270 --> 00:06:58.296
all of them. 
And if you don't have aliases it affects 

103
00:06:58.296 --> 00:07:02.313
only one of them and you have to 
understand this to understand how your 

104
00:07:02.313 --> 00:07:05.046
program behaves and whether your code is 
correct. 

105
00:07:05.046 --> 00:07:09.620
So in the next segment I'm actually going 
to show a rather tricky example of this 

106
00:07:09.620 --> 00:07:12.074
in Java. 
Since we don't require Java for the 

107
00:07:12.074 --> 00:07:16.480
course it will be totally optional but it 
will show you just how hard it is to 

108
00:07:16.480 --> 00:07:19.102
reason about aliases and assignment 
statements. 

109
00:07:19.102 --> 00:07:23.676
And in ML the way we avoid having to do 
that is we just get rid of the assignment 

110
00:07:23.676 --> 00:07:24.290
statements. 