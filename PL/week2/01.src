WEBVTT

1
00:00:00.000 --> 00:00:04.940
[MUSIC] 

2
00:00:04.940 --> 00:00:07.301
Alright. 
In this segment, we're going to take the 

3
00:00:07.301 --> 00:00:11.184
same program we had in our previous 
segment and we're going to look at those 

4
00:00:11.184 --> 00:00:15.381
different kinds of expressions we saw 
more carefully and make sure we give them 

5
00:00:15.381 --> 00:00:18.215
a precise semantics so we know exactly 
what they mean. 

6
00:00:18.215 --> 00:00:22.098
So we're going to take the same program 
we had before, you see it here on the 

7
00:00:22.098 --> 00:00:26.033
Powerpoint slide, and we're going to 
really focus in on those expressions that 

8
00:00:26.033 --> 00:00:28.500
we had for each of the variables that we 
bound. 

9
00:00:28.500 --> 00:00:32.753
We're not doing this because I think you 
don't understand addition or what an 

10
00:00:32.753 --> 00:00:35.426
integer is or how a conditional 
expression works. 

11
00:00:35.426 --> 00:00:39.080
But because by giving the semantics to 
these things very carefully, 

12
00:00:39.080 --> 00:00:43.497
we'll be able to build on top of that and 
use the exact same ideas when we learn 

13
00:00:43.497 --> 00:00:47.749
more sophisticated and interesting 
language constructs in the near future. 

14
00:00:47.749 --> 00:00:52.111
So if we look at this program we see a 
bunch of different kinds of expressions 

15
00:00:52.111 --> 00:00:56.695
either explicitly in the program like 34 
or a variable x or an addition as well as 

16
00:00:56.695 --> 00:01:01.057
a couple of things that we don't see in 
the program but would be the result of 

17
00:01:01.057 --> 00:01:05.420
evaluating some of those expressions like 
the bullion constants true and false. 

18
00:01:05.420 --> 00:01:10.295
So, in fact, I thought I would show those 
to you quickly and here's my program. 

19
00:01:10.295 --> 00:01:13.221
and I can go ahead and open the REPL 
here. 

20
00:01:13.221 --> 00:01:17.304
There really is a constant true. 
just like there's a constant 42. 

21
00:01:17.304 --> 00:01:21.875
And that's the result of things like 
conditional expressions so three less 

22
00:01:21.875 --> 00:01:26.812
than zero evaluates to the Boolean false. 
And if I include those variables that I 

23
00:01:26.812 --> 00:01:29.249
bound, 
then I can use those in less than 

24
00:01:29.249 --> 00:01:32.480
expressions as well. 
And I can ask is x less than y? 

25
00:01:32.480 --> 00:01:38.320
Turns out it's false, but if I ask is Y 
less than X, that evaluates to true. 

26
00:01:38.320 --> 00:01:42.782
So, we have these kinds of expressions as 
you might expect but we also have this 

27
00:01:42.782 --> 00:01:46.241
neat property that we can build 
expressions as big as we want. 

28
00:01:46.241 --> 00:01:50.592
So certain expressions like addition, 
less than and conditionals are built out 

29
00:01:50.592 --> 00:01:54.218
of smaller sub-expressions and that can 
nest as deep as you want. 

30
00:01:54.218 --> 00:01:57.286
So you can have an addition inside of 
another addition. 

31
00:01:57.286 --> 00:02:00.020
You can have a conditional inside of an 
addition. 

32
00:02:00.020 --> 00:02:04.203
You can have an addition inside of 
conditionals and that can go as deep as 

33
00:02:04.203 --> 00:02:06.770
you want, making expressions as big as we 
want. 

34
00:02:06.770 --> 00:02:11.783
So when we go to define the syntax and 
semantics of expressions, that definition 

35
00:02:11.783 --> 00:02:16.483
is going to have to be recursive because 
we're going to have to define it in terms 

36
00:02:16.483 --> 00:02:20.135
of those sub expressions. 
So there's a, a really important 

37
00:02:20.135 --> 00:02:25.218
methodology to what we're going to do 
right now and that is for every kind of 

38
00:02:25.218 --> 00:02:28.672
expression to ask ourselves the same 
three questions. 

39
00:02:28.672 --> 00:02:31.800
What is the syntax, i.e. 
how do you write it down? 

40
00:02:31.800 --> 00:02:35.618
What are the typing checking rules. 
In other words, what type does an 

41
00:02:35.618 --> 00:02:40.224
expression have, and what can cause it to 
fail to type check in which case you get 

42
00:02:40.224 --> 00:02:43.368
an error message. 
And then the third question is whether 

43
00:02:43.368 --> 00:02:46.794
the evaluation rules. 
Assuming it does type check, how does it 

44
00:02:46.794 --> 00:02:49.771
perform its computation in order to 
produce a result. 

45
00:02:49.771 --> 00:02:52.242
And we're going to call that result a 
value. 

46
00:02:52.242 --> 00:02:56.285
Of course, expressions might not produce 
a result that can also raise an 

47
00:02:56.285 --> 00:02:59.150
exceptionate run time or go into an 
infinite loop. 

48
00:03:00.340 --> 00:03:05.503
Okay, so let's start with the simplest 
kind of expression I can think of, which 

49
00:03:05.503 --> 00:03:08.422
is a variable. 
So we're going to ask three questions. 

50
00:03:08.422 --> 00:03:11.253
What is the syntax? 
The answer is it's any sequence of 

51
00:03:11.253 --> 00:03:15.551
letters or digits or underscores, except 
the first thing in that sequence can't be 

52
00:03:15.551 --> 00:03:18.120
a digit. 
The rules for variables in ML are pretty 

53
00:03:18.120 --> 00:03:21.004
similar to what they are in many 
programming languages. 

54
00:03:21.004 --> 00:03:23.940
The second question is, what are the type 
checking rules? 

55
00:03:23.940 --> 00:03:28.430
This is when we're using a variable, not 
when we are defining it with a variable 

56
00:03:28.430 --> 00:03:32.471
binding, but when we're using it as an 
expression, or as part of a larger 

57
00:03:32.471 --> 00:03:35.333
expression. 
So the answer is, the way you type check 

58
00:03:35.333 --> 00:03:38.420
a variable is you look it up in the 
static environment. 

59
00:03:38.420 --> 00:03:42.798
If you find it, whatever type it has in 
the static environment, that's the type 

60
00:03:42.798 --> 00:03:45.885
of the expression. 
If you don't find it, it doesn't type 

61
00:03:45.885 --> 00:03:49.950
check, and you get an error message. 
And then the third question was the 

62
00:03:49.950 --> 00:03:53.218
evaluation rules. 
Here it's similar to the type checking 

63
00:03:53.218 --> 00:03:57.770
rules, except we looked the variable up 
in the dynamic environment and we used 

64
00:03:57.770 --> 00:04:01.913
whatever value we find there. 
We don't have to worry about it not being 

65
00:04:01.913 --> 00:04:06.757
there, because in ML we only run programs 
that type check, so we know that variable 

66
00:04:06.757 --> 00:04:09.298
will be in the dynamic environment. 
Alright. 

67
00:04:09.298 --> 00:04:12.661
So, that's variables. 
Like I said, they're pretty simple. 

68
00:04:12.661 --> 00:04:16.835
Maybe even a little too simple. 
So let's next do addition expressions. 

69
00:04:16.835 --> 00:04:22.004
And these are our first example where the 
expression has sub expressions inside of 

70
00:04:22.004 --> 00:04:24.620
it. 
So the answers to all of our questions 

71
00:04:24.620 --> 00:04:29.728
are going to have to rely on the answers 
to the questions for the sub expressions. 

72
00:04:29.728 --> 00:04:33.029
So first, what's the syntax of an 
addition expression? 

73
00:04:33.029 --> 00:04:37.950
It's any expression where you have two 
other expressions with a plus symbol in 

74
00:04:37.950 --> 00:04:40.652
between them. 
That means you have an addition 

75
00:04:40.652 --> 00:04:43.374
expression. 
Okay, so what are the type checking 

76
00:04:43.374 --> 00:04:46.213
rules? 
But what you have to do given an addition 

77
00:04:46.213 --> 00:04:50.768
expression is you have to type check both 
of those sub-expressions E1 and E2. 

78
00:04:50.768 --> 00:04:55.086
And if they both have type int, then the 
addition expression has type int. 

79
00:04:55.086 --> 00:04:59.582
If either of them does not type check, or 
has a type other than int, then the 

80
00:04:59.582 --> 00:05:03.545
entire thing does not type check. 
See how the answer for the larger 

81
00:05:03.545 --> 00:05:07.450
expression is built out of the answer for 
the smaller expressions. 

82
00:05:07.450 --> 00:05:11.557
And similarly for our evaluation rules, 
we're going to take those two 

83
00:05:11.557 --> 00:05:16.691
subexpressions e1 and e2, evaluate them 
to values, let's call them v1 and v2 

84
00:05:16.691 --> 00:05:21.961
whatever they might be and then our 
overall result will be the sum of v1 and 

85
00:05:21.961 --> 00:05:27.438
v2 and again thanks to type checking I 
know v1 and v2 will be ints so I know 

86
00:05:27.438 --> 00:05:30.450
that it will always be possible to sum 
them. 

87
00:05:30.450 --> 00:05:34.302
Alright so that's addition, we all knew 
how addition worked. 

88
00:05:34.302 --> 00:05:39.396
Now, before I get to the more interesting 
one, which is conditional expressions, 

89
00:05:39.396 --> 00:05:42.596
let me talk a little bit more about these 
values. 

90
00:05:42.596 --> 00:05:46.383
So remember the result of evaluating 
something is a value. 

91
00:05:46.383 --> 00:05:51.608
So it turns out that every value is an 
expression but not every expression is a 

92
00:05:51.608 --> 00:05:54.560
value. 
So what we have are these certain kinds 

93
00:05:54.560 --> 00:05:59.298
of expressions, the values that are 
always going to evaluate to themselves. 

94
00:05:59.298 --> 00:06:02.178
So 42 evaluates to 42, true evaluates to 
true. 

95
00:06:02.178 --> 00:06:07.044
There's actually even one the result of 
that use command, we use in the REPL 

96
00:06:07.044 --> 00:06:11.781
produces this value left parenthesis 
right parenthesis that has type unit. 

97
00:06:11.781 --> 00:06:16.710
So, for each of these types there's a 
certain set of values and those are the 

98
00:06:16.710 --> 00:06:20.680
answers that we get when we have some 
expression of that type. 

99
00:06:20.680 --> 00:06:25.071
So, we know how 34 works. 
Its syntax is a sequence of digits. 

100
00:06:25.071 --> 00:06:30.950
Its typing rule is that it has type int. 
And its evaluation rule is that it's a 

101
00:06:30.950 --> 00:06:35.341
value and like all values it produces 
itself as its answer. 

102
00:06:35.341 --> 00:06:37.500
Okay, 
so those are the values. 

103
00:06:37.500 --> 00:06:42.185
Now let's do a more sophisticated one, 
which are the conditional expressions. 

104
00:06:42.185 --> 00:06:46.871
And I thought it would be more 
interesting to write this out rather than 

105
00:06:46.871 --> 00:06:51.618
just already have it up on the slide. 
And since my typing is much better than 

106
00:06:51.618 --> 00:06:56.304
my handwriting, I thought I would just 
open a text file in emacs and write it 

107
00:06:56.304 --> 00:06:58.647
there. 
So the syntax for a conditional 

108
00:06:58.647 --> 00:07:05.308
expression is if e1 then e2 else e3 where 
if then and else are keywords. 

109
00:07:05.308 --> 00:07:10.644
They're the actual syntax that explains 
what this is what construct this is. 

110
00:07:10.644 --> 00:07:15.845
And e1, e2, and e3 are sub expressions. 
So the same way an addition has two sub 

111
00:07:15.845 --> 00:07:19.358
expressions. 
A conditional has three sub expressions. 

112
00:07:19.358 --> 00:07:24.019
Now, the type checking is more 
interesting, and is different than with 

113
00:07:24.019 --> 00:07:28.004
addition expressions. 
so first e1 must have type bool. 

114
00:07:28.004 --> 00:07:33.138
It must be true or false, or a variable 
of type bool or a comparison or some 

115
00:07:33.138 --> 00:07:41.978
expression of type bool. 
e2 and e3 can have any type, let's call 

116
00:07:41.978 --> 00:07:48.658
it t but they must have the same type, t. 
So you can't have a then branch of one 

117
00:07:48.658 --> 00:07:54.575
type and an else branch of another type, 
because the result of our entire 

118
00:07:54.575 --> 00:08:00.330
expression might be either of them. 
And what we need is, the type of the 

119
00:08:00.330 --> 00:08:06.729
entire expression is also t. 
And last we have to evaluation rules. 

120
00:08:06.729 --> 00:08:11.942
And here we first evaluate e1 to a value, 
call it v1. 

121
00:08:11.942 --> 00:08:19.161
Since it type checked with typo, I 
actually know that v1 will be true or 

122
00:08:19.161 --> 00:08:23.873
false. 
If it's true evaluate e2 and that result 

123
00:08:23.873 --> 00:08:30.814
is the whole expressions result else 
evaluate e3 and that result is the whole 

124
00:08:30.814 --> 00:08:35.750
expressions result. 
And that is everything there is to know 

125
00:08:35.750 --> 00:08:42.360
about the syntax tight checking rules and 
evaluation rules of an if expression. 

126
00:08:44.160 --> 00:08:48.507
So to finish up lets have you do one. 
Which is to figure out what it is for 

127
00:08:48.507 --> 00:08:51.811
less than comparisons. 
Try to work through it on your own. 

128
00:08:51.811 --> 00:08:56.216
Just on a blank piece of paper. 
If you get stuck it's also in the reading 

129
00:08:56.216 --> 00:09:00.737
notes associated with the lecture and 
then we can add some questions about it 

130
00:09:00.737 --> 00:09:03.578
as well. 
So remember for all of these the details 

131
00:09:03.578 --> 00:09:07.635
are less important than the fact that we 
always ask the same question. 

132
00:09:07.635 --> 00:09:11.519
How do I write it down the syntax. 
What are the type checking rules. 

133
00:09:11.519 --> 00:09:13.780
And then what are the evaluation rules. 