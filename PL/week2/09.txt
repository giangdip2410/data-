WEBVTT

1
00:00:04.330 --> 00:00:07.910
Okay. In this segment I want to start talking about

2
00:00:07.910 --> 00:00:10.400
the last big language feature we need

3
00:00:10.400 --> 00:00:13.615
before we sort of understand the basics of ML programming.

4
00:00:13.615 --> 00:00:14.990
And that's the ability to introduce

5
00:00:14.990 --> 00:00:18.025
local variables which we're going to do with let-expressions.

6
00:00:18.025 --> 00:00:19.310
But before we get to that,

7
00:00:19.310 --> 00:00:22.615
let's just review kind of where we are and how far we've come.

8
00:00:22.615 --> 00:00:26.024
We've seen a bunch of different types of data, ints and bools.

9
00:00:26.024 --> 00:00:29.051
We've seen tuples built out of smaller things, lists.

10
00:00:29.051 --> 00:00:32.085
We've seen functions that take arguments and return a result.

11
00:00:32.085 --> 00:00:33.710
We understand how environments work,

12
00:00:33.710 --> 00:00:36.459
at least that top level and with function bindings.

13
00:00:36.459 --> 00:00:39.839
And for each of functions and tuples and lists,

14
00:00:39.839 --> 00:00:42.619
we know how to build them using some language constructs.

15
00:00:42.619 --> 00:00:43.955
We know how to use them,

16
00:00:43.955 --> 00:00:48.880
either to call a function or to access the pieces of either a tuple or a list.

17
00:00:48.880 --> 00:00:53.807
So what we don't know how to do yet is how to define local variables,

18
00:00:53.807 --> 00:00:58.159
to put variables inside of a function that can only be used in that function.

19
00:00:58.159 --> 00:01:01.235
And that can be very good style and extremely convenient.

20
00:01:01.235 --> 00:01:04.450
And in this segment, we're going to go over the basics of how to do that.

21
00:01:04.450 --> 00:01:05.885
And then in the next segment,

22
00:01:05.885 --> 00:01:08.360
we're going to show that you can use the exact same language

23
00:01:08.360 --> 00:01:11.150
construct to put one function inside of another,

24
00:01:11.150 --> 00:01:16.455
which is a great idea that unfortunately you see in far too few programming languages.

25
00:01:16.455 --> 00:01:17.675
Then the segment after that,

26
00:01:17.675 --> 00:01:20.870
we'll discuss efficiency and learn that there are situations where

27
00:01:20.870 --> 00:01:24.185
you really need local variables and let bindings,

28
00:01:24.185 --> 00:01:26.550
in order to write a reasonable algorithm.

29
00:01:26.550 --> 00:01:27.710
But through all of this,

30
00:01:27.710 --> 00:01:30.680
the thing I'm going to emphasise is that all we're going to add

31
00:01:30.680 --> 00:01:34.075
to our language is a single new kind of expression.

32
00:01:34.075 --> 00:01:35.509
It's just an expression.

33
00:01:35.509 --> 00:01:38.210
We don't have to add anything else to our language and it's going to

34
00:01:38.210 --> 00:01:43.110
capture all the ideas we need for all of these purposes.

35
00:01:43.110 --> 00:01:44.495
So without further ado,

36
00:01:44.495 --> 00:01:45.694
let me show you the expression.

37
00:01:45.694 --> 00:01:49.455
I'll give you the formal definition first and then we'll write some code.

38
00:01:49.455 --> 00:01:52.010
Just some silly examples showing how to use it.

39
00:01:52.010 --> 00:01:58.710
So the syntax of a let expression involves three keywords: let, in and end.

40
00:01:58.710 --> 00:02:00.814
And between the let and the in,

41
00:02:00.814 --> 00:02:03.080
you can put any number of bindings.

42
00:02:03.080 --> 00:02:05.377
So these aren't expressions, they're actually bindings.

43
00:02:05.377 --> 00:02:07.920
Just like we've been putting at the top level of our program,

44
00:02:07.920 --> 00:02:10.950
we're now going to be able to put those in any let expression.

45
00:02:10.950 --> 00:02:12.965
And since they're an expression that means we,

46
00:02:12.965 --> 00:02:14.645
let expressions are expressions.

47
00:02:14.645 --> 00:02:18.530
That means we have a way to put bindings pretty much anywhere in our program.

48
00:02:18.530 --> 00:02:20.074
And then between in and end,

49
00:02:20.074 --> 00:02:24.719
we have one more expression which I'll call the body of the let expression.

50
00:02:24.719 --> 00:02:26.664
Let me talk about the evaluation rules next then,

51
00:02:26.664 --> 00:02:28.270
we'll come back to type checking.

52
00:02:28.270 --> 00:02:31.279
The idea is that we're just going to evaluate each binding in order,

53
00:02:31.279 --> 00:02:34.815
just like we would if those bindings were at the top level of the program.

54
00:02:34.815 --> 00:02:38.405
So each binding will be usable in the bindings that follow it,

55
00:02:38.405 --> 00:02:40.395
but not the earlier ones.

56
00:02:40.395 --> 00:02:43.520
And then, they are all usable in the body.

57
00:02:43.520 --> 00:02:45.395
So we evaluate each binding in order,

58
00:02:45.395 --> 00:02:47.720
then the body e. And the result of

59
00:02:47.720 --> 00:02:51.815
that body e will be the result of the entire let-expression.

60
00:02:51.815 --> 00:02:58.155
And those bindings will have no effect on any environment except in this let-expression.

61
00:02:58.155 --> 00:02:59.810
So given those evaluation rules,

62
00:02:59.810 --> 00:03:01.955
type checking works pretty much the same way.

63
00:03:01.955 --> 00:03:04.490
We're going to type check each binding in order,

64
00:03:04.490 --> 00:03:08.525
use that new static environment for type checking the other bindings.

65
00:03:08.525 --> 00:03:12.395
We'll allow all those bindings to be used in type checking the body,

66
00:03:12.395 --> 00:03:18.070
and then the type of the body e will be the type of the entire let-expression.

67
00:03:18.070 --> 00:03:20.550
Okay. So that's really all there is to it.

68
00:03:20.550 --> 00:03:24.045
How about we write some code to sort of make this concrete and understand it.

69
00:03:24.045 --> 00:03:26.390
I don't claim that this code is going to do anything.

70
00:03:26.390 --> 00:03:30.680
So how about I just call it silly_one since I'll write a couple of functions here.

71
00:03:30.680 --> 00:03:33.040
Just write a little function that takes an int.

72
00:03:33.040 --> 00:03:35.240
And here as we know, this function body can be any

73
00:03:35.240 --> 00:03:38.785
expression e. How about I make it a let expression?

74
00:03:38.785 --> 00:03:41.000
Okay. So it's going to have this form: let, in, end.

75
00:03:41.000 --> 00:03:43.036
And I'm going to have some bindings here.

76
00:03:43.036 --> 00:03:46.959
How about 'val x equals if z greater than zero'?

77
00:03:46.959 --> 00:03:50.240
So when I go to evaluate this expression here, type check it,

78
00:03:50.240 --> 00:03:53.765
I can use all the bindings that are already in the environment here.

79
00:03:53.765 --> 00:03:58.340
So z or anything that came earlier in the file would be fine.

80
00:03:58.340 --> 00:04:01.690
And then when I do another binding, say val y,

81
00:04:01.690 --> 00:04:06.629
I can use x. I can use z. I can use whatever expression I want.

82
00:04:06.629 --> 00:04:11.960
And so that seems like a perfectly reasonable expression for binding to y.

83
00:04:11.960 --> 00:04:13.634
So when we evaluate this,

84
00:04:13.634 --> 00:04:18.229
we'll evaluate x to the result of if z greater than zero then x else 34'.

85
00:04:18.229 --> 00:04:19.865
Then we'll evaluate y to be,

86
00:04:19.865 --> 00:04:21.240
x plus z plus nine.

87
00:04:21.240 --> 00:04:23.990
And then our body can use x and y and z and

88
00:04:23.990 --> 00:04:27.519
everything else so it could just be something like this.

89
00:04:27.519 --> 00:04:29.360
And now the type of this whole thing.

90
00:04:29.360 --> 00:04:33.005
So we want to end up having type 'int arrow int' because

91
00:04:33.005 --> 00:04:38.525
its body has type int and that's because the body of the let-expression has type int.

92
00:04:38.525 --> 00:04:41.225
And that's because the body is an if expression,

93
00:04:41.225 --> 00:04:45.065
and both the Then branch and the Else branch have type int.

94
00:04:45.065 --> 00:04:47.000
All right, so that's an example of a let-expression.

95
00:04:47.000 --> 00:04:48.770
Let's do one more.

96
00:04:48.770 --> 00:04:53.585
So let's again have our function body be a let-expression.

97
00:04:53.585 --> 00:04:59.325
But now let's really emphasise that we can put let-expressions anywhere.

98
00:04:59.325 --> 00:05:01.569
So what if this body were an addition expression?

99
00:05:01.569 --> 00:05:02.960
So we know addition is going to take

100
00:05:02.960 --> 00:05:06.955
two arguments and these could be let-expressions if we want.

101
00:05:06.955 --> 00:05:10.290
You can put a let-expression anywhere you can put an expression.

102
00:05:10.290 --> 00:05:11.751
So what if I did something like,

103
00:05:11.751 --> 00:05:17.756
val x equal two in x plus one end?

104
00:05:17.756 --> 00:05:19.835
How is that going to work?

105
00:05:19.835 --> 00:05:23.175
Well, I'm going to be in an environment where x is bound to one.

106
00:05:23.175 --> 00:05:24.910
But then when I evaluate this,

107
00:05:24.910 --> 00:05:30.580
I'll create an inner environment where this x shadows the outer x.

108
00:05:30.580 --> 00:05:34.555
So x will be two when I go to evaluate this body.

109
00:05:34.555 --> 00:05:39.455
So, x plus one' will be three and this entire let-expression will evaluate to three.

110
00:05:39.455 --> 00:05:43.015
The outer x will simply be irrelevant because I shadowed it.

111
00:05:43.015 --> 00:05:45.789
What if I had a different let-expression over here,

112
00:05:45.789 --> 00:05:48.725
where I had x plus two in y plus one?

113
00:05:48.725 --> 00:05:50.740
Well, now, there's no shadowing.

114
00:05:50.740 --> 00:05:55.435
So this x, in this x plus two is going to refer to this outer one.

115
00:05:55.435 --> 00:05:57.099
So I'll get three here,

116
00:05:57.099 --> 00:05:58.945
y will be bound to three.

117
00:05:58.945 --> 00:06:00.310
And so this body will be four.

118
00:06:00.310 --> 00:06:03.550
Notice that the let-expression over here only

119
00:06:03.550 --> 00:06:07.359
affects the bindings and expression in that let expression.

120
00:06:07.359 --> 00:06:09.395
That x is completely irrelevant.

121
00:06:09.395 --> 00:06:10.600
Over here on the right,

122
00:06:10.600 --> 00:06:13.840
where I have a different let-expression and the x refers to

123
00:06:13.840 --> 00:06:17.689
whichever one is in the environment when I go to evaluate this let-expression,

124
00:06:17.689 --> 00:06:19.565
so x will be one there.

125
00:06:19.565 --> 00:06:22.470
All right. So we can try this out real quickly.

126
00:06:22.470 --> 00:06:25.590
Let's try "let_expressions_dot_sml.

127
00:06:25.590 --> 00:06:28.105
And if I want to run,

128
00:06:28.105 --> 00:06:31.150
call silly_two, just pass it zero arguments,

129
00:06:31.150 --> 00:06:32.910
pass it a unit value there.

130
00:06:32.910 --> 00:06:35.830
And I get seven which is what I expected. All right.

131
00:06:35.830 --> 00:06:38.185
So that's let-expressions. As you can see,

132
00:06:38.185 --> 00:06:39.515
I'm really emphasizing that they're

133
00:06:39.515 --> 00:06:43.915
just expressions but they do introduce a really new thing for us

134
00:06:43.915 --> 00:06:50.484
and that is this idea of scope - of when is a binding in a particular environment,

135
00:06:50.484 --> 00:06:52.900
where in the program can we use that binding?

136
00:06:52.900 --> 00:06:55.880
When we only had top level bindings,

137
00:06:55.880 --> 00:06:58.480
we said that a binding was in the environment

138
00:06:58.480 --> 00:07:01.565
for the rest of the file unless it was shadowed.

139
00:07:01.565 --> 00:07:03.700
But now with these let-expressions,

140
00:07:03.700 --> 00:07:05.500
when we have bindings there,

141
00:07:05.500 --> 00:07:08.860
they're in scope for the later bindings and

142
00:07:08.860 --> 00:07:12.725
the body of that let expression and nowhere else.

143
00:07:12.725 --> 00:07:17.205
So it really does give us a powerful idea of local variables.

144
00:07:17.205 --> 00:07:19.300
But anywhere we have an expression,

145
00:07:19.300 --> 00:07:21.610
we can introduce a local scope with

146
00:07:21.610 --> 00:07:25.460
a let-expression to introduce bindings for just there.

147
00:07:25.460 --> 00:07:29.440
And other than that, we haven't added anything new to our language.

148
00:07:29.440 --> 00:07:32.200
We're reusing the whole idea of bindings and

149
00:07:32.200 --> 00:07:35.515
type checking and evaluation rules like we did at top level.

150
00:07:35.515 --> 00:07:38.005
We just are now doing it in a local way,

151
00:07:38.005 --> 00:07:42.440
where it only affects that let-expression and nothing outside of it.

152
00:07:42.440 --> 00:07:46.570
So that's your basic introduction of let-expressions and now we're going to use it,

153
00:07:46.570 --> 00:07:51.000
the idea, in the next couple of segments to do some additional important things.