WEBVTT

1
00:00:00.000 --> 00:00:04.940
[SOUND] 

2
00:00:04.940 --> 00:00:07.340
Okay. 
In this segment, we're going to start 

3
00:00:07.340 --> 00:00:10.141
studying functions, these are new kind of 
binding. 

4
00:00:10.141 --> 00:00:14.772
So we're going to change our program. 
definition of program will not just be a 

5
00:00:14.772 --> 00:00:18.659
sequence of variable bindings but who are 
both variables and functions. 

6
00:00:18.659 --> 00:00:22.831
If you haven't heard of the term 
function, it's a lot like a method in an 

7
00:00:22.831 --> 00:00:26.490
object-oriented language. 
This is something that's going to take 

8
00:00:26.490 --> 00:00:29.520
arguments, compute some result, and 
return that result. 

9
00:00:29.520 --> 00:00:33.228
That's all it does so it's in many ways 
simpler than a method. 

10
00:00:33.228 --> 00:00:36.279
And we're always going to call these 
things functions. 

11
00:00:36.279 --> 00:00:40.766
So why don't I just flip over to Emacs 
here and show you a first example. 

12
00:00:40.766 --> 00:00:45.492
How about I'll write a little function 
for exponentiation or raising something 

13
00:00:45.492 --> 00:00:49.740
to the power of something else. 
So, here is most of what I need to write. 

14
00:00:49.740 --> 00:00:52.059
Okay, 
so I have the keyword fun. 

15
00:00:52.059 --> 00:00:56.923
The name of the function I'm defining, 
pow. The arguments it takes. 

16
00:00:56.923 --> 00:01:02.535
Here X and Y separated by commas. 
I've written their types with a colon and 

17
00:01:02.535 --> 00:01:05.079
then the type name. 
Then an equals. 

18
00:01:05.079 --> 00:01:07.548
And then I have my function body. 
Okay, 

19
00:01:07.548 --> 00:01:12.439
so that body can just be any expression I 
want and what happens when you call the 

20
00:01:12.439 --> 00:01:15.123
function? 
It is, we are going to evaluate that 

21
00:01:15.123 --> 00:01:19.060
expression and then the result will be 
the result of the function. 

22
00:01:19.060 --> 00:01:25.180
So for exponentiation what I want is 
something like a conditional expression 

23
00:01:25.180 --> 00:01:29.770
that says if y is zero, than one. 
Otherwise how about x times? 

24
00:01:29.770 --> 00:01:35.486
this other expression which is to call 
the pow function with x and y minus one 

25
00:01:35.486 --> 00:01:41.271
and that will work as long as y is 
greater than or equal to zero and I'll 

26
00:01:41.271 --> 00:01:46.500
make no attempt to be correct for 
negative y since this is just an example. 

27
00:01:46.500 --> 00:01:50.533
So, this is a program. 
this can be included in my sequence of 

28
00:01:50.533 --> 00:01:53.287
bindings. 
I could have a val binding before. 

29
00:01:53.287 --> 00:01:57.001
maybe afterwards, I could have another 
function binding. 

30
00:01:57.001 --> 00:02:00.586
How about something that takes its 
argument and cubes it? 

31
00:02:00.586 --> 00:02:06.157
So I could define this as x * x * x or I 
could use any previous bindings, since 

32
00:02:06.157 --> 00:02:10.960
it'll be in my environment and I could 
instead, implement this as pow x3. 

33
00:02:10.960 --> 00:02:16.654
So the body of this cube function is 
itself a function call that calls pow 

34
00:02:16.654 --> 00:02:21.210
with x which is the argument to cube, and 
the constant three, 

35
00:02:21.210 --> 00:02:23.824
alright? 
So, I could use these functions. 

36
00:02:23.824 --> 00:02:27.712
I could say val 64. 
That should just equal cube of four. 

37
00:02:27.712 --> 00:02:33.075
You don't actually need these parentheses 
but it looks a little more like other 

38
00:02:33.075 --> 00:02:38.840
languages if I put them in, at least, for 
now or I could have something that uses 

39
00:02:38.840 --> 00:02:43.533
you know more nested expressions like, 
you can call a function with an 

40
00:02:43.533 --> 00:02:47.018
expression. 
In which case, I'll evaluate this 2 + 2 

41
00:02:47.018 --> 00:02:50.840
to 4 and then pass four as the second 
argument to pow. 

42
00:02:50.840 --> 00:02:57.580
here I could add another sixteen, and 
another eight, and another two. 

43
00:02:57.580 --> 00:03:02.555
You could even have nested calls if you 
wanted, so you could say, pal 2 comma 2 

44
00:03:02.555 --> 00:03:06.659
in there and so on. 
Alright, when you want to test something 

45
00:03:06.659 --> 00:03:09.983
out, just like always, go over here to 
the repple. 

46
00:03:09.983 --> 00:03:14.415
You can say, use functions.SML. 
See all of our bindings there. 

47
00:03:14.415 --> 00:03:19.678
You'll notice that pow and cube print 
differently than variable bindings. 

48
00:03:19.678 --> 00:03:23.210
In terms of the value, they just say, I'm 
a function. 

49
00:03:23.210 --> 00:03:27.124
We don't print out the body of the 
function or anything, the reple always 

50
00:03:27.124 --> 00:03:30.810
just say, here is a function. 
And here is it's type. 

51
00:03:30.810 --> 00:03:37.030
So you see with pow, that it has type int 
star int arrow int. 

52
00:03:37.030 --> 00:03:40.326
So the way function types are written in 
ML. 

53
00:03:40.326 --> 00:03:44.527
As we write down the types of the 
arguments, separated by a star. 

54
00:03:44.527 --> 00:03:47.350
So it takes two int arguments, int star 
int. 

55
00:03:47.350 --> 00:03:50.239
And then a hyphenate angle bracket, an 
arrow. 

56
00:03:50.239 --> 00:03:52.930
And then the result type, which is an 
int. 

57
00:03:52.930 --> 00:03:56.410
Notice we didn't have to write down that 
result type. 

58
00:03:56.410 --> 00:03:59.692
ML figured it out by looking at the 
function body. 

59
00:03:59.692 --> 00:04:05.010
That conditional that we had up here and 
realizing that if x and y have type int, 

60
00:04:05.010 --> 00:04:07.832
the conditional has the type, have type 
int. 

61
00:04:07.832 --> 00:04:12.100
And so the function, when called, with 
two ints, will return an int. 

62
00:04:12.100 --> 00:04:17.061
Similary cube is a function that takes 
one int and returns one int. 

63
00:04:17.061 --> 00:04:21.800
64 and 42 as usual, and we can you know 
try things out at the 

64
00:04:21.800 --> 00:04:25.307
repel now. 
So we could cube seven and we'll get 343 

65
00:04:25.307 --> 00:04:28.020
and so on. 
So, that's the informal idea of 

66
00:04:28.020 --> 00:04:33.381
functions, let me make a few points here 
back with the slides, since this is a new 

67
00:04:33.381 --> 00:04:39.138
thing we're learning the first thing is 
that the body of the pow function, itself 

68
00:04:39.138 --> 00:04:42.381
can use pow. 
So that's how we implement recursive 

69
00:04:42.381 --> 00:04:47.345
algorithms, as we did here, so all this 
is showing is that inside a function 

70
00:04:47.345 --> 00:04:52.910
body, you can call the function itself. 
There's a few gotchas when you start 

71
00:04:52.910 --> 00:04:56.882
writing things out, we have all new 
sources of potential error messages. 

72
00:04:56.882 --> 00:05:01.358
Especially if you leave that colon off 
between the name of the variable and the 

73
00:05:01.358 --> 00:05:05.666
type or if like in other languages you 
try to write ent x instead of x colon 

74
00:05:05.666 --> 00:05:08.240
int. 
All of these things are syntax errors and 

75
00:05:08.240 --> 00:05:10.870
you're going to get error messages as a 
result. 

76
00:05:10.870 --> 00:05:16.773
I would also point out that when we wrote 
out those function types in the repel, we 

77
00:05:16.773 --> 00:05:19.974
saw that pow had type int star int arrow 
int. 

78
00:05:19.974 --> 00:05:23.957
That star is different than the star for 
multiplication. 

79
00:05:23.957 --> 00:05:27.016
So it's just a reuse of the same 
character. 

80
00:05:27.016 --> 00:05:32.280
In expressions, star means multiply, in 
types, at least as we've seen so far, 

81
00:05:32.280 --> 00:05:36.050
it's just separating the types of 
multiple arguments. 

82
00:05:36.050 --> 00:05:40.768
And finally, just like variable bindings. 
function binding can use earlier bindings 

83
00:05:40.768 --> 00:05:43.710
in the file. 
But they can't use later bindings in the 

84
00:05:43.710 --> 00:05:46.153
file. 
And that's, again, just ML's rule. 

85
00:05:46.153 --> 00:05:50.538
so any helper functions you want, 
if you want to define one function like 

86
00:05:50.538 --> 00:05:54.868
cubed, in terms of another function like 
pow, then you have to put cubed second. 

87
00:05:54.868 --> 00:05:57.311
Now, this does raise an interesting 
question. 

88
00:05:57.311 --> 00:06:01.419
What if you had two or three functions 
that all wanted to call each other. 

89
00:06:01.419 --> 00:06:03.862
There would be no good order to put them 
in. 

90
00:06:03.862 --> 00:06:07.914
And I'll show you, in some future 
segments, some special support in ML for 

91
00:06:07.914 --> 00:06:12.030
that case of mutual recursion. 
if you're not yet comfortable with 

92
00:06:12.030 --> 00:06:14.835
recursion, hopefully you've at least seen 
it before. 

93
00:06:14.835 --> 00:06:20.282
you will be soon on your first homework 
assignment pretty much every function you 

94
00:06:20.282 --> 00:06:24.077
write will be recursive and we're going 
to see a bunch more examples. 

95
00:06:24.077 --> 00:06:28.643
So, don't panic if the algorithm for pow 
looked a little too magical, but there's 

96
00:06:28.643 --> 00:06:32.989
really absolutely nothing magical to it. 
So let me flip back here and just show 

97
00:06:32.989 --> 00:06:37.166
you this pow function. 
The reason why we can define pow in terms 

98
00:06:37.166 --> 00:06:41.622
of pow, there's nothing circular here. 
What we did is we defined raising 

99
00:06:41.622 --> 00:06:46.770
something to the y-th power, in terms of 
raising something to the y - 1-th power. 

100
00:06:46.770 --> 00:06:49.850
And that, is a perfect reasonable 
definition. 

101
00:06:49.850 --> 00:06:54.706
A recursive call is solving a simpler 
problem and if that simpler problem is 

102
00:06:54.706 --> 00:06:58.560
that y is zero, then we don't use 
recursion at all, and we just return the 

103
00:06:58.560 --> 00:07:01.252
answer one. 
So we'll get very comfortable with this 

104
00:07:01.252 --> 00:07:04.635
idea as we move forward. 
and in ML we're always going to use 

105
00:07:04.635 --> 00:07:09.101
recursion for these sorts of things. 
If you're used to writing things like pow 

106
00:07:09.101 --> 00:07:12.510
with while loops or for loops we're not 
going to use them. 

107
00:07:12.510 --> 00:07:18.039
they often obscure what are simple, more 
elegant algorithms and recursion is more 

108
00:07:18.039 --> 00:07:21.199
powerful. 
So, often while loops and for loops are 

109
00:07:21.199 --> 00:07:24.425
more convenient or the idiom in many 
programming languages and many 

110
00:07:24.425 --> 00:07:26.597
programming languages, they're more 
efficient. 

111
00:07:26.597 --> 00:07:31.337
But anything you can do with a loop, I 
promise you, you can do with recursion. 

112
00:07:31.337 --> 00:07:36.604
And we're going to focus on that approach 
in ML and most of the programming we do 

113
00:07:36.604 --> 00:07:37.460
in the class. 