WEBVTT

1
00:00:00.000 --> 00:00:04.940
[SOUND] 

2
00:00:04.940 --> 00:00:09.810
Alright in this segment I just want to 
pick up a few odds and ends that we didnt 

3
00:00:09.810 --> 00:00:14.502
do before in the interest of, of getting 
you ramped up with our useful thing to 

4
00:00:14.502 --> 00:00:17.175
know. 
and thats basically ways to combined 

5
00:00:17.175 --> 00:00:21.213
boolean expressions with and, and or, or 
negation things like that. 

6
00:00:21.213 --> 00:00:25.787
And also how to compare numbers with 
comparison operations I think I've only 

7
00:00:25.787 --> 00:00:30.457
shown you equal and grater than so far. 
So let's start with the boolean 

8
00:00:30.457 --> 00:00:33.515
operations. 
I actually showed you once because it 

9
00:00:33.515 --> 00:00:37.696
came up for an algorithm we needed. 
the construct e1 and also e2. 

10
00:00:37.696 --> 00:00:40.442
So, and also is just a seven letter key 
word. 

11
00:00:40.442 --> 00:00:45.435
And the type checking rules are that e1 
and e2 can be any expressions that have 

12
00:00:45.435 --> 00:00:48.355
type bool. 
And the evaluation rule is that we 

13
00:00:48.355 --> 00:00:51.699
evaluate e1. 
If we get false, then the result of the 

14
00:00:51.699 --> 00:00:54.781
entire thing is false and we never 
evaluate e2. 

15
00:00:54.781 --> 00:00:59.830
Otherwise, we evaluate e2 and then that's 
the result of the entire expression. 

16
00:00:59.830 --> 00:01:03.744
So this is exactly what in most 
programming languages these days is 

17
00:01:03.744 --> 00:01:08.752
written with the && operator. 
But ML is an older language that chose a 

18
00:01:08.752 --> 00:01:12.609
different and longer syntax. 
So you just have to write out and-also 

19
00:01:12.609 --> 00:01:16.812
when you want to do an and like this. 
similarly we have or-else, where we 

20
00:01:16.812 --> 00:01:21.302
evaluate e1, if we get true that's the 
result for the whole thing and we never 

21
00:01:21.302 --> 00:01:24.295
evaluate E2. 
Otherwise we evaluate E2 and that's the 

22
00:01:24.295 --> 00:01:27.860
result for the whole thing. 
And we have, actually, a function, not, 

23
00:01:27.860 --> 00:01:31.379
an OT, that evaluates e1. 
If you get true, the result is false. 

24
00:01:31.379 --> 00:01:35.680
If you get false, the result is true. 
So again, the syntax is most languages is 

25
00:01:35.680 --> 00:01:37.356
different. 
&&. 

26
00:01:37.356 --> 00:01:40.483
a pipe, pipe for or. 
And the exclamation point for not. 

27
00:01:40.483 --> 00:01:43.220
If you try those in ML, they're not going 
to work. 

28
00:01:43.220 --> 00:01:46.125
And, and, and or. 
And, and or with amper, amper and pipe, 

29
00:01:46.125 --> 00:01:49.141
pipe don't mean anything. 
So you'll get a syntax error. 

30
00:01:49.141 --> 00:01:53.554
the exclamation point actually means 
something totally different related to 

31
00:01:53.554 --> 00:01:56.011
mutation, which we might see at the very 
end. 

32
00:01:56.011 --> 00:02:00.960
So you'll get a stranger error message. 
And the last thing I wanted to point out 

33
00:02:00.960 --> 00:02:06.187
is because and also and or else have this 
property that don't always evaluate both 

34
00:02:06.187 --> 00:02:09.840
sub expressions. 
They really are key words and they're not 

35
00:02:09.840 --> 00:02:12.674
functions whereas not can just be a 
function. 

36
00:02:12.674 --> 00:02:16.578
So let me show you that. 
If I say something like true andalso 

37
00:02:16.578 --> 00:02:18.656
false I get false. 
That's fine. 

38
00:02:18.656 --> 00:02:21.931
And if I said true andalso true then I 
get true. 

39
00:02:21.931 --> 00:02:24.828
That's fine. 
And if I say not true I get false. 

40
00:02:24.828 --> 00:02:28.670
And if I say not false I get true. 
But if I just say andalso. 

41
00:02:28.670 --> 00:02:32.351
it's asking for more input. 
It's like that doesn't make any sense. 

42
00:02:32.351 --> 00:02:35.112
That's not the right syntax, this is a 
syntax error. 

43
00:02:35.112 --> 00:02:39.552
Because it says if you use andalso, you 
have to put an expression on the left and 

44
00:02:39.552 --> 00:02:42.909
an expression on the right. 
But if I just say not, it turns out 

45
00:02:42.909 --> 00:02:46.591
that's not special syntax at all. 
It just says, oh, well that's just a 

46
00:02:46.591 --> 00:02:50.435
function that was already defined, that 
takes a bool and returns a bool. 

47
00:02:50.435 --> 00:02:54.550
And that works just fine for not, because 
we always evaluate it's expression. 

48
00:02:54.550 --> 00:02:58.340
But we wouldn't want to define andalso 
that way, because we know that. 

49
00:02:58.340 --> 00:03:03.661
If we have, a function, we evaluate all 
the arguments to it, before we call the 

50
00:03:03.661 --> 00:03:08.429
function. And since that's not the 
semantics for andalso and or else, 

51
00:03:08.429 --> 00:03:10.502
they're not functions. 
Alright? 

52
00:03:10.502 --> 00:03:13.681
Okay. 
let me just point out one other thing 

53
00:03:13.681 --> 00:03:16.791
here. 
going back to the slides, and that is, 

54
00:03:16.791 --> 00:03:22.113
that a language, a programming language, 
if it has if-then-else expressions, it 

55
00:03:22.113 --> 00:03:27.426
doesn't need andalso, or else or not. 
So it turns out, as you see here on the 

56
00:03:27.426 --> 00:03:33.081
slide, if you were ever going to write e1 
and also e2, you could just write if e1 

57
00:03:33.081 --> 00:03:37.392
then e2, else false. 
Because both versions have the exact same 

58
00:03:37.392 --> 00:03:42.481
type checking rules and semantics. 
e1 and e2 both have to have type bool. 

59
00:03:42.481 --> 00:03:46.298
We evaluate e1. 
If we get false, that's the type, result 

60
00:03:46.298 --> 00:03:50.610
for the whole thing. 
If we get true, then we get the result of 

61
00:03:50.610 --> 00:03:55.380
evaluating E2. 
Similarly e1 or else e2 could just be 

62
00:03:55.380 --> 00:04:01.914
written if e1 then true else e2, and not. 
Can be written if e1 then false, else 

63
00:04:01.914 --> 00:04:04.766
true. 
So from a how powerful is your language 

64
00:04:04.766 --> 00:04:10.089
standpoint all you need is if then else. 
But because we have and also or else and 

65
00:04:10.089 --> 00:04:14.526
not, these longer versions with if then 
else are considered poor style. 

66
00:04:14.526 --> 00:04:19.532
And that's because someone reading your 
code can tell much more easily, oh this 

67
00:04:19.532 --> 00:04:24.348
is and, this is an and or this is an or. 
If you use the special syntax for it 

68
00:04:24.348 --> 00:04:29.228
rather than these more verbose versions 
using the more general expression. 

69
00:04:29.228 --> 00:04:33.804
And as long as we're on the subject. 
Please make sure that you never, in any 

70
00:04:33.804 --> 00:04:37.333
programming language. 
Write the equivalent of if e, then true, 

71
00:04:37.333 --> 00:04:40.157
else false. 
Let's understand what this is saying. 

72
00:04:40.157 --> 00:04:43.510
It says, evaluate e to a result. 
Which has to be a Boolean. 

73
00:04:43.510 --> 00:04:46.804
Either true or false. 
If that is, result is true, then our 

74
00:04:46.804 --> 00:04:50.157
whole thing is true. 
And if that result is false, then our 

75
00:04:50.157 --> 00:04:53.569
whole thing is false. 
That sounds very natural when you're 

76
00:04:53.569 --> 00:04:56.746
programming. 
But do you know a simpler expression that 

77
00:04:56.746 --> 00:04:58.570
has the exact same semantics? 
E. 

78
00:04:58.570 --> 00:05:02.693
E is an expression, that if you evaluate 
it and you get true, then the whole thing 

79
00:05:02.693 --> 00:05:06.461
is true, and if you evaluate it and you 
get false, the whole thing is false. 

80
00:05:06.461 --> 00:05:09.160
So please just write e, not if e then 
true, else false. 

81
00:05:09.160 --> 00:05:12.976
Okay, so those are the Booleans. 
Let's just finish up with the comparison 

82
00:05:12.976 --> 00:05:15.415
operators. 
If you have two ints, you can see if 

83
00:05:15.415 --> 00:05:17.376
there equal of equal. 
We've done that. 

84
00:05:17.376 --> 00:05:21.404
You can see if they're not equal with 
this second one, the less than greater 

85
00:05:21.404 --> 00:05:23.725
than. 
You might be used to in most programming 

86
00:05:23.725 --> 00:05:26.766
languages exclamation point equals. 
It's just not ML syntax. 

87
00:05:26.766 --> 00:05:30.143
You can think of this as < or > if you 
like. 

88
00:05:30.143 --> 00:05:32.770
The other comparison operators are more 
familiar. 

89
00:05:32.770 --> 00:05:38.667
><, <>, >=, <=. 
Just a couple weird things in ML, thanks 

90
00:05:38.667 --> 00:05:41.723
to the type system. 
And that is that the last four, for 

91
00:05:41.723 --> 00:05:45.904
greater than and less than, greater than 
or equal to, less than or equal to, can 

92
00:05:45.904 --> 00:05:50.140
also be used for floating point numbers, 
which ML calls things of type real, but 

93
00:05:50.140 --> 00:05:54.267
you can't use it for an int and a real. 
So let's just show you what I mean by 

94
00:05:54.267 --> 00:05:57.109
that. 
You can say 3 > 2 you get true. 

95
00:05:57.109 --> 00:06:00.994
You can ask if 3.0 is > 2.0. 
That also gives you true. 

96
00:06:00.994 --> 00:06:04.798
Notice, that three has type int and 3.0 
has type real. 

97
00:06:04.798 --> 00:06:07.690
You can't do this. 
You just get a type error. 

98
00:06:07.690 --> 00:06:12.114
The over need to convert an int to a 
real, there's a library function that 

99
00:06:12.114 --> 00:06:16.598
does that called real.fromint. 
You can call it with 2, you get back 2.0. 

100
00:06:16.598 --> 00:06:21.620
These purple messages are just the ripple 
telling you that it loaded the library 

101
00:06:21.620 --> 00:06:25.507
that has that functionality and you're 
welcome to ignore that. 

102
00:06:25.507 --> 00:06:29.154
Now just one more complication now that 
I've mentioned reals. 

103
00:06:29.154 --> 00:06:33.040
it turns out you cannot in ML, use = or 
not equal on reals. 

104
00:06:33.040 --> 00:06:37.644
You can use them on lots of types, we'll 
talk about this in the future, things 

105
00:06:37.644 --> 00:06:41.351
like equality types. 
Int's are just one example of an equality 

106
00:06:41.351 --> 00:06:43.585
type. 
But real is not in a quality type its 

107
00:06:43.585 --> 00:06:47.508
actually enforcing something that's good 
in any programming language because 

108
00:06:47.508 --> 00:06:51.533
floating point numbers are subject to 
round off errors it is rarely, rarely the 

109
00:06:51.533 --> 00:06:55.660
right thing to do to actually take two 
floating point numbers and see if they're 

110
00:06:55.660 --> 00:06:58.258
equal or not. 
You should always see if there within 

111
00:06:58.258 --> 00:07:00.806
some small epsilon, some small range of 
each other. 