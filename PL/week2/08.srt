WEBVTT

1
00:00:00.000 --> 00:00:02.822
[SOUND]. 
In this segment, we're just going to 

2
00:00:02.822 --> 00:00:07.888
write a bunch of functions that either 
take lists as arguments, or return lists 

3
00:00:07.888 --> 00:00:11.095
as results. 
We're not going to learn any new language 

4
00:00:11.095 --> 00:00:14.110
constructs. 
Instead, what we're going to do is take 

5
00:00:14.110 --> 00:00:18.728
our understanding of how recursive 
functions work, as well as, as well as 

6
00:00:18.728 --> 00:00:23.987
our understanding for how lists work. 
And combine them very powerfully to write 

7
00:00:23.987 --> 00:00:28.990
a lot of real useful programs, actually. 
And functions with very little code. 

8
00:00:28.990 --> 00:00:31.664
All right. 
So let's just go over here and get 

9
00:00:31.664 --> 00:00:34.575
started. 
How about as an initial example we write 

10
00:00:34.575 --> 00:00:37.368
a function to add up all the numbers in a 
list. 

11
00:00:37.368 --> 00:00:42.063
So, let's just take one argument of type 
int lists, I'll call it Xs, this is just 

12
00:00:42.063 --> 00:00:46.995
a convention to give variables that hold 
lists names that end in s, like the X's 

13
00:00:46.995 --> 00:00:49.610
where each element in the list ends in an 
x. 

14
00:00:49.610 --> 00:00:52.640
But it's just a variable name, nothing 
more or less. 

15
00:00:52.640 --> 00:00:57.179
And now we just have to add them up. 
Now the key thing when you're processing 

16
00:00:57.179 --> 00:01:01.804
a list, is to ask what should I do if the 
list is empty and what should I do if 

17
00:01:01.804 --> 00:01:05.023
it's not empty. 
Well, now if it is empty, maybe you think 

18
00:01:05.023 --> 00:01:08.711
that's not a well defined question. 
It's perfectly well defined. 

19
00:01:08.711 --> 00:01:11.111
The sum of zero elements is zero, 
alright. 

20
00:01:11.111 --> 00:01:15.911
that's going to help us out for our 
recursion, it's also what mathematicians 

21
00:01:15.911 --> 00:01:19.247
will tell you is the proper sum over an 
empty collection. 

22
00:01:19.247 --> 00:01:22.584
But, in any case, let's just now handle 
the non-empty case. 

23
00:01:22.584 --> 00:01:27.091
So, the way you sum up the elements of a 
non-empty list, is you take the first 

24
00:01:27.091 --> 00:01:29.180
element. 
And you add to it. 

25
00:01:29.180 --> 00:01:34.345
The sum of adding up. 
All the other elements. 

26
00:01:34.345 --> 00:01:40.060
So take the tail of the list, sum that up 
to get a number, add to that the head. 

27
00:01:40.060 --> 00:01:44.888
It's a simple recursive thought that 
follows directly from understanding what 

28
00:01:44.888 --> 00:01:49.360
should I do if the list is empty, what 
should I do if the list is not empty. 

29
00:01:49.360 --> 00:01:53.200
So this is a good example of a function 
that processes a list. 

30
00:01:53.200 --> 00:01:55.864
How bout we look at this for just a 
second. 

31
00:01:55.864 --> 00:01:59.270
Make sure it works. 
You see indeed, that it's type is, it 

32
00:01:59.270 --> 00:02:03.916
takes a list of int's and it returns an 
int, and we can try it out with for 

33
00:02:03.916 --> 00:02:06.890
example, with three, four, and five, and 
get twelve. 

34
00:02:06.890 --> 00:02:11.080
Alright, very good. 
So that was an example of a function that 

35
00:02:11.080 --> 00:02:15.271
took a list and returned here a simp, 
single answer like int. 

36
00:02:15.271 --> 00:02:20.928
How about a function that takes that has 
kind of the opposite type that takes an 

37
00:02:20.928 --> 00:02:25.607
int and returns an int list. 
And what I want to do actually is if I 

38
00:02:25.607 --> 00:02:31.055
call this for example seven, I want this 
to return seven, the list, excuse me 

39
00:02:31.055 --> 00:02:34.826
seven six five four three two one 
something like that. 

40
00:02:34.826 --> 00:02:38.492
that's just the function I want to write. 
all right? 

41
00:02:38.492 --> 00:02:41.825
So now, I have a different recursive 
question. 

42
00:02:41.825 --> 00:02:46.046
I want to say, well, when, should I stop 
making a bigger list? 

43
00:02:46.046 --> 00:02:50.786
Well, that's if x is zero. 
So if x is zero, then let's just return 

44
00:02:50.786 --> 00:02:54.563
the empty list. 
That's how you count down from zero. 

45
00:02:54.563 --> 00:02:59.821
You just have no more list. 
otherwise let's put x on the front of 

46
00:02:59.821 --> 00:03:04.117
some smaller list. 
And in fact, the list you would get from 

47
00:03:04.117 --> 00:03:08.100
evaluating the expression. 
Call countdown with x-1. 

48
00:03:08.100 --> 00:03:10.303
All right. 
So that's that. 

49
00:03:10.303 --> 00:03:19.566
Let's go over here and try this out. 
And indeed, countdown takes an int and 

50
00:03:19.566 --> 00:03:23.020
returns an int list, and I could say, 
countdown of seven. 

51
00:03:23.020 --> 00:03:25.635
And I get seven, six, five, four, three, 
two, one. 

52
00:03:25.635 --> 00:03:29.854
By the way, if you say count down to 
seven hundred, it will do the right 

53
00:03:29.854 --> 00:03:34.371
thing, but the redevelop print loop is 
trying to be nice to you, and figuring 

54
00:03:34.371 --> 00:03:38.829
that you don't want to see the entire 
answer, so you'll notice this dot, dot, 

55
00:03:38.829 --> 00:03:42.573
dot, here in the buffer. 
it really is a seven hundred element 

56
00:03:42.573 --> 00:03:47.387
list, and I could actually prove that to 
you by calling sub list on count down of 

57
00:03:47.387 --> 00:03:52.023
seven hundred, and I'll leave it to you 
to verify that it produced the correct 

58
00:03:52.023 --> 00:03:54.938
stuff. 
Alright let's go back here and write some 

59
00:03:54.938 --> 00:03:58.287
more functions. 
Here's probably one of my favorite ones, 

60
00:03:58.287 --> 00:04:02.185
this might look familiar and I'll tell 
you why in just a second. 

61
00:04:02.185 --> 00:04:07.179
Let's take two ent lists and append them 
so to return a new list that has all the 

62
00:04:07.179 --> 00:04:10.468
elements of X, X's followed by all the 
elements of Y's. 

63
00:04:10.468 --> 00:04:15.462
Now we'll learn later how to define this 
in a way that works for any kind of list 

64
00:04:15.462 --> 00:04:19.300
not just an ent list but we'll keep it 
simple for this segment. 

65
00:04:19.300 --> 00:04:23.222
And boy that seems like a tough thing. 
In fact this is sometimes even an 

66
00:04:23.222 --> 00:04:27.091
interview question if you're using a 
language like C or Java. 

67
00:04:27.091 --> 00:04:30.360
But, let's just think about how we would 
do this recursively. 

68
00:04:30.360 --> 00:04:35.234
We could think well, 
iff the first list is empty, Then it's 

69
00:04:35.234 --> 00:04:40.566
really easy to put all the elements in 
the first list in front of the elements 

70
00:04:40.566 --> 00:04:42.996
in the second list. 
there aren't any. 

71
00:04:42.996 --> 00:04:46.100
So just return Y's. 
Otherwise, what would we do? 

72
00:04:46.100 --> 00:04:51.499
Well what I could do is that I know the 
final result is going to start with the 

73
00:04:51.499 --> 00:04:56.898
first element of the first list, and then 
I'm going to have to pons that on to some 

74
00:04:56.898 --> 00:05:00.408
other list. 
So, how am I going to get all the rest of 

75
00:05:00.408 --> 00:05:04.390
the elements of the first list appended 
to the second list? 

76
00:05:04.390 --> 00:05:08.956
well all I have to do is call append, 
because that's how I append things. 

77
00:05:08.956 --> 00:05:13.461
With the smaller arguments, and this 
isn't going to be an infinite loop or 

78
00:05:13.461 --> 00:05:18.242
anything. 
and then wise and that's it. 

79
00:05:18.242 --> 00:05:22.529
Some of these parentheses aren't needed. 
But that's exactly the idea. 

80
00:05:22.529 --> 00:05:27.761
You append a non-empty X's by taking the 
first element of X's and ponsing it on to 

81
00:05:27.761 --> 00:05:30.977
the result of the pending the rest of X's 
onto Y's. 

82
00:05:30.977 --> 00:05:36.083
And I promise to tell why this might look 
familiar, this is the first half of the 

83
00:05:36.083 --> 00:05:39.676
course logo is an implementation of this 
append function. 

84
00:05:39.676 --> 00:05:45.035
let's look a the type of this I'll just 
tell you, you can type it in the rupple 

85
00:05:45.035 --> 00:05:47.620
and see. 
This is going to take two int lists. 

86
00:05:48.740 --> 00:05:54.914
And it's going to return an end list. 
That's what we would expect from pending 

87
00:05:54.914 --> 00:05:59.188
two end lists together. 
Alright, so now, lets write some 

88
00:05:59.188 --> 00:06:04.730
functions, over pairs of lists. 
Especially, since on your first homework 

89
00:06:04.730 --> 00:06:11.300
assignment you'll have to write a number 
of functions over lists that have triples 

90
00:06:11.300 --> 00:06:13.912
in them. 
So int star, int star int. 

91
00:06:13.912 --> 00:06:19.611
So this will be somewhat similar. 
So what if we wanted to take a list of 

92
00:06:19.611 --> 00:06:23.312
pairs of ints. 
Like this, and add together all the ints 

93
00:06:23.312 --> 00:06:27.007
in the whole list, including both 
components of the pairs. 

94
00:06:27.007 --> 00:06:30.767
Well, if there is nothing in that list, 
then we'll get zero. 

95
00:06:30.767 --> 00:06:33.944
That's still the right answer for the 
empty list. 

96
00:06:33.944 --> 00:06:39.130
Otherwise we need to take hash one of the 
first element of the list, add to that 

97
00:06:39.130 --> 00:06:42.890
hash two of the first element of the 
list, and add to that. 

98
00:06:42.890 --> 00:06:47.380
Some pair list tail of X's. 
This makes perfect sense because if I do, 

99
00:06:47.380 --> 00:06:52.596
for example, head of X's, that'll give me 
back an int star int, and then I can do 

100
00:06:52.596 --> 00:06:55.700
hash one or hash two to get the actual 
int sum. 

101
00:06:55.700 --> 00:07:01.161
If we wanted to test this out, we would 
have to call it with something like sum 

102
00:07:01.161 --> 00:07:04.272
pair list three comma four, five comma 
six. 

103
00:07:04.272 --> 00:07:08.420
And hopefully if we tried that out, we 
would get eighteen. 

104
00:07:08.420 --> 00:07:12.071
Alright? 
Here's another interesting function about 

105
00:07:12.071 --> 00:07:15.431
firsts. 
So this is also going to take an int star 

106
00:07:15.431 --> 00:07:19.009
int list. 
And what I want to do is return the first 

107
00:07:19.009 --> 00:07:23.318
component of everything. 
So, for example, if I called it with 

108
00:07:23.318 --> 00:07:25.947
this, list of pairs. 
Three, 4-5, six. 

109
00:07:25.947 --> 00:07:31.936
I would want to get back the list, three, 
5.'Cause that's the first component of 

110
00:07:31.936 --> 00:07:35.534
each thing. 
Well, if I start with the empty list, the 

111
00:07:35.534 --> 00:07:40.076
list holding the first component of 
everything, is the empty list. 

112
00:07:40.076 --> 00:07:45.456
Otherwise I have a non-empty list, then 
I'm going to take the first component of 

113
00:07:45.456 --> 00:07:50.346
the head and pons that onto the first 
component of the terrible lists. 

114
00:07:50.346 --> 00:07:55.796
So, for example if you called this with 
three comma four five comma six, you're 

115
00:07:55.796 --> 00:08:01.316
then making a recursive call with the 
list holding a single pair of five comma 

116
00:08:01.316 --> 00:08:04.250
six. 
So that would come back with the list 

117
00:08:04.250 --> 00:08:07.435
five. 
By the way, and here I'm going to do a 

118
00:08:07.435 --> 00:08:10.795
little bit of cut and paste in the 
interest of time. 

119
00:08:10.795 --> 00:08:14.220
We can compare this to the funge 
[INAUDIBLE] seconds. 

120
00:08:14.220 --> 00:08:17.310
Which just looks like this. 
And it's exactly the same. 

121
00:08:17.310 --> 00:08:21.974
Except we do have a hash two right there. 
And, of course, our recursive call needs 

122
00:08:21.974 --> 00:08:25.998
to call seconds instead of firsts. 
And probably a little later in the 

123
00:08:25.998 --> 00:08:29.788
course, we'll see nice ways to, not have 
to copy code like that. 

124
00:08:29.788 --> 00:08:34.336
To be able to write first and seconds, in 
terms of the same helper function. 

125
00:08:34.336 --> 00:08:39.000
But for now, we can at least see that, if 
we applied this to our example, we would 

126
00:08:39.000 --> 00:08:42.393
hope to get, four, six. 
And then lastly, I would point out that 

127
00:08:42.393 --> 00:08:46.226
one of the nice things in functional 
programming, or really any programming, 

128
00:08:46.226 --> 00:08:50.264
is sometimes you notice that some of the 
functions, functions you want to write 

129
00:08:50.264 --> 00:08:53.688
can be done quite simply in terms of 
functions you already have. 

130
00:08:53.688 --> 00:08:57.368
So, I thought I would show you another 
version of summing pairs of lists. 

131
00:08:57.368 --> 00:09:01.456
So I'll just call it sum pair list two so 
that I'm not shadowing my earlier one. 

132
00:09:01.456 --> 00:09:05.392
Remember this was the thing that took our 
example list and returned eighteen. 

133
00:09:05.392 --> 00:09:08.238
It just added everything together. 
And I would argue. 

134
00:09:08.238 --> 00:09:11.685
I'm going to maybe try to show you 
everything at once here. 

135
00:09:11.685 --> 00:09:16.548
That these three funct-, three of the 
functions I've written earlier, exactly 

136
00:09:16.548 --> 00:09:19.810
what I need. 
Up at the top of the file, the very first 

137
00:09:19.810 --> 00:09:23.750
function I wrote knows how to sum all of 
the elements in a list. 

138
00:09:23.750 --> 00:09:27.874
So what if I called that with the first 
elements or the components. 

139
00:09:27.874 --> 00:09:31.980
[SOUND] And then added that to [SOUND] 
summing [SOUND]. 

140
00:09:31.980 --> 00:09:38.097
All the second components. 
Alright, and then I would have a sol, 

141
00:09:38.097 --> 00:09:42.075
solution to that. 
So let's go over here try these things 

142
00:09:42.075 --> 00:09:48.590
out. 
You can try it out at, whoop. 

143
00:09:48.590 --> 00:09:51.107
on your own as well. 
Oop, 

144
00:09:51.107 --> 00:09:56.545
second seconds, right here on the last 
line, 

145
00:09:56.545 --> 00:10:00.544
all right. 
Much better. 

146
00:10:00.544 --> 00:10:07.895
And for example, I could call sum pair 
list two, on three comma four, five comma 

147
00:10:07.895 --> 00:10:15.360
six, and since I'm feeling bold here. 
How about nine comma negative three, 

148
00:10:15.360 --> 00:10:17.699
and I get 24, 
all right? 

149
00:10:17.699 --> 00:10:21.896
So that's a bunch of examples. 
Let me put back to the slides here just 

150
00:10:21.896 --> 00:10:26.333
to talk a little bit more about recursion 
and to remind you that it's not 

151
00:10:26.333 --> 00:10:30.470
surprising that functions of a list are 
pretty much always recursive. 

152
00:10:30.470 --> 00:10:34.842
If you're given a list, and you want to 
implement some function that accesses all 

153
00:10:34.842 --> 00:10:37.610
the elements. 
The only way you're going to be able to 

154
00:10:37.610 --> 00:10:42.039
get to all those elements is with some 
sort of recursive processing of the tail 

155
00:10:42.039 --> 00:10:44.972
of the list. 
So you just ask yourself, what should the 

156
00:10:44.972 --> 00:10:48.847
answer be for the empty list? 
And how can I compute the answer for the 

157
00:10:48.847 --> 00:10:51.560
non empty list, in terms of the tail of 
that list. 

158
00:10:51.560 --> 00:10:54.830
That's all there is to recursion. 
There's nothing magical about it. 

159
00:10:54.830 --> 00:10:59.985
Similarly, if you want to produce a list 
whose length depends on some argument you 

160
00:10:59.985 --> 00:11:04.883
took, like in our countdown example where 
I am going to put seven, six, five, four, 

161
00:11:04.883 --> 00:11:09.266
three, two, one, you're going to need 
something recursive so that you can 

162
00:11:09.266 --> 00:11:14.035
create your final result out of some 
smaller list that you created via 

163
00:11:14.035 --> 00:11:15.103
recursion. 
Alright. 

164
00:11:15.103 --> 00:11:18.435
So that's a lot of practice. 
You can get a lot more practice on 

165
00:11:18.435 --> 00:11:20.973
homework one. 
And now we'll move on to some more 

166
00:11:20.973 --> 00:11:21.926
language concepts. 