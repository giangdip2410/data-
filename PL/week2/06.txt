WEBVTT

1
00:00:04.179 --> 00:00:06.530
OK. In this segment,

2
00:00:06.530 --> 00:00:11.289
we're going to start studying data and ML that's built out of smaller pieces of data.

3
00:00:11.289 --> 00:00:13.160
We're going to start with pairs.

4
00:00:13.160 --> 00:00:15.733
So, we've seen numbers, we've seen booleans,

5
00:00:15.733 --> 00:00:17.949
those are basic data values and we've seen

6
00:00:17.949 --> 00:00:21.530
various ways to program with them like conditionals or variables or functions.

7
00:00:21.530 --> 00:00:25.039
But we need some way to build up things that have fields,

8
00:00:25.039 --> 00:00:26.162
multiple parts of them.

9
00:00:26.162 --> 00:00:28.760
This is essential in any programming language.

10
00:00:28.760 --> 00:00:31.449
If you have programmed in a language like Java,

11
00:00:31.449 --> 00:00:34.729
you've probably programmed with arrays that contain multiple pieces or you've

12
00:00:34.729 --> 00:00:38.575
programmed with classes that had multiple fields that sort of thing.

13
00:00:38.575 --> 00:00:42.090
In ML, we are going to take a very sort of fundamental approach to it.

14
00:00:42.090 --> 00:00:43.564
We are going to start with tuples,

15
00:00:43.564 --> 00:00:48.049
which are a very direct way to have a fixed number of different data items,

16
00:00:48.049 --> 00:00:51.289
each of which can have different types and then in later segments,

17
00:00:51.289 --> 00:00:53.840
we'll start programming with lists that can have

18
00:00:53.840 --> 00:00:57.920
any length at run-time but all the pieces have to have the same type.

19
00:00:57.920 --> 00:01:00.829
These are not the only forms of compound data we will study

20
00:01:00.829 --> 00:01:04.280
but they will be enough for the first homework assignment and they'll get us started.

21
00:01:04.280 --> 00:01:06.780
So, we'll start with pairs,

22
00:01:06.780 --> 00:01:09.614
and the way I want you to think about pairs is that they are

23
00:01:09.614 --> 00:01:12.859
just things with two parts and so in terms of new

24
00:01:12.859 --> 00:01:15.439
language constructs we need a way to build

25
00:01:15.439 --> 00:01:19.099
pairs and we need a way to access the pieces of pairs.

26
00:01:19.099 --> 00:01:21.290
So, here on this slide I have

27
00:01:21.290 --> 00:01:26.465
the pair building expression and I have the answers to our three questions about them.

28
00:01:26.465 --> 00:01:28.280
In terms of syntax,

29
00:01:28.280 --> 00:01:29.870
we are going to write two expressions.

30
00:01:29.870 --> 00:01:31.909
We are going to separate them by a comma,

31
00:01:31.909 --> 00:01:36.129
put them in parentheses and that's the syntax for building a pair.

32
00:01:36.129 --> 00:01:38.234
What are the evaluation rules?

33
00:01:38.234 --> 00:01:41.435
Well what we are going to do is evaluate 'e1' to some value.

34
00:01:41.435 --> 00:01:48.015
Call it 'v1', 'e2' to a value called 'v2' and then that pair of values will be a value.

35
00:01:48.015 --> 00:01:50.420
So, one val new kind of value,

36
00:01:50.420 --> 00:01:52.084
something that's done evaluating,

37
00:01:52.084 --> 00:01:55.719
is a pair that holds itself values.

38
00:01:55.719 --> 00:01:58.760
We also have a new kind of type for these pairs.

39
00:01:58.760 --> 00:02:03.170
So, if 'e1' has some type say 'ta' and 'e2' has some type

40
00:02:03.170 --> 00:02:08.155
say 'tb' then the pair expression will have 'ta * tb'.

41
00:02:08.155 --> 00:02:10.464
So, just as the two parts of the pair,

42
00:02:10.464 --> 00:02:14.004
the types of those parts separated by a star.

43
00:02:14.004 --> 00:02:18.269
So, that's how we build pair expressions now how do we access the pieces?

44
00:02:18.269 --> 00:02:22.849
Well, I will show you a different way in the future but for now let's use these two

45
00:02:22.849 --> 00:02:28.580
constructs '#1' of an expression and '#2' of an expression.

46
00:02:28.580 --> 00:02:32.659
The evaluation rules are that we are going to evaluate that expression 'e' to

47
00:02:32.659 --> 00:02:38.479
some value it's going to be a pair and then '#1' will return the first part of that pair,

48
00:02:38.479 --> 00:02:41.594
and then '#2' would return the second part of the pair.

49
00:02:41.594 --> 00:02:48.229
So if 'x' is say the pair of four and 17 and we said '#1' of 'x', we'd get back 4.

50
00:02:48.229 --> 00:02:52.854
Type checking works similarly that 'e' in there better have a pair type,

51
00:02:52.854 --> 00:02:55.319
so it better be some 'ta * tb'.

52
00:02:55.319 --> 00:02:59.330
Otherwise this access expression doesn't type check and then '#1'

53
00:02:59.330 --> 00:03:04.335
of 'e' would have type 'ta' and '#2' of 'e' would have typed 'tb'.

54
00:03:04.335 --> 00:03:07.340
So those really are the rules but like anything you tend

55
00:03:07.340 --> 00:03:11.444
to really understand how they work by writing some programs and trying them out.

56
00:03:11.444 --> 00:03:15.465
So, let's just write a few functions that take or return pairs.

57
00:03:15.465 --> 00:03:18.229
So, how about I start with a 'swap' function maybe it

58
00:03:18.229 --> 00:03:21.319
takes one argument I'll call it 'pr' for pair

59
00:03:21.319 --> 00:03:24.020
maybe it has type 'int*bool' so it

60
00:03:24.020 --> 00:03:27.540
takes something whose first part is an 'int' and second part is a 'bool'.

61
00:03:27.540 --> 00:03:31.669
And maybe what I want to return is a new pair where I build

62
00:03:31.669 --> 00:03:37.095
the first piece out of '#2' of pair and the second piece out of '#1' of pair. All right.

63
00:03:37.095 --> 00:03:39.814
So I'll show you in a second an example of how that works.

64
00:03:39.814 --> 00:03:43.310
In the meantime, how about I just write some other functions here.

65
00:03:43.310 --> 00:03:44.330
How about I take,

66
00:03:44.330 --> 00:03:48.724
write a function that takes two pairs both of which have type 'int * int'

67
00:03:48.724 --> 00:03:53.745
and just adds up those four pieces that are in there.

68
00:03:53.745 --> 00:03:59.504
So what I want to return is '#1' of pair one plus '#2' of pair one.

69
00:03:59.504 --> 00:04:01.969
I can grab these four pieces in any order I want.

70
00:04:01.969 --> 00:04:05.800
'#1' of pair two plus '#2' of pair two.

71
00:04:05.800 --> 00:04:07.819
It's a perfectly reasonable function that takes as

72
00:04:07.819 --> 00:04:11.389
arguments two 'int * int' and returns an int.

73
00:04:11.389 --> 00:04:18.432
So the type of this whole thing would be '(int * int) * (int * int)',

74
00:04:18.432 --> 00:04:25.499
and it returns an 'int' let's put that in a comment. All right?

75
00:04:25.499 --> 00:04:27.954
Let's do a couple of more.

76
00:04:27.954 --> 00:04:30.889
Oh, here's one that I really like because this is something that's just

77
00:04:30.889 --> 00:04:34.975
completely natural to do and a pain to do in many programming languages.

78
00:04:34.975 --> 00:04:41.680
Let's take in a numerator and denominator x and y so just two arguments of type and.

79
00:04:41.680 --> 00:04:46.939
And let's return X divided by Y and the remainder of x and y.

80
00:04:46.939 --> 00:04:50.084
Now these operators have strange names in ML;

81
00:04:50.084 --> 00:04:52.750
div and mod but I can still write this.

82
00:04:52.750 --> 00:04:57.245
All I'm doing here is returning a pair of two expressions

83
00:04:57.245 --> 00:05:02.149
the result of X div Y and the result of X mod Y and so this function is

84
00:05:02.149 --> 00:05:06.449
going to take in two 'ints' * 'int' and it's going to return a pair of

85
00:05:06.449 --> 00:05:09.040
'ints' three to val print loop and we actually print this

86
00:05:09.040 --> 00:05:12.600
out won't write those parentheses but it's just that simple.

87
00:05:12.600 --> 00:05:13.998
All right. How about one more,

88
00:05:13.998 --> 00:05:18.660
how about we take in a pair of integers and we sort that pair.

89
00:05:18.660 --> 00:05:25.990
So we're going to return a pair of 'int' * 'int' and if the first part of the pair

90
00:05:25.990 --> 00:05:29.050
is less than the second part of the pair

91
00:05:29.050 --> 00:05:33.795
then we'll just return the pair we started with because it's already sorted.

92
00:05:33.795 --> 00:05:39.745
Otherwise, let's swap it around and return '#2' of pair, '#1' of pair.

93
00:05:39.745 --> 00:05:42.189
All right? So that seems like a good set of example functions.

94
00:05:42.189 --> 00:05:43.982
Let's real quickly go over here,

95
00:05:43.982 --> 00:05:50.050
make sure that I actually wrote those correctly and they load up here, good.

96
00:05:50.050 --> 00:05:54.980
We see that swap is has type 'int'*'bool' arrow 'bool'*'int'.

97
00:05:54.980 --> 00:06:00.819
So how about I try that out how about I tried calling it with seven and true and I get

98
00:06:00.819 --> 00:06:03.699
true seven if I call it with let's say minus

99
00:06:03.699 --> 00:06:07.084
four and false should get false and minus four.

100
00:06:07.084 --> 00:06:09.730
Now, you might be thinking how does ML know that I'm

101
00:06:09.730 --> 00:06:13.180
calling it with a pair and not calling it with two arguments.

102
00:06:13.180 --> 00:06:15.939
Well, in a future lecture I will show you the ML that's actually

103
00:06:15.939 --> 00:06:20.595
exactly the same thing but for now we'll keep them as separate concepts.

104
00:06:20.595 --> 00:06:25.689
And let me try one more here how about sort pair of (3,4).

105
00:06:25.689 --> 00:06:28.269
I just get back the pair (3,4) of type 'int'*'int'

106
00:06:28.269 --> 00:06:31.389
and if instead I had maybe had a value that

107
00:06:31.389 --> 00:06:37.254
was (4,3) and then I said sort pair of X it would come back (3,4).

108
00:06:37.254 --> 00:06:40.459
Of course, I could have just directly asked

109
00:06:40.459 --> 00:06:44.475
sort pair (4,3) I would get the same answer of course.

110
00:06:44.475 --> 00:06:46.654
OK. So that's programming with pairs.

111
00:06:46.654 --> 00:06:49.720
Let's go back to the slides here and show you that while that's

112
00:06:49.720 --> 00:06:53.379
really all there is the pairs we can,

113
00:06:53.379 --> 00:06:56.560
in fact, generalize this idea to tuples.

114
00:06:56.560 --> 00:06:58.569
So a pair is just a two tuple.

115
00:06:58.569 --> 00:07:01.334
In general you can have any number of pieces.

116
00:07:01.334 --> 00:07:04.644
So to build a tuple with n pieces you just have

117
00:07:04.644 --> 00:07:09.129
n expression separated by commas the type of that thing will be

118
00:07:09.129 --> 00:07:14.074
all the types of the expressions separated by stars or something like

119
00:07:14.074 --> 00:07:17.214
'int'*'int'*'int' would be a triple where

120
00:07:17.214 --> 00:07:20.709
each piece was 'int' and you access the pieces with '#1 e,

121
00:07:20.709 --> 00:07:24.610
#2 e, #3 e' and so forth.

122
00:07:24.610 --> 00:07:28.029
So you'll get a lot of experience on this because 'int'*'int*int' is in

123
00:07:28.029 --> 00:07:32.829
fact a common type for a lot of the problems on the first homework assignment.

124
00:07:32.829 --> 00:07:35.394
I also want to emphasize that without adding

125
00:07:35.394 --> 00:07:38.439
anything new to our language the rules I already showed you.

126
00:07:38.439 --> 00:07:43.290
You can nest tuples and other kinds of expressions as deep as you like.

127
00:07:43.290 --> 00:07:45.970
So, I have a few examples here on the slide we could type these into

128
00:07:45.970 --> 00:07:49.035
the redeveloped print loop or into an M-L file as well.

129
00:07:49.035 --> 00:07:55.240
But for example, if you write seven comma and then in it's own pair true comma nine.

130
00:07:55.240 --> 00:07:59.269
Well that's going to be a pair where the first part has type 'int'

131
00:07:59.269 --> 00:08:03.990
the second part is also a pair of type ('bool'*'int').

132
00:08:03.990 --> 00:08:09.764
So the overall type is ('int*') parenthesis ('bool'*'int').

133
00:08:09.764 --> 00:08:14.740
Therefore, if you took that x 1 and you applied the hash to

134
00:08:14.740 --> 00:08:20.425
operation to it (#2 x1) is going to give back a ('bool'*'int').

135
00:08:20.425 --> 00:08:25.500
So if we then added #1 of that so #1 of #2 of x

136
00:08:25.500 --> 00:08:33.100
1 that would give you back something of type bool and in fact x 2 would evaluate to true.

137
00:08:33.100 --> 00:08:38.184
Similarly, x 3 which is this #2 of x 1 makes perfect sense.

138
00:08:38.184 --> 00:08:41.496
The result we look up X-1 in our environment we get (7,

139
00:08:41.496 --> 00:08:44.676
(true, 9)) we do #2 that,

140
00:08:44.676 --> 00:08:46.690
we're going to get (true, 9) and that's

141
00:08:46.690 --> 00:08:52.365
a perfectly reasonable value of type ('bool'*'int') that we can then bind to x 3.

142
00:08:52.365 --> 00:08:55.085
And of course, these things can nest however deep you want.

143
00:08:55.085 --> 00:08:57.700
So, in this last line here maybe it's hard to

144
00:08:57.700 --> 00:09:00.700
follow all the parentheses or whatever but we just have

145
00:09:00.700 --> 00:09:03.730
a pair whose first part is a pair of 'ints' and

146
00:09:03.730 --> 00:09:07.490
whose second part is two pairs of pairs of 'ints' sorry,

147
00:09:07.490 --> 00:09:10.975
it's a pair of a pair of 'ints' hard to talk about

148
00:09:10.975 --> 00:09:16.000
easy to program with and you can see the type written here. So that's tuples.