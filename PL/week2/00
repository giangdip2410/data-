WEBVTT

1
00:00:04.250 --> 00:00:07.020
Without much further ado,

2
00:00:07.020 --> 00:00:10.485
let's get started with programming in ML.

3
00:00:10.485 --> 00:00:13.122
What I really hope you'll do,

4
00:00:13.122 --> 00:00:14.275
as we start doing this,

5
00:00:14.275 --> 00:00:19.260
is let go of any programming or any programming language you already know.

6
00:00:19.260 --> 00:00:22.370
For now, treat ML as this totally new thing.

7
00:00:22.370 --> 00:00:24.720
If you prefer, don't even call it programming.

8
00:00:24.720 --> 00:00:27.390
We'll have plenty of time later to compare and

9
00:00:27.390 --> 00:00:31.385
contrast what we're going to do in ML to things that you already know.

10
00:00:31.385 --> 00:00:33.810
And I really think that if right now you try to

11
00:00:33.810 --> 00:00:36.840
take each thing that I write down and say, "Oh,

12
00:00:36.840 --> 00:00:41.204
that's kind of like this thing I know in Java or in Python," or in whatever,

13
00:00:41.204 --> 00:00:44.815
it's going to confuse you and make things more difficult.

14
00:00:44.815 --> 00:00:47.550
It may seem like I'm going really slowly,

15
00:00:47.550 --> 00:00:50.550
but focus on the words and the terms,

16
00:00:50.550 --> 00:00:53.250
and how we're thinking about stuff rather

17
00:00:53.250 --> 00:00:56.365
than trying to guess what the answer is going to be as we go.

18
00:00:56.365 --> 00:00:59.779
I'll usually have things open for us in advance,

19
00:00:59.779 --> 00:01:02.940
but since this is the first time I'm showing this to you,

20
00:01:02.940 --> 00:01:05.310
what I'm going to do now is open the Emacs editor.

21
00:01:05.310 --> 00:01:07.960
This is what it looks like right after I open it.

22
00:01:07.960 --> 00:01:09.275
Your colors may be different.

23
00:01:09.275 --> 00:01:12.855
I've chosen these colors because I think they'll record better and in fact,

24
00:01:12.855 --> 00:01:19.255
I'm going to switch the size here as well so that it will be easier for you to see.

25
00:01:19.255 --> 00:01:21.495
Now I'm just going to open any file I want.

26
00:01:21.495 --> 00:01:23.150
I'll usually have this predone,

27
00:01:23.150 --> 00:01:25.361
but again, I hit Control-X,

28
00:01:25.361 --> 00:01:29.634
Control-F and now I'm just passing in a pathname.

29
00:01:29.634 --> 00:01:32.763
This file doesn't actually exist yet, first.sml.

30
00:01:32.763 --> 00:01:36.720
We're always going to use sml for our file extensions.

31
00:01:36.720 --> 00:01:39.857
Hit return and now I have this blank file here.

32
00:01:39.857 --> 00:01:41.820
By the way, another simple thing you can do is,

33
00:01:41.820 --> 00:01:43.590
if you create the file ahead of time,

34
00:01:43.590 --> 00:01:45.235
you can literally take your mouse,

35
00:01:45.235 --> 00:01:49.080
at least under Windows, and drag the file on to Emacs and it will open.

36
00:01:49.080 --> 00:01:51.660
So, here I am, in a blank file,

37
00:01:51.660 --> 00:01:54.581
and the first thing I'll do is write a comment.

38
00:01:54.581 --> 00:01:57.160
So, "This is a comment.

39
00:01:57.160 --> 00:01:59.855
This is our first program."

40
00:01:59.855 --> 00:02:03.810
Comments, like in every programming language I'm familiar with,

41
00:02:03.810 --> 00:02:08.655
are just things that are ignored by anything, except humans,

42
00:02:08.655 --> 00:02:10.289
and in standard ML,

43
00:02:10.289 --> 00:02:12.780
we start our comments with a round parenthesis and

44
00:02:12.780 --> 00:02:16.585
then a star and we end them with a star and then a round parenthesis,

45
00:02:16.585 --> 00:02:19.745
and yes, you can nest comments inside of each other.

46
00:02:19.745 --> 00:02:20.849
That's just a comment.

47
00:02:20.849 --> 00:02:22.980
We haven't written any program yet.

48
00:02:22.980 --> 00:02:25.464
Let's write a one line program,

49
00:02:25.464 --> 00:02:27.870
val x = 34.

50
00:02:27.870 --> 00:02:34.356
This program is going to create a variable and is going to have that variable hold 34,

51
00:02:34.356 --> 00:02:38.355
and because 34 is something of type int,

52
00:02:38.355 --> 00:02:40.740
short for the English word integer,

53
00:02:40.740 --> 00:02:44.350
x will be a variable of type int.

54
00:02:44.350 --> 00:02:50.820
What we see here is we are creating a new variable using the val keyword.

55
00:02:50.820 --> 00:02:53.445
So val is a special word in the language that says,

56
00:02:53.445 --> 00:02:55.139
"I'm about to introduce a variable.".

57
00:02:55.139 --> 00:02:57.565
X is the variable name we chose.

58
00:02:57.565 --> 00:03:05.370
We could have chosen any thing there like y or foo or hello or Dan.

59
00:03:05.370 --> 00:03:09.600
Equals is part of the syntax of declaring a variable, and then here,

60
00:03:09.600 --> 00:03:12.895
between the equals and the semi-colon to end it,

61
00:03:12.895 --> 00:03:15.720
I've put an expression and the simplest kind of

62
00:03:15.720 --> 00:03:19.110
expression we have is just an integer constant.

63
00:03:19.110 --> 00:03:20.670
Let me do a second one.

64
00:03:20.670 --> 00:03:24.190
Let's create a variable y that has value 17.

65
00:03:24.190 --> 00:03:25.949
Now I'm going to save with Control-X,

66
00:03:25.949 --> 00:03:28.635
Control-S, and now this is a program.

67
00:03:28.635 --> 00:03:30.150
I didn't need a main.

68
00:03:30.150 --> 00:03:31.655
I didn't need a class.

69
00:03:31.655 --> 00:03:32.984
I didn't need a method.

70
00:03:32.984 --> 00:03:35.400
For today, for this video,

71
00:03:35.400 --> 00:03:40.005
a program is just a sequence of these variable bindings.

72
00:03:40.005 --> 00:03:41.845
Each of these is a binding.

73
00:03:41.845 --> 00:03:45.100
We have a sequence of them and that's our program.

74
00:03:45.100 --> 00:03:46.904
If I want to run this program,

75
00:03:46.904 --> 00:03:51.205
I'm going to use the standard ML REPL, the Read-Eval-Print Loop.

76
00:03:51.205 --> 00:03:53.253
We'll talk more about that in a couple of videos,

77
00:03:53.253 --> 00:03:56.510
but for now, let me just give you the basics of how you run this program.

78
00:03:56.510 --> 00:03:58.241
I'm going to try Control-C,

79
00:03:58.241 --> 00:04:00.960
Control-S, then hit return.

80
00:04:00.960 --> 00:04:03.105
That brings up this other window,

81
00:04:03.105 --> 00:04:05.160
where I can now say,

82
00:04:05.160 --> 00:04:07.910
use, and then first.sml.

83
00:04:07.910 --> 00:04:09.585
So the name of my file,

84
00:04:09.585 --> 00:04:11.310
inside of quotation marks,

85
00:04:11.310 --> 00:04:12.696
to make it a string,

86
00:04:12.696 --> 00:04:15.760
this function, although think of it as a command use,

87
00:04:15.760 --> 00:04:18.500
then a semi-colon and then hit return.

88
00:04:18.500 --> 00:04:23.396
Sure enough, I get a message that it's opening that file and it tells me some things.

89
00:04:23.396 --> 00:04:27.495
It says that it's created a value x, a variable x,

90
00:04:27.495 --> 00:04:30.520
that contains 34 and has type int,

91
00:04:30.520 --> 00:04:34.559
a variable y that contains 17 and has type int,

92
00:04:34.559 --> 00:04:36.180
and this last line you'll always see.

93
00:04:36.180 --> 00:04:41.065
This is actually the result of running use and you're free to ignore it.

94
00:04:41.065 --> 00:04:43.340
I can now continue.

95
00:04:43.340 --> 00:04:45.165
I could add more things to my file,

96
00:04:45.165 --> 00:04:48.570
but I can also just use this prompt to see things.

97
00:04:48.570 --> 00:04:50.544
If I type, x;,

98
00:04:50.544 --> 00:04:52.954
it will say, "Oh that's a 34.

99
00:04:52.954 --> 00:04:54.150
It has type int." If I said,

100
00:04:54.150 --> 00:04:56.730
x+7;, it'll say, "Oh,

101
00:04:56.730 --> 00:04:59.000
that's 41 and it has type int."

102
00:04:59.000 --> 00:05:01.870
If I say x+7 and forget the semi-colon,

103
00:05:01.870 --> 00:05:06.290
it will wait for me to continue some longer command and so I can end it with semi-colon,

104
00:05:06.290 --> 00:05:09.140
or I could have split things onto multiple lines and

105
00:05:09.140 --> 00:05:12.169
maybe added y to that and then semi-colon,

106
00:05:12.169 --> 00:05:15.113
and that would be 58 and so on.

107
00:05:15.113 --> 00:05:18.230
We'll have more to say about the REPL in a bit,

108
00:05:18.230 --> 00:05:19.440
but for this video,

109
00:05:19.440 --> 00:05:24.110
what I want to do is just go back and continue writing our program and

110
00:05:24.110 --> 00:05:29.850
understand the exact meaning of what it means to have a sequence of bindings.

111
00:05:29.850 --> 00:05:31.790
The nice thing about this sequence,

112
00:05:31.790 --> 00:05:34.250
is that you can use earlier things in the sequence.

113
00:05:34.250 --> 00:05:39.165
If I have x+y+y+2,

114
00:05:39.165 --> 00:05:43.789
now what will happen is when I go to create the variable binding for z,

115
00:05:43.789 --> 00:05:46.830
it will be able to use the earlier bindings.

116
00:05:46.830 --> 00:05:48.200
An obvious question would be,

117
00:05:48.200 --> 00:05:49.879
can you use later bindings?

118
00:05:49.879 --> 00:05:54.079
The answer is you cannot and that might seem very strange or unusual,

119
00:05:54.079 --> 00:05:58.155
but it has certain advantages that we'll talk about in a couple of videos.

120
00:05:58.155 --> 00:06:01.180
But the rule, every programming language has different rules,

121
00:06:01.180 --> 00:06:04.615
is that you can only use the earlier bindings.

122
00:06:04.615 --> 00:06:07.760
The reason is, that we can actually keep

123
00:06:07.760 --> 00:06:11.180
track of exactly what our program means as we go along.

124
00:06:11.180 --> 00:06:12.875
I'm going to do this in comments,

125
00:06:12.875 --> 00:06:14.794
but this is exactly what

126
00:06:14.794 --> 00:06:18.840
the implementation of the language is doing when it sees all this code.

127
00:06:18.840 --> 00:06:21.620
Initially, we don't have anything.

128
00:06:21.620 --> 00:06:24.455
It turns out we have a bunch of predefined functions and variables,

129
00:06:24.455 --> 00:06:27.405
but we haven't defined anything yet.

130
00:06:27.405 --> 00:06:32.284
After we create this variable binding x,

131
00:06:32.284 --> 00:06:35.955
what we have is what I'll call it a dynamic environment.

132
00:06:35.955 --> 00:06:40.205
It's the environment you have when you're running the program and in that environment,

133
00:06:40.205 --> 00:06:42.935
let's say, x --> 34.

134
00:06:42.935 --> 00:06:45.830
Then, after the next one,

135
00:06:45.830 --> 00:06:50.000
we'll have a dynamic environment.

136
00:06:50.000 --> 00:06:56.040
Environment, where x --> 34 and y --> 17.

137
00:06:56.040 --> 00:07:02.309
That's why, when we get to this third one,

138
00:07:02.309 --> 00:07:05.850
we still have x --> 34 and y --> 17.

139
00:07:05.850 --> 00:07:08.395
What happens is, we get to

140
00:07:08.395 --> 00:07:14.435
this expression and we evaluate it in the current dynamic environment.

141
00:07:14.435 --> 00:07:16.350
When you have an addition expression,

142
00:07:16.350 --> 00:07:18.768
you go and evaluate the two sub pieces,

143
00:07:18.768 --> 00:07:20.380
so in this edition expression,

144
00:07:20.380 --> 00:07:21.630
the two sub pieces.

145
00:07:21.630 --> 00:07:22.915
When you get a variable,

146
00:07:22.915 --> 00:07:24.800
you look it up in the environment.

147
00:07:24.800 --> 00:07:26.844
We look up x, we get 34.

148
00:07:26.844 --> 00:07:28.710
We look up y, we get 17.

149
00:07:28.710 --> 00:07:30.315
Together, that's 51.

150
00:07:30.315 --> 00:07:32.635
Over here we'll end up looking up y again.

151
00:07:32.635 --> 00:07:35.855
That will give us 17, add two more, that's 19.

152
00:07:35.855 --> 00:07:38.520
If my math is correct, we'll get what?

153
00:07:38.520 --> 00:07:41.715
About 70 here so z will,

154
00:07:41.715 --> 00:07:44.530
in this environment, now map to 70.

155
00:07:44.530 --> 00:07:48.300
This is how we continue as we evaluate our program.

156
00:07:48.300 --> 00:07:50.609
If next, we had z+1,

157
00:07:50.609 --> 00:07:52.320
then I'm just going to paste this down.

158
00:07:52.320 --> 00:07:54.921
We'd have everything we did have on our environment,

159
00:07:54.921 --> 00:07:56.984
and now w holds 71.

160
00:07:56.984 --> 00:08:00.650
There's something that happens before any of this,

161
00:08:00.650 --> 00:08:02.955
and that is that our entire program,

162
00:08:02.955 --> 00:08:06.458
our file or sequence of bindings, is typed checked.

163
00:08:06.458 --> 00:08:10.065
ML is a language with a type system and if your program makes

164
00:08:10.065 --> 00:08:12.120
inconsistent assumptions about what's in

165
00:08:12.120 --> 00:08:16.279
int or tries to use a variable that's not defined,

166
00:08:16.279 --> 00:08:19.683
you get an error before you ever tried to run the program

167
00:08:19.683 --> 00:08:23.212
and that is taken care of by what I'll call the static environment.

168
00:08:23.212 --> 00:08:25.100
Even though I'm showing this to you second,

169
00:08:25.100 --> 00:08:28.155
this all happens before the program is ever evaluated,

170
00:08:28.155 --> 00:08:29.549
before it's ever run.

171
00:08:29.549 --> 00:08:31.395
What actually happened is

172
00:08:31.395 --> 00:08:35.479
the implementation first went through this whole program and said, "Oh,

173
00:08:35.479 --> 00:08:38.175
because 34 is an int, I know that,

174
00:08:38.175 --> 00:08:39.765
that's built into the language,

175
00:08:39.765 --> 00:08:42.054
x will have type int.

176
00:08:42.054 --> 00:08:43.890
It will hold something of type int.".

177
00:08:43.890 --> 00:08:49.149
Similarly, as I go back through this sequence I say,

178
00:08:49.149 --> 00:08:52.368
"Oh, x has type int and y has type int.".

179
00:08:52.368 --> 00:08:55.050
Here, now this is more interesting,

180
00:08:55.050 --> 00:08:58.050
the only reason that z gets to also have

181
00:08:58.050 --> 00:09:04.100
type int is because when I looked at this expression,

182
00:09:04.100 --> 00:09:07.339
when the type checker looked at this expression, and said, "Well,

183
00:09:07.339 --> 00:09:13.769
addition has type int if both the sub expressions on the two sides have type int.

184
00:09:13.769 --> 00:09:16.535
Similarly, this addition can have type int,

185
00:09:16.535 --> 00:09:20.585
if x and y have type int and when you get a variable,

186
00:09:20.585 --> 00:09:24.979
you type check it by looking it up in the static environment.".

187
00:09:24.979 --> 00:09:28.920
The static environment acts a lot like the dynamic environment

188
00:09:28.920 --> 00:09:33.310
except it just deals with what's an int or what's defined or what's not,

189
00:09:33.310 --> 00:09:37.415
and so it doesn't actually run the program.

190
00:09:37.415 --> 00:09:41.330
What really happens when you take this file is,

191
00:09:41.330 --> 00:09:43.820
first, everything type checks then,

192
00:09:43.820 --> 00:09:46.280
if that passes, everything runs.

193
00:09:46.280 --> 00:09:48.280
It may not look that way.

194
00:09:48.280 --> 00:09:50.315
If I flip over to my REPL here,

195
00:09:50.315 --> 00:09:55.385
and I'm always going to restart before I show you something after I've changed the file,

196
00:09:55.385 --> 00:10:01.245
it looks like it just figured out all together that x is a 34 and is type int,

197
00:10:01.245 --> 00:10:02.775
y is 17 and is type int.

198
00:10:02.775 --> 00:10:08.816
I really like to think of the type checking as coming before the evaluation.

199
00:10:08.816 --> 00:10:14.821
Let me show you a couple more kinds of expressions and then we'll wrap up this segment.

200
00:10:14.821 --> 00:10:20.090
First, let me show you a conditional.

201
00:10:20.090 --> 00:10:26.240
Here, let me finish writing it out and then I'll walk you through what's going on here.

202
00:10:26.240 --> 00:10:28.034
I'm just creating another variable.

203
00:10:28.034 --> 00:10:33.514
This one is called abs_of_z and it says if z < 0,

204
00:10:33.514 --> 00:10:36.170
then 0 - z else z.

205
00:10:36.170 --> 00:10:38.165
As you might imagine,

206
00:10:38.165 --> 00:10:41.985
the way an "if" expression is evaluated is different than addition.

207
00:10:41.985 --> 00:10:46.135
It doesn't go and evaluate all the sub expressions.

208
00:10:46.135 --> 00:10:51.260
It first looks at this first sub expression, z < 0.

209
00:10:51.260 --> 00:10:54.420
It looks up z in the dynamic environment, gets 70,

210
00:10:54.420 --> 00:10:59.405
takes 0, asks <, that's false.

211
00:10:59.405 --> 00:11:03.425
As a result, it ignores this expression between then and else,

212
00:11:03.425 --> 00:11:09.416
never evaluates it, and instead evaluates just the thing after the else, gets a result,

213
00:11:09.416 --> 00:11:10.982
in this case 70,

214
00:11:10.982 --> 00:11:14.075
and so the result of the entire thing,

215
00:11:14.075 --> 00:11:17.235
this if will be 70 and will end up therefore,

216
00:11:17.235 --> 00:11:19.970
putting the result as the value for abs_of_z,

217
00:11:19.970 --> 00:11:23.960
which is shorthand for the absolute value of z.

218
00:11:23.960 --> 00:11:28.335
In fact, in our dynamic environment here,

219
00:11:28.335 --> 00:11:33.299
we'll have everything we had before and then,

220
00:11:33.299 --> 00:11:38.959
that abs_of_z maps to 70.

221
00:11:38.959 --> 00:11:40.910
As for the type checking,

222
00:11:40.910 --> 00:11:42.710
the way we type check an if then else,

223
00:11:42.710 --> 00:11:47.600
is the thing between the if and the then has to be something of type bool, and indeed,

224
00:11:47.600 --> 00:11:49.805
less then returns a bool,

225
00:11:49.805 --> 00:11:53.194
short for Boolean, given two integer arguments.

226
00:11:53.194 --> 00:11:56.205
Then these two branches can have any type they want,

227
00:11:56.205 --> 00:11:57.925
but they have to have the same type.

228
00:11:57.925 --> 00:12:00.800
In this case, fortunately, they both have type int and so

229
00:12:00.800 --> 00:12:04.203
the result of the entire if expression is type int,

230
00:12:04.203 --> 00:12:08.780
which is why abs_of_z in our static environment indeed

231
00:12:08.780 --> 00:12:11.165
has type int as does everything else

232
00:12:11.165 --> 00:12:13.880
we've added to our static environment in this first file.

233
00:12:13.880 --> 00:12:16.160
By the way, this is

234
00:12:16.160 --> 00:12:20.440
a real programming language with lots of built in features like less than,

235
00:12:20.440 --> 00:12:21.895
and plus and minus.

236
00:12:21.895 --> 00:12:23.680
We didn't actually have to do it that way.

237
00:12:23.680 --> 00:12:27.199
There's a function defined for us called abs,

238
00:12:27.199 --> 00:12:30.020
which takes an int and returns its absolute value.

239
00:12:30.020 --> 00:12:32.705
This is the first time I'm showing you, calling a function.

240
00:12:32.705 --> 00:12:35.840
You might be used to something like this and you can write it that way,

241
00:12:35.840 --> 00:12:37.760
but the parentheses don't actually matter.

242
00:12:37.760 --> 00:12:40.600
You can leave them out and this would have done the same thing.

243
00:12:40.600 --> 00:12:42.982
That's our first program.

244
00:12:42.982 --> 00:12:45.650
Let me now get rid of this and just give you

245
00:12:45.650 --> 00:12:50.115
a little more sense of how the slides will work after I show you the code.

246
00:12:50.115 --> 00:12:52.360
Here's basically the program we just wrote.

247
00:12:52.360 --> 00:12:55.370
I like to include it in the slides so if you're looking through the slides,

248
00:12:55.370 --> 00:12:56.915
you don't have to flip back and forth,

249
00:12:56.915 --> 00:12:59.600
but we already saw all this.

250
00:12:59.600 --> 00:13:04.452
What we focused on here were variable bindings and in general,

251
00:13:04.452 --> 00:13:06.905
the way we have a variable bindings, we had val,

252
00:13:06.905 --> 00:13:10.689
the name of the variable, the equal sign,

253
00:13:10.689 --> 00:13:13.520
an expression which I'm representing here in the middle of

254
00:13:13.520 --> 00:13:16.820
the slide with an e and then a semi-colon.

255
00:13:16.820 --> 00:13:19.745
What I've just described is the syntax.

256
00:13:19.745 --> 00:13:22.670
Syntax is how you write something down.

257
00:13:22.670 --> 00:13:24.740
I haven't said what it means,

258
00:13:24.740 --> 00:13:28.160
that we talked about with the code and I have it here on

259
00:13:28.160 --> 00:13:31.811
the last slide of this little segment and that's the semantics.

260
00:13:31.811 --> 00:13:34.059
Syntax is how you write something,

261
00:13:34.059 --> 00:13:36.530
semantics is what that something means.

262
00:13:36.530 --> 00:13:39.495
We're dividing our semantics into type checking,

263
00:13:39.495 --> 00:13:44.540
which is what we do before the program runs to make sure there's nothing inconsistent.

264
00:13:44.540 --> 00:13:46.940
You don't use a variable that's not defined.

265
00:13:46.940 --> 00:13:49.295
You don't try to add something that's not a number,

266
00:13:49.295 --> 00:13:50.390
that sort of thing,

267
00:13:50.390 --> 00:13:54.250
and then evaluation, which is what happens when the program runs.

268
00:13:54.250 --> 00:13:55.940
For these variable bindings,

269
00:13:55.940 --> 00:13:58.122
which is all I showed you here,

270
00:13:58.122 --> 00:14:00.470
you type check the expression,

271
00:14:00.470 --> 00:14:02.365
that e after the equals,

272
00:14:02.365 --> 00:14:05.230
and use that to extend the static environment.

273
00:14:05.230 --> 00:14:07.525
When you evaluate the expression,

274
00:14:07.525 --> 00:14:10.660
that ends up extending the dynamic environment.

275
00:14:10.660 --> 00:14:13.584
That's this meaning of variable bindings,

276
00:14:13.584 --> 00:14:16.150
but it seems clear that the meaning is

277
00:14:16.150 --> 00:14:19.080
going to depend on what kind of expression we have.

278
00:14:19.080 --> 00:14:21.460
For each kind of expression: variables,

279
00:14:21.460 --> 00:14:24.024
additions, conditionals, less than,

280
00:14:24.024 --> 00:14:27.535
they're going to have their own syntax, type checking rules,

281
00:14:27.535 --> 00:14:30.430
and evaluation rules, and to go through those,

282
00:14:30.430 --> 00:14:32.000
you can go to the next video.