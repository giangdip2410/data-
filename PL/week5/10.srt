WEBVTT

1
00:00:00.012 --> 00:00:05.952
[MUSIC] It's now time to take our module 
example from the previous segment and 

2
00:00:05.952 --> 00:00:11.451
figure our a good signature to give it. 
And I think this will be much more 

3
00:00:11.451 --> 00:00:17.183
interesting than you might imagine. 
So from what we know so far, what would 

4
00:00:17.183 --> 00:00:23.621
be natural is defined as signature like 
you see on the slide that hides the two 

5
00:00:23.621 --> 00:00:27.537
helper functions that we don't want the 
outside world to know about. 

6
00:00:27.537 --> 00:00:32.019
So we make no mention of GCD and reduce, 
but the outside world does need to know 

7
00:00:32.019 --> 00:00:35.897
there's a type rational that can be 
wholes or fracs, that there's an 

8
00:00:35.897 --> 00:00:40.493
exception bad frac, there's a make frac 
that takes a numerator and a denominator 

9
00:00:40.493 --> 00:00:44.527
and returns a rational. 
Add takes 2 rationals, returns a rational 

10
00:00:44.527 --> 00:00:47.744
and to string takes a rational and 
returns a string. 

11
00:00:47.744 --> 00:00:51.563
And this signature is something we can 
give to our structure. 

12
00:00:51.563 --> 00:00:56.128
It will type check and then the outside 
world will not be able to use GCD or 

13
00:00:56.128 --> 00:00:58.723
reduced directly. 
So, that's okay. 

14
00:00:58.723 --> 00:01:03.573
It's not a bad start. 
But it turns out we made a crucial error. 

15
00:01:03.573 --> 00:01:09.669
And that is, that by revealing the data 
type definition, this first line here 

16
00:01:09.669 --> 00:01:15.202
where we told the outside world how 
rational was implemented clients can 

17
00:01:15.202 --> 00:01:19.826
violate all of our invariants and they'll 
be able to use the library in the way 

18
00:01:19.826 --> 00:01:23.608
that will not lead to the results and the 
behavior that we want. 

19
00:01:23.608 --> 00:01:27.968
Now we could include a comment, or we 
could ask clients to please, please 

20
00:01:27.968 --> 00:01:32.881
promise not to build their own rationals. 
To always call make frac, because make 

21
00:01:32.881 --> 00:01:37.521
frac checks for certain things, and 
insta, institutes our invariants when we 

22
00:01:37.521 --> 00:01:40.265
get started. 
But I don't know about you, I have 

23
00:01:40.265 --> 00:01:44.967
certainly found that when I put things in 
comments and documentation, my library 

24
00:01:44.967 --> 00:01:49.246
clients don't always follow those rules. 
And it would be much better if my 

25
00:01:49.246 --> 00:01:51.711
language had a way to enforce those 
rules. 

26
00:01:51.711 --> 00:01:54.902
And it does, and I'll show that to you in 
just a second. 

27
00:01:54.902 --> 00:01:59.856
But first, let me emphasize what goes 
wrong here under this first signature 

28
00:01:59.856 --> 00:02:03.304
rational A. 
The key problem is that clients will be 

29
00:02:03.304 --> 00:02:06.390
able to call the frac constructor 
directly. 

30
00:02:06.390 --> 00:02:11.514
They could make a frac out of an 1 and 0 
or a 3 and -2, or 9 and 6 and these are 

31
00:02:11.514 --> 00:02:17.062
all forms of values that the functions in 
my library assume do not exist and once 

32
00:02:17.062 --> 00:02:21.482
they do exist, all sorts of things could 
end up going wrong. 

33
00:02:21.482 --> 00:02:26.267
So let me show some slightly different 
examples I've already included everything 

34
00:02:26.267 --> 00:02:30.917
here exactly as you've seen it, so I have 
this structure rational 1 that has the 

35
00:02:30.917 --> 00:02:34.802
signature you see right here, 
okay? And now let me just write some 

36
00:02:34.802 --> 00:02:37.717
things that work and some things that 
don't work. 

37
00:02:37.717 --> 00:02:42.342
So suppose I wanted to add 2 rationals 
and suppose first I do this correctly and 

38
00:02:42.342 --> 00:02:47.706
I call make frac. 
So 1,0 and make_frac of say two-thirds, 

39
00:02:47.706 --> 00:02:54.877
okay? If I do this, I get the exception 
bad frac which is the correct behavior. 

40
00:02:54.877 --> 00:03:00.052
But if my client does not follow the 
rules and makes a frac directly then it 

41
00:03:00.052 --> 00:03:05.267
goes in an infinite loop it turns out and 
we could try to figure out why I think 

42
00:03:05.267 --> 00:03:09.072
it's related to GCD. 
But we don't want to figure this out, we 

43
00:03:09.072 --> 00:03:12.452
want to keep clients from doing something 
like this. 

44
00:03:12.452 --> 00:03:15.974
Like this, alright. 
here's something else they might do if I 

45
00:03:15.974 --> 00:03:19.937
just had negative denominator I think I 
end up overflowing. 

46
00:03:19.937 --> 00:03:24.105
Again because the arithmetic just assumed 
in the module there wouldn't be a 

47
00:03:24.105 --> 00:03:28.897
negative denominator and if there is 
certain things are not behaving correctly 

48
00:03:28.897 --> 00:03:33.800
and as a final even simpler example. 
Remember, one of the things we promised 

49
00:03:33.800 --> 00:03:37.730
clients is that we would always print 
everything in reduced form. 

50
00:03:37.730 --> 00:03:42.222
But if they just called to string with a 
frac directly, we're just going to get 

51
00:03:42.222 --> 00:03:45.847
nine slash six. 
Because you may recall that our to string 

52
00:03:45.847 --> 00:03:49.777
code which you see here assumes its 
argument was already reduced. 

53
00:03:49.777 --> 00:03:53.452
And this is again something our client is 
able to violate, 

54
00:03:53.452 --> 00:03:59.002
okay? So this is what we want to try to 
prevent, and here's the intuition. 

55
00:03:59.002 --> 00:04:04.987
The intuition is that an ADT should hide 
the concrete representation of a type. 

56
00:04:04.987 --> 00:04:10.802
That way clients will never be able to 
make anything of the type without going 

57
00:04:10.802 --> 00:04:16.422
through our functions like make frac. 
That way we can get those invariants 

58
00:04:16.422 --> 00:04:21.338
installed and then out functions can keep 
them, so here's how you might think to do 

59
00:04:21.338 --> 00:04:23.768
this. 
Let's just take the signature we had 

60
00:04:23.768 --> 00:04:28.024
before and take out the data type 
definition don't tell clients that it can 

61
00:04:28.024 --> 00:04:31.260
be built from a whole constructor or a 
frac constructor. 

62
00:04:31.260 --> 00:04:34.980
So this does not work here, 
and the reason is the type checker sees 

63
00:04:34.980 --> 00:04:38.373
these types rational and says I've never 
heard of such a thing, 

64
00:04:38.373 --> 00:04:40.915
right? 
It'll just give an error and says, you, 

65
00:04:40.915 --> 00:04:43.895
you can't, you can't just make up type 
names like that. 

66
00:04:43.895 --> 00:04:48.146
I need to know there's a type rational 
otherwise I, I think you just, you know, 

67
00:04:48.146 --> 00:04:49.299
had a typo. 
Alright, 

68
00:04:49.299 --> 00:04:51.791
so that's good the type checker is 
helping us. 

69
00:04:51.791 --> 00:04:55.933
Somehow what we want to do is tell the 
type checker, that for this signature, 

70
00:04:55.933 --> 00:05:00.050
yes, rational is a type. 
But no, I don't want clients to know 

71
00:05:00.050 --> 00:05:05.098
anything more about it. 
And that is an absolutely crucial idea, 

72
00:05:05.098 --> 00:05:10.967
which is known as an abstract type. 
You can know the type is exists, but you 

73
00:05:10.967 --> 00:05:16.003
cant know it's definition. 
So this is how we do this in ML, this is 

74
00:05:16.003 --> 00:05:21.918
a feature provided by ML, which is in 
signatures you can just write type and 

75
00:05:21.918 --> 00:05:25.285
the name of a type. 
And if you have no equals and no more 

76
00:05:25.285 --> 00:05:30.130
information, it means what I just said. 
The type exists, but the outside world 

77
00:05:30.130 --> 00:05:33.930
can't know what it is. 
So here is a signature I like very much. 

78
00:05:33.930 --> 00:05:37.816
I'll call it rational B, 
and it tells clients what they can know 

79
00:05:37.816 --> 00:05:40.976
about rational. 
It says you can know there's a type 

80
00:05:40.976 --> 00:05:43.692
rational. 
You can know there's an exception 

81
00:05:43.692 --> 00:05:46.569
BadFrac. 
You can know that make_frac returns a 

82
00:05:46.569 --> 00:05:50.294
rational given 2 int's. 
Add can take 2 rationals and return a 

83
00:05:50.294 --> 00:05:53.994
rational to string can take a rational 
and return a string. 

84
00:05:53.994 --> 00:05:58.635
And if we gave Rational1 this signature, 
we will still be able to try all the 

85
00:05:58.635 --> 00:06:03.380
examples that use make_frac correctly, 
but the outside world no longer knows 

86
00:06:03.380 --> 00:06:08.644
there is a frac constructor. 
Capital FRAC, and so it won't be able to 

87
00:06:08.644 --> 00:06:13.171
create any of those vowels that violate 
our invariance. 

88
00:06:13.171 --> 00:06:19.172
So this is a really big deal, there is 
nothing a client can do not to violate 

89
00:06:19.172 --> 00:06:23.095
our invariance. 
We could take the structure we studied 

90
00:06:23.095 --> 00:06:28.180
carefully in the previous segment and 
this signature and convince ourselves 

91
00:06:28.180 --> 00:06:32.896
that all of our properties will always 
hold, here is the intuition of the 

92
00:06:32.896 --> 00:06:35.958
argument. 
How we will make it rational? 

93
00:06:35.958 --> 00:06:41.415
The first rational acclaim ever makes has 
to be made make_frac, because this is all 

94
00:06:41.415 --> 00:06:46.792
they have to create rationals, you can't 
call add until you have a rational. 

95
00:06:46.792 --> 00:06:49.419
You can't call to string until you have a 
rational. 

96
00:06:49.419 --> 00:06:51.950
So, you're going to have to start with 
make_frac. 

97
00:06:51.950 --> 00:06:56.067
We could study the code for make_frac and 
convince ourselves that it gets all the 

98
00:06:56.067 --> 00:07:00.399
invariants and properties correctly, no 
zero denominator, no negative denominator 

99
00:07:00.399 --> 00:07:03.661
fraction in reduced form. 
After that, the only thing you can do 

100
00:07:03.661 --> 00:07:07.539
with rationals is add them together and 
convert them to strings and we would 

101
00:07:07.539 --> 00:07:11.912
similarly convince ourselves that those 
functions were implemented correctly. 

102
00:07:11.912 --> 00:07:17.009
Now to the outside world it can do what 
it wants with the rational values it can 

103
00:07:17.009 --> 00:07:22.352
put them in lists, it can pass them to 
functions it can put them in tuples, but 

104
00:07:22.352 --> 00:07:27.584
the only operations it can perform that 
access the pieces Are those provided in 

105
00:07:27.584 --> 00:07:30.525
our library. 
Now, the reason why our structure 

106
00:07:30.525 --> 00:07:34.758
actually has this signature, is because 
it does define everything. 

107
00:07:34.758 --> 00:07:39.618
Defines make_frac added to string and can 
have these types and it does define a 

108
00:07:39.618 --> 00:07:43.662
type rational. 
It does it with a data type binding, that 

109
00:07:43.662 --> 00:07:49.102
is a perfect good way to define a type. 
The outside world just doesn't know you 

110
00:07:49.102 --> 00:07:54.622
did it with a data type binding, and it 
certainly doesn't know that details of 

111
00:07:54.622 --> 00:07:59.877
data type binding. And this is how you 
use signatures of abstract types to 

112
00:07:59.877 --> 00:08:04.662
properly enforce obstructions and 
implement abstract data types. 

113
00:08:04.662 --> 00:08:09.985
So, what we have now are two powerful 
ways to use a signature to hide things 

114
00:08:09.985 --> 00:08:13.615
from clients. 
The first one is to deny bindings exist. 

115
00:08:13.615 --> 00:08:18.528
That if you leave val-bindings, 
fun-bindings, constructors and so on out 

116
00:08:18.528 --> 00:08:22.207
of your signature, they simply don't 
exist to clients. 

117
00:08:22.207 --> 00:08:27.250
But, the second more sophisticated and 
more exciting way to hide things, is to 

118
00:08:27.250 --> 00:08:31.232
take a type definition. 
Tell the outside world that yes you have 

119
00:08:31.232 --> 00:08:35.521
defined this type, but I'm not going to 
tell you how I did it, and that's 

120
00:08:35.521 --> 00:08:38.441
important, so that we can say that make 
frac. 

121
00:08:38.441 --> 00:08:43.251
Returns a rational and takes 2 rationals 
and returns a rational without revealing 

122
00:08:43.251 --> 00:08:46.996
what the rational actually is. 
We'll see some other things that 

123
00:08:46.996 --> 00:08:52.566
signatures can hide in, in, one of the 
later segments on modules but these are 

124
00:08:52.566 --> 00:08:55.385
the 2 things I hope you'll always 
remember. 

125
00:08:55.385 --> 00:09:00.232
Now before we finish up this segment, I 
want to show you a third signature that's 

126
00:09:00.232 --> 00:09:05.121
also in the code file that's posted with 
these materials and this is just a little 

127
00:09:05.121 --> 00:09:07.992
bit cute. 
So it turns out that if you look at the 

128
00:09:07.992 --> 00:09:12.827
data type binding for this module which I 
have right here, It was a problem for our 

129
00:09:12.827 --> 00:09:17.037
invariance, to export the frac 
constructor, and I showed you a bunch of 

130
00:09:17.037 --> 00:09:20.337
examples of that. 
But it turns out, it would be fine, to 

131
00:09:20.337 --> 00:09:24.522
export the whole constructor. 
That our library doesn't mind, any int, 

132
00:09:24.522 --> 00:09:27.952
past the whole. 
So you cant get in trouble that, that's, 

133
00:09:27.952 --> 00:09:32.887
has to do with our particular properties 
in invariance, but it turns out you can 

134
00:09:32.887 --> 00:09:37.240
convince yourself it would be okay, if 
clients used whole directly, okay? So we 

135
00:09:37.240 --> 00:09:41.681
actually can export it and we can do it 
with this signature. 

136
00:09:41.681 --> 00:09:47.373
It turns out we could go ahead and tell 
clients that there is a function whole 

137
00:09:47.373 --> 00:09:50.672
with a capital W of type int arrow 
rational. 

138
00:09:50.672 --> 00:09:54.891
And if you take this structure as we've 
already defined it and type check it 

139
00:09:54.891 --> 00:09:59.209
against this signature, ML allows it. 
And that's kind of surprising perhaps, 

140
00:09:59.209 --> 00:10:03.602
but the reason why is when it sees this 
data type binding, it remembers all the 

141
00:10:03.602 --> 00:10:06.270
way back from when we first learned data 
types. 

142
00:10:06.270 --> 00:10:11.420
That this defines a number of things. 
It defines a type rational yes, but also 

143
00:10:11.420 --> 00:10:16.811
a function whole of type int or a 
rational, Frac of int*int, a rational, as 

144
00:10:16.811 --> 00:10:21.105
well as Whole and Frac being allowed to 
be used in patterns. 

145
00:10:21.105 --> 00:10:25.349
Signatures let us hide some things and 
reveal some things. 

146
00:10:25.349 --> 00:10:30.609
And in this particular example, ML will 
allow us to expose that there is a 

147
00:10:30.609 --> 00:10:35.749
function Whole of type int rational. 
There is a type rational, but still hide 

148
00:10:35.749 --> 00:10:39.120
all the other things that data type 
binding gave us. 

149
00:10:39.120 --> 00:10:44.034
This is a bit of a peculuraity to ML, I 
don't think this is the most important 

150
00:10:44.034 --> 00:10:49.152
feature in a language, but I do find it 
cute and I find it, that it emphasizes 

151
00:10:49.152 --> 00:10:53.016
that signatures get to expose some things 
and hide other things. 

152
00:10:53.016 --> 00:10:57.508
And there's just a particular way we 
could let clients do a little bit more. 

153
00:10:57.508 --> 00:11:02.214
They can call Whole directly rather than 
having to call make_frac with a second 

154
00:11:02.214 --> 00:11:03.135
argument of int. 