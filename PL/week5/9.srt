WEBVTT

1
00:00:00.000 --> 00:00:05.236
[MUSIC]

2
00:00:05.236 --> 00:00:08.776
This segment is going to introduce
an example that we are going to use for

3
00:00:08.776 --> 00:00:11.060
the rest of our study of module systems.

4
00:00:11.060 --> 00:00:12.460
So we'll get very used to it and

5
00:00:12.460 --> 00:00:15.600
it's worth going through
the code before we get started.

6
00:00:15.600 --> 00:00:19.120
The example is going to
implement an abstract data type.

7
00:00:19.120 --> 00:00:23.670
It's just a module that exports some new
type of data and some operations on it.

8
00:00:23.670 --> 00:00:26.715
And for a simple example that
doesn't take too long to implement,

9
00:00:26.715 --> 00:00:29.620
I've a little library for
rational numbers.

10
00:00:29.620 --> 00:00:31.610
So these are numbers that
can have a numerator and

11
00:00:31.610 --> 00:00:35.960
a denominator where both the numerator and
the denominator are integers.

12
00:00:35.960 --> 00:00:39.320
And the operations I'm going to
support are making these things,

13
00:00:39.320 --> 00:00:41.630
these fractions if you will.

14
00:00:41.630 --> 00:00:45.260
Adding two of them together and
then converting them to a string.

15
00:00:45.260 --> 00:00:49.880
So for example,
if you had number three halves,

16
00:00:49.880 --> 00:00:53.640
would turn out three slash two
when you convert it to a string.

17
00:00:53.640 --> 00:00:55.260
So I'll show you the code
in just a second,

18
00:00:55.260 --> 00:00:57.210
let me give you a high
level picture of it.

19
00:00:57.210 --> 00:00:59.376
I'm going to have
a structure named Rational1,

20
00:00:59.376 --> 00:01:02.972
because in later segments I'm going to
define rational two and rational three.

21
00:01:02.972 --> 00:01:05.170
I'm going to have little data type for

22
00:01:05.170 --> 00:01:09.350
my rational numbers that has either
the constructor Whole, for whole numbers,

23
00:01:09.350 --> 00:01:12.851
carries one int, or Frac for
fractions, that carries two ints.

24
00:01:12.851 --> 00:01:17.570
I've got an exception BadFrac in case
someone tries to make a fraction with

25
00:01:17.570 --> 00:01:21.876
a denominator of zero because I want those
to be undefined in the raise an exception.

26
00:01:21.876 --> 00:01:26.160
And the function make_frac that takes
in a numerator and a denominator and

27
00:01:26.160 --> 00:01:27.730
returns a rational.

28
00:01:27.730 --> 00:01:31.800
Add for adding two rationals and
toString for taking a rational and

29
00:01:31.800 --> 00:01:33.240
returning a string.

30
00:01:33.240 --> 00:01:36.930
Now the implementation of my module is
going to have local helper functions,

31
00:01:36.930 --> 00:01:39.200
that I'll show what those
do in just a second.

32
00:01:39.200 --> 00:01:41.950
And in the next segment,
when we give this structure a signature,

33
00:01:41.950 --> 00:01:44.620
it will not surprise you that
we will choose to hide those.

34
00:01:44.620 --> 00:01:48.145
So the outside world doesn't
have to rely on them.

35
00:01:48.145 --> 00:01:51.006
So next, let's go over and
show you the code.

36
00:01:51.006 --> 00:01:52.210
So here it is.

37
00:01:52.210 --> 00:01:56.480
It has the datatype definition, just
like I promised you and the exception,

38
00:01:56.480 --> 00:01:58.100
just like I promised you.

39
00:01:58.100 --> 00:02:00.160
And as we're going to talk
about more in a minute,

40
00:02:00.160 --> 00:02:03.600
the implementation of
this module is going to

41
00:02:03.600 --> 00:02:07.660
keep a couple in variants because
it's going to promise a few things.

42
00:02:07.660 --> 00:02:11.300
What I didn't tell you yet about this
module is that I'm going to make sure

43
00:02:11.300 --> 00:02:15.810
that we always return strings
that are in reduced form.

44
00:02:15.810 --> 00:02:18.180
So we would never return
the string nine slash six.

45
00:02:18.180 --> 00:02:21.146
We would instead return three slash two.

46
00:02:21.146 --> 00:02:24.510
And we wouldn't return
the string eight slash two,

47
00:02:24.510 --> 00:02:26.660
we would return the string four.

48
00:02:26.660 --> 00:02:31.110
So we're going to do that by
having a couple helper functions.

49
00:02:31.110 --> 00:02:34.150
The key helper function
is this one reduce.

50
00:02:34.150 --> 00:02:37.111
Reduce takes in a rational and
returns a rational and

51
00:02:37.111 --> 00:02:40.570
what it does is it return
something in reduced form.

52
00:02:40.570 --> 00:02:43.170
So if it starts with a whole number,
just return the whole number.

53
00:02:43.170 --> 00:02:44.750
Those are always reduced.

54
00:02:44.750 --> 00:02:47.459
Otherwise, if it's a fraction of an x and
y,

55
00:02:47.459 --> 00:02:52.460
if x=0, the numerator is 0,
then the whole thing is 0, right.

56
00:02:52.460 --> 00:02:54.230
Zero over anything should be zero.

57
00:02:54.230 --> 00:02:57.090
Remember we're not going to
allow zero denominators.

58
00:02:57.090 --> 00:03:02.190
Otherwise, it turns out what we need to
do is compute the greatest common divisor

59
00:03:02.190 --> 00:03:07.320
of x and y, but my gcd function
assumes that x and y are positive.

60
00:03:07.320 --> 00:03:11.810
So I'm going to (abs x, y),
my denominators will always be positive,

61
00:03:11.810 --> 00:03:15.670
that's another invariant that
this module is going to enforce.

62
00:03:15.670 --> 00:03:18.570
Then if d, the greatest common divisor,

63
00:03:18.570 --> 00:03:22.960
divides y,
then we should be a whole number, x div d.

64
00:03:22.960 --> 00:03:25.500
Otherwise, we should div the Frac(x div d,
y div d).

65
00:03:25.500 --> 00:03:30.520
And I will leave it to you to either trust
me or check me on the arithmetic that this

66
00:03:30.520 --> 00:03:36.740
does reduce a fraction to reduced form
as long as gcd is implemented correctly.

67
00:03:36.740 --> 00:03:38.130
I have that right up here.

68
00:03:38.130 --> 00:03:42.680
This is another algorithm that I will
not convince you is correct but if x and

69
00:03:42.680 --> 00:03:46.630
y are greater than zero,
this will do the right thing.

70
00:03:46.630 --> 00:03:51.220
And believe it or not this is a recursive
algorithm that is over 2000 years old.

71
00:03:51.220 --> 00:03:53.420
It goes back to ancient Greece I believe.

72
00:03:53.420 --> 00:03:58.440
And so humankind is fairly convinced
that this algorithm is correct.

73
00:03:58.440 --> 00:03:59.830
So that's kind of neat.

74
00:03:59.830 --> 00:04:01.370
These are just helper functions.

75
00:04:01.370 --> 00:04:03.908
Now let's talk about the functions
that our clients are going to use.

76
00:04:03.908 --> 00:04:09.390
I have make_frac which is going
to take in an x and a y, if y=0,

77
00:04:09.390 --> 00:04:14.268
you're trying to grade a fraction with a
zero denominator, I'll raise an exception.

78
00:04:14.268 --> 00:04:18.910
If y < 0,
I don't want negative denominators,

79
00:04:18.910 --> 00:04:22.050
that's one of the invariance this
model is going to maintain, so

80
00:04:22.050 --> 00:04:28.830
instead I'm going to return Frac(-x,-y) so
that's going to make y positive.

81
00:04:28.830 --> 00:04:33.580
And x will have the opposite sign of
whatever it did when it was passed in.

82
00:04:33.580 --> 00:04:35.802
And then I need to reduce that,

83
00:04:35.802 --> 00:04:40.856
because maybe you call make_frac
with 9 and 6 or 9 and negative 6.

84
00:04:40.856 --> 00:04:44.890
And then I want to return
negative three over two, okay.

85
00:04:44.890 --> 00:04:49.570
Otherwise y is positive so
we'll just reduce(Frac(x, y).

86
00:04:49.570 --> 00:04:52.580
So now we've created fractions
that are in reduced form.

87
00:04:52.580 --> 00:04:56.720
If we want to add the two together, we're
going to assume they're in reduced form

88
00:04:56.720 --> 00:04:59.290
and make sure the result
is in reduced form.

89
00:04:59.290 --> 00:05:01.655
This is a great example for
nested pattern matching.

90
00:05:01.655 --> 00:05:03.190
If you have two whole numbers,

91
00:05:03.190 --> 00:05:05.990
return the whole number that's
the sum of those two numbers.

92
00:05:05.990 --> 00:05:09.980
If you have a whole number and a fraction,
it turns out if that fraction is already

93
00:05:09.980 --> 00:05:13.680
in reduced form, then so will be
the result of adding a whole number.

94
00:05:13.680 --> 00:05:17.120
So we can just return j+k*i,k.

95
00:05:17.120 --> 00:05:23.390
If you have two fractions, then we can
compute a new fraction as a*d + b*c, b*d.

96
00:05:23.390 --> 00:05:28.790
But then we need to reduce the result and
again this is a primary

97
00:05:28.790 --> 00:05:32.820
school arithmetic but I know I am always
a little forgetful on these things.

98
00:05:32.820 --> 00:05:36.580
It's okay if the exact arithmetic
is a little surprising to you.

99
00:05:36.580 --> 00:05:40.080
It's not really the point
of studying module systems.

100
00:05:40.080 --> 00:05:41.910
Okay.
And then finally we have this thing

101
00:05:41.910 --> 00:05:43.156
that prints out the string.

102
00:05:43.156 --> 00:05:44.720
Now this is very interesting.

103
00:05:44.720 --> 00:05:47.480
Because we keep all our
rationals in reduced form,

104
00:05:47.480 --> 00:05:49.150
we can just go ahead and print it.

105
00:05:49.150 --> 00:05:51.730
So if it's a whole number,
just convert it to a string.

106
00:05:51.730 --> 00:05:55.330
Excuse me, we're not actually printing
here, we're just converting to strings but

107
00:05:55.330 --> 00:05:58.720
then the REPL prints out our results,
so that's why I keep saying printing.

108
00:05:58.720 --> 00:06:02.314
And if you have a fraction
then just (Int.toString

109
00:06:02.314 --> 00:06:05.740
a) concatenate that with a slash and
(Int.toStrig b).

110
00:06:05.740 --> 00:06:07.844
So let me show you an example
of using all of this.

111
00:06:07.844 --> 00:06:13.232
[SOUND] And then we'll talk a little bit
more about the structure of our module.

112
00:06:13.232 --> 00:06:17.299
So there we go,
I've defined my whole module and

113
00:06:17.299 --> 00:06:22.471
now I could say val x =
Rational1.make_frac(9,6).

114
00:06:22.471 --> 00:06:26.798
All right and how about val y =

115
00:06:26.798 --> 00:06:33.386
Rational1.make_frac(-8,-2).

116
00:06:33.386 --> 00:06:36.390
And I'm just misspelled Rational1 in here.

117
00:06:38.920 --> 00:06:40.345
And misspelled make_frac.

118
00:06:40.345 --> 00:06:44.005
[SOUND]
Okay, there we go.

119
00:06:44.005 --> 00:06:48.983
Now we could say Rational1.add(x, y).

120
00:06:48.983 --> 00:06:54.099
And I could just immediately have
a Rational1.toString of that.

121
00:06:54.099 --> 00:06:59.436
[SOUND] And I get 11/2,
which is in fact three-halves plus 4,

122
00:06:59.436 --> 00:07:05.459
which is the reduced form of nine over
six and negative 8 over negative 2.

123
00:07:05.459 --> 00:07:08.030
So this is how I would use
the module as a client.

124
00:07:09.200 --> 00:07:11.010
So, that's the idea.

125
00:07:11.010 --> 00:07:12.060
We see the structure here.

126
00:07:12.060 --> 00:07:16.067
We define our data type, our exception and
these public functions make_frac, add and

127
00:07:16.067 --> 00:07:17.338
toString.

128
00:07:17.338 --> 00:07:20.550
Now I want to talk more about
how abstract data types

129
00:07:20.550 --> 00:07:22.878
are typically implemented with modules.

130
00:07:22.878 --> 00:07:27.950
And I want to focus on the specification
of the library in terms of

131
00:07:27.950 --> 00:07:33.280
properties and how it's implemented
in terms of invariants.

132
00:07:33.280 --> 00:07:37.890
So what I'm calling properties
are externally visible guarantees.

133
00:07:37.890 --> 00:07:43.240
Things that the library writer is
promising any clients of the library.

134
00:07:43.240 --> 00:07:46.970
Some of the things that this module
that I just showed you is promising,

135
00:07:46.970 --> 00:07:48.250
are the following.

136
00:07:48.250 --> 00:07:50.570
We will disallow any denominators of 0.

137
00:07:50.570 --> 00:07:54.100
If you go to make such a fraction,
we will raise an exception.

138
00:07:54.100 --> 00:07:57.710
You will never see a rational
with a denominator of zero.

139
00:07:57.710 --> 00:08:01.560
That all the strings we
return are in reduced form.

140
00:08:01.560 --> 00:08:06.290
Well you see 4, not 4/1 and 3/2 not 9/6.

141
00:08:06.290 --> 00:08:07.200
And that except for

142
00:08:07.200 --> 00:08:10.750
disallowing denominators of zero any time
you call a function it will terminate,

143
00:08:10.750 --> 00:08:14.480
it won't raise an exception,
it always produces the correct answer.

144
00:08:14.480 --> 00:08:17.990
So there are additional properties,
this is not a full specification but

145
00:08:17.990 --> 00:08:21.740
these are particular things
I want to emphasize that

146
00:08:21.740 --> 00:08:25.880
I'm going to say our library must do,
even though it's not in the types

147
00:08:25.880 --> 00:08:28.550
of the functions we're providing
like add and to string.

148
00:08:29.760 --> 00:08:32.590
Now that's all the outside
world should care about.

149
00:08:32.590 --> 00:08:37.130
Internally, our implementation is
maintaining some important invariants.

150
00:08:37.130 --> 00:08:40.830
And what this means is that all of
the functions are going to have to

151
00:08:40.830 --> 00:08:45.960
guarantee these extra things or
other functions might do the wrong thing.

152
00:08:45.960 --> 00:08:48.020
Now the outside world
should not care about this.

153
00:08:48.020 --> 00:08:53.840
These are implementation details but
they're things that are across the module

154
00:08:53.840 --> 00:08:58.300
so that one function can rely on
another function doing it correctly.

155
00:08:58.300 --> 00:09:01.730
So the first thing we're going to
require is in fact that all denominators

156
00:09:01.730 --> 00:09:03.090
are positive.

157
00:09:03.090 --> 00:09:08.150
So the outside world can make a fraction
with negative 8 and negative 2, but

158
00:09:08.150 --> 00:09:12.960
we'll return the fraction that doesn't
have a negative denominator, okay.

159
00:09:12.960 --> 00:09:16.240
And so
all of our functions can assume that.

160
00:09:16.240 --> 00:09:19.350
Second thing that's
internal invariant is that,

161
00:09:19.350 --> 00:09:22.420
all of the rational values
are already reduced.

162
00:09:22.420 --> 00:09:27.770
So we never even create a 9/6,
we immediately create a 3/2.

163
00:09:27.770 --> 00:09:33.080
So let me emphasize that our functions
are maintaining these invariants and

164
00:09:33.080 --> 00:09:35.710
relying on them in several places.

165
00:09:35.710 --> 00:09:39.500
So if you look back at the code,
you'll see a number of things.

166
00:09:39.500 --> 00:09:42.712
So you see that make_frac,
when we get started and

167
00:09:42.712 --> 00:09:46.310
we build a rational number,
explicitly disallows a 0.

168
00:09:46.310 --> 00:09:50.350
It had a special case to
remove a negative denominator,

169
00:09:50.350 --> 00:09:54.798
it immediately negated both
the numerator and the denominator.

170
00:09:54.798 --> 00:09:59.000
And it called reduce on the result to
make sure that we created a rational in

171
00:09:59.000 --> 00:09:59.650
reduced form.

172
00:10:00.730 --> 00:10:06.390
Then our add function assume that
the two arguments were in reduced form.

173
00:10:06.390 --> 00:10:11.110
And it actually used that to avoid calling
reduced in some cases where it did

174
00:10:11.110 --> 00:10:12.500
not need to.

175
00:10:12.500 --> 00:10:14.430
But in other cases, to be careful and

176
00:10:14.430 --> 00:10:20.100
to make sure it preserves the invariants,
it did call reduce, okay.

177
00:10:20.100 --> 00:10:24.430
We're relying on these invariants and
several other places as well.

178
00:10:24.430 --> 00:10:28.480
The gcd function is not correct for
negative arguments and there are certain

179
00:10:28.480 --> 00:10:34.240
places where we called gcd with arguments
that we only know are non negative.

180
00:10:34.240 --> 00:10:38.480
Because all of our module is
maintaining this invariant.

181
00:10:38.480 --> 00:10:41.600
And similarly, in toString,
remember toString,

182
00:10:41.600 --> 00:10:47.270
we promised the outside world would
always return things in reduced form.

183
00:10:47.270 --> 00:10:51.440
But toString didn't check for
that and did not call reduce,

184
00:10:51.440 --> 00:10:55.440
because it's relying on the invariant
in the rest of the module.

185
00:10:55.440 --> 00:11:00.510
So that's our example and now what we
want to do is use signatures to make

186
00:11:00.510 --> 00:11:05.500
sure that this properties and
invariants cannot be violated by clients.