WEBVTT

1
00:00:00.012 --> 00:00:03.942
[MUSIC] In this segment, 
I'm going to show you a third 

2
00:00:03.942 --> 00:00:09.987
implementation of rational numbers that 
will be equivalent to our other two, as 

3
00:00:09.987 --> 00:00:15.002
long as we keep the type abstract. 
And what I'm going to do here, is 

4
00:00:15.002 --> 00:00:18.782
actually change the implementation of the 
type rational, 

5
00:00:18.782 --> 00:00:23.441
in order to emphasize that when the type 
is abstract, an equivalent structure can 

6
00:00:23.441 --> 00:00:26.211
go ahead and change how the type is 
implemented. 

7
00:00:26.211 --> 00:00:30.583
So, given a signature that has an 
abstract type, different structures can 

8
00:00:30.583 --> 00:00:34.734
have that signature while implementing 
the type in different ways. 

9
00:00:34.734 --> 00:00:38.341
Those structures might or might, might 
not be equivalent. 

10
00:00:38.341 --> 00:00:42.710
I'll show you an example where they are. 
So I'm about to show you a third 

11
00:00:42.710 --> 00:00:48.106
implementation, rational 3 And in 
rational 3, the type rational is going to 

12
00:00:48.106 --> 00:00:52.245
be implemented as a type synonym with int 
* int. 

13
00:00:52.245 --> 00:00:56.392
So let's go over and see that. 
Here is my structure. 

14
00:00:56.392 --> 00:01:00.872
You'll see I have a type synonym here, so 
in the rest of this module, rational and 

15
00:01:00.872 --> 00:01:04.992
int * int are the same type. 
The outside world, however, doesn't have 

16
00:01:04.992 --> 00:01:08.107
to know that. 
So before I show you these functions, how 

17
00:01:08.107 --> 00:01:12.165
about I just show you, remind you, what 
the three signatures look like? 

18
00:01:12.165 --> 00:01:17.658
Now signature RATIONAL_A requires the 
module to implement rational as this data 

19
00:01:17.658 --> 00:01:20.644
type. 
Since our module does not, rational 3 

20
00:01:20.644 --> 00:01:25.376
does not have this signature. 
If we try to give it this signature, the 

21
00:01:25.376 --> 00:01:30.088
type checker will reject it. 
But it does have this second signature, 

22
00:01:30.088 --> 00:01:33.556
RATIONAL_B. 
As we'll see, we already saw it defines a 

23
00:01:33.556 --> 00:01:38.542
type rational. It defines it to equal int 
* int. That's a fine way to implement a 

24
00:01:38.542 --> 00:01:42.435
type rational. 
But, given that definition, it's going to 

25
00:01:42.435 --> 00:01:46.738
have to have these three functions, where 
rational is int * int. 

26
00:01:46.738 --> 00:01:51.194
The outside world, as usual, will not 
know that rational is int * int, 

27
00:01:51.194 --> 00:01:56.742
and then for RATIONAL_C it can have this 
signature, provided it has everything it 

28
00:01:56.742 --> 00:02:00.213
had before, as well as a function of type 
int arrow rational. 

29
00:02:00.213 --> 00:02:04.549
And I'll show you that at the end. 
So, let's see how struct rational 3 is 

30
00:02:04.549 --> 00:02:09.304
implemented and the fact that it can have 
type, the signature RATIONAL_B. 

31
00:02:09.304 --> 00:02:12.632
So rationals are now just pairs of ints, 
in all cases. 

32
00:02:12.632 --> 00:02:16.982
So here's make_frac. 
If the denominator is 0, raise an 

33
00:02:16.982 --> 00:02:20.407
exception. 
If y less than 0, then produce (-x,-y). 

34
00:02:20.407 --> 00:02:26.682
Just like before, but now it's just a 
pair of ints, there's no frac constructor 

35
00:02:26.682 --> 00:02:29.426
involved. 
Otherwise return (x,y). 

36
00:02:29.426 --> 00:02:33.767
Notice we're not treating whole numbers 
any differently. 

37
00:02:33.767 --> 00:02:38.354
So if this denominator is 1, then we'll 
just, return (x,y). 

38
00:02:38.354 --> 00:02:41.532
Okay? 
To add 2 fractions, well, add needs to 

39
00:02:41.532 --> 00:02:45.290
take 2 rationals. 
And each rational is an int * int, so 

40
00:02:45.290 --> 00:02:49.384
this pattern will do well. 
And, we're not going to reduce things. 

41
00:02:49.384 --> 00:02:54.414
That's an orthogonal choice, but like 
Rational2, we're just going to wait until 

42
00:02:54.414 --> 00:02:58.508
toString to reduce things. 
So we'll just return a*d + c*b in the 

43
00:02:58.508 --> 00:03:01.827
first position, and b*d in the second 
position. 

44
00:03:01.827 --> 00:03:07.002
And then finally, toString is a little 
more complicated, because we still want 

45
00:03:07.002 --> 00:03:12.277
to return everything in reduced form and 
treat whole numbers specially here. 

46
00:03:12.277 --> 00:03:17.402
So here's what you need to do, if x is 0, 
you have a numerator of 0, you better 

47
00:03:17.402 --> 00:03:22.079
return the string 0. 
Otherwise We have some more work to do 

48
00:03:22.079 --> 00:03:28.153
here with GCD and reduce. 
so here's a let fun gcd equal this in, 

49
00:03:28.153 --> 00:03:35.580
let's convert to a string the numerator 
concatenated with if the denominator is 

50
00:03:35.580 --> 00:03:41.835
one then don't do anything. 
Else, a slash, and then to string of the 

51
00:03:41.835 --> 00:03:45.017
denominator. 
So, I didn't empahasize this. 

52
00:03:45.017 --> 00:03:49.666
Up here, I've computed the num and the 
denominator, by dividing both by the gcd, 

53
00:03:49.666 --> 00:03:54.035
of the absolute value of x and y. 
So, a bunch of arithmetic, but the point 

54
00:03:54.035 --> 00:03:58.784
is, to not print the denominator, if the, 
if the numerator is 0, or if the 

55
00:03:58.784 --> 00:04:02.622
denominator is 1. 
And so overall, if we go back up here to 

56
00:04:02.622 --> 00:04:07.447
the signature RATIONAL_B, we've provided 
everything at the right type, 

57
00:04:07.447 --> 00:04:12.147
make_frac returned an int * int, 
add took two int * ints and returned an 

58
00:04:12.147 --> 00:04:15.147
int * int. 
And toString took and int * int and 

59
00:04:15.147 --> 00:04:18.841
returned a string. 
And then the outside world does not know 

60
00:04:18.841 --> 00:04:23.270
that rational is int star int. 
Now, if we want to implement Rational3, 

61
00:04:23.270 --> 00:04:27.557
we also need a function, of type int 
arrow rational. 

62
00:04:27.557 --> 00:04:32.838
This was this cute thing where, for our 
other structures, the data type binding 

63
00:04:32.838 --> 00:04:38.153
was providing this function, and then we 
are exposing just that part of the data 

64
00:04:38.153 --> 00:04:43.223
type binding to the outside world. 
Now, in our new structure we don't have a 

65
00:04:43.223 --> 00:04:46.847
data type binding, we don't have such a 
function being defined by it, 

66
00:04:46.847 --> 00:04:50.706
but we can still implement this signature 
provided we have this function. 

67
00:04:50.706 --> 00:04:54.747
And so, again, it's a little cute, but 
down here at the bottom, I just defined a 

68
00:04:54.747 --> 00:04:58.859
function whole, you're allowed to start 
functions with a capital letter if you 

69
00:04:58.859 --> 00:05:02.115
want to, 
that just takes in an i and returns this 

70
00:05:02.115 --> 00:05:06.049
rational, this int * int of (i,1), and it 
works great. 

71
00:05:06.049 --> 00:05:10.929
So, that is our third implementation. 
I want to emphasize, that when we do 

72
00:05:10.929 --> 00:05:16.410
signature matching of this structure, 
against either RATIONAL_B or RATIONAL_C, 

73
00:05:16.410 --> 00:05:19.562
a couple of interesting things are going 
on. 

74
00:05:19.562 --> 00:05:27.018
So let me emphasize those for you. 
the first is make_frac internally has 

75
00:05:27.018 --> 00:05:33.829
type int * int arrow int * int. 
And so that does match a signature where 

76
00:05:33.829 --> 00:05:38.236
we're exploding, exporting it as int * 
int arrow rational, because rational is 

77
00:05:38.236 --> 00:05:41.185
int * int. 
And the client will never be able to tell 

78
00:05:41.185 --> 00:05:45.951
that we're actually returning something 
of the same type we're taking in, because 

79
00:05:45.951 --> 00:05:48.825
the client doesn't know those are the 
same types. 

80
00:05:48.825 --> 00:05:54.337
Now what's interesting, is we could If we 
went back here to RATIONAL_B, we could 

81
00:05:54.337 --> 00:05:59.425
say that make_frac, instead of being 
int*int arrow rational, it's actually 

82
00:05:59.425 --> 00:06:03.866
rational arrow rational. 
Now this is a very bad signature. The 

83
00:06:03.866 --> 00:06:08.712
structure has this signature. 
The type checker will accept it. 

84
00:06:08.712 --> 00:06:14.247
But, the structure will be useless. 
Because if all the outside world knows is 

85
00:06:14.247 --> 00:06:19.649
that it can use these bindings, it's 
never going to be able to call make_frac, 

86
00:06:19.649 --> 00:06:24.957
add or toString, because it can never get 
its first rational to get started. 

87
00:06:24.957 --> 00:06:27.832
There's no way it can call any of these 
functions. 

88
00:06:27.832 --> 00:06:31.757
So there are programs out there that type 
check and are not useful. 

89
00:06:31.757 --> 00:06:35.822
Okay? So we really want to expose here 
that make_frac does take 2 ints as 

90
00:06:35.822 --> 00:06:38.842
arguments. 
So that's the first interesting thing. 

91
00:06:38.842 --> 00:06:42.002
The second interesting thing is this 
function, whole. 

92
00:06:42.002 --> 00:06:45.842
So let me go back and show that to you 
here at the bottom. 

93
00:06:45.842 --> 00:06:50.529
Based on what we know from type 
inference, this is going to have type 

94
00:06:50.529 --> 00:06:55.139
alpha arrow alpha * int. 
And that is indeed what the type checker 

95
00:06:55.139 --> 00:07:00.062
will give this function internally, when 
it goes to type check it. 

96
00:07:00.062 --> 00:07:04.987
But in our signature in RATIONAL_C, we 
said this had to have type int arrow 

97
00:07:04.987 --> 00:07:08.212
rational. 
And so somehow, the type checker, which 

98
00:07:08.212 --> 00:07:13.537
is fairly sophisticated and fairly smart, 
has to get from this first type to this 

99
00:07:13.537 --> 00:07:18.689
second type legally, and it turns out it 
can, because the rules of signature 

100
00:07:18.689 --> 00:07:23.378
matching let you take a polymorphic 
function and instantiate it to a 

101
00:07:23.378 --> 00:07:27.965
non-polymorphic function. 
So the first thing the type checker has 

102
00:07:27.965 --> 00:07:32.627
to figure out to do, for signature 
matching, is to realize that alpha can be 

103
00:07:32.627 --> 00:07:38.387
int, and therefore, this could also have 
typed the less flexible type, int arrow 

104
00:07:38.387 --> 00:07:41.287
int * int. 
We have to replace all the alphas 

105
00:07:41.287 --> 00:07:45.887
consistently, and now we see, that 
indeed, since rational inside the module 

106
00:07:45.887 --> 00:07:51.977
is int * int, we can, as we usually do, 
match this type against this type in the 

107
00:07:51.977 --> 00:07:56.822
signature, and its pretty neat that ML 
does that for us. 

108
00:07:56.822 --> 00:08:03.888
Notice that this does not have something 
like the type, alpha arrow int * int, or 

109
00:08:03.888 --> 00:08:08.577
you know, int arrow alpha * int. 
When you take a generic type, a 

110
00:08:08.577 --> 00:08:12.949
polymorphic type and make it less 
general, you have to replace all the 

111
00:08:12.949 --> 00:08:16.703
alphas with another type. 
The, this function hold does not have 

112
00:08:16.703 --> 00:08:19.960
these bottom two types, that doesn't make 
any sense. 

113
00:08:19.960 --> 00:08:24.627
It is not the case, that if you called 
whole with a string, you would get back 

114
00:08:24.627 --> 00:08:28.821
an int * int, so these types are just 
wrong and I will delete them. 

115
00:08:28.821 --> 00:08:33.685
It is interesting to me that inside this 
module, we actually could call whole with 

116
00:08:33.685 --> 00:08:38.423
a string for i, but outside the module, 
because of what the signature says, we 

117
00:08:38.423 --> 00:08:43.279
can only call it with an int, and 
therefore it will return irrational. 

118
00:08:43.279 --> 00:08:48.010
Okay? So, that is the more sophisticated 
and interesting details of this third 

119
00:08:48.010 --> 00:08:50.966
structure. 
But the high level point is that under 

120
00:08:50.966 --> 00:08:55.078
RATIONAL_B or RATIONAL_C, this structure 
is equivalent to our other two 

121
00:08:55.078 --> 00:08:58.009
structures, 
even though it implements the type 

122
00:08:58.009 --> 00:09:00.953
rational and in, and in an entirely 
different way. 