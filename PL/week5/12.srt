WEBVTT

1
00:00:00.000 --> 00:00:05.244
[MUSIC]

2
00:00:05.244 --> 00:00:08.955
I want to continue emphasizing
the importance of abstractions,

3
00:00:08.955 --> 00:00:10.982
signatures, and abstract types.

4
00:00:10.982 --> 00:00:14.447
By now showing you other
structures that have the same

5
00:00:14.447 --> 00:00:19.149
signatures as the ones we've seen already,
for our rational numbers.

6
00:00:20.220 --> 00:00:26.050
So a key purpose of abstraction, and of
using signatures and abstract data types,

7
00:00:26.050 --> 00:00:32.510
is to allow different implementations
of some functionality to be equivalent.

8
00:00:32.510 --> 00:00:34.070
What I mean by equivalent is,

9
00:00:34.070 --> 00:00:39.260
no client will ever be able to
tell which one you are using.

10
00:00:39.260 --> 00:00:43.350
If you can guarantee via abstraction
that clients can't tell,

11
00:00:43.350 --> 00:00:47.620
then you can take one implementation and
replace it with another one.

12
00:00:47.620 --> 00:00:51.300
Maybe that one has additional
functionality that doesn't change the old

13
00:00:51.300 --> 00:00:53.850
functionality, maybe it's faster.

14
00:00:53.850 --> 00:00:56.550
Maybe you just want to be
able to delay your choice of

15
00:00:56.550 --> 00:00:59.410
which implementation to use until later,
and

16
00:00:59.410 --> 00:01:03.219
have a guarantee that clients won't
break when you make the change.

17
00:01:04.220 --> 00:01:09.950
This is easier to do, it is more likely
that two structures are equivalent

18
00:01:09.950 --> 00:01:15.800
under a signature that reveals less,
compared to a signature that reveals more.

19
00:01:15.800 --> 00:01:18.980
So I'm going to show you two examples
of that, one in this segment and

20
00:01:18.980 --> 00:01:20.250
one in the next.

21
00:01:20.250 --> 00:01:23.886
The one in this segment is
going to be a structure that,

22
00:01:23.886 --> 00:01:29.437
like our Rational1 structure, can have
all three signatures we saw previously.

23
00:01:29.437 --> 00:01:34.281
It can have signature RATIONAL_A,
RATIONAL_B, or RATIONAL_C.

24
00:01:34.281 --> 00:01:40.435
And it will be equivalent to the previous
structure under RATIONAL_B or RATIONAL_C.

25
00:01:40.435 --> 00:01:43.820
It won't be equivalent, under RATIONAL_A.

26
00:01:43.820 --> 00:01:47.850
So let me tell you how this is different,
it's a fun example using rational numbers,

27
00:01:47.850 --> 00:01:50.250
I'll show you the code in just a second.

28
00:01:50.250 --> 00:01:55.246
The idea is that structure Rational2,
compared to structure

29
00:01:55.246 --> 00:01:59.687
Rational1, does not keep
rationals in reduced form.

30
00:01:59.687 --> 00:02:02.324
It goes ahead and let's the numerator and

31
00:02:02.324 --> 00:02:05.348
the denominator to be something like 9 and
6.

32
00:02:05.348 --> 00:02:09.074
But then the toString function
always reduces things,

33
00:02:09.074 --> 00:02:12.010
before it ever returns a string.

34
00:02:12.010 --> 00:02:13.500
Okay, so let me show you the code.

35
00:02:14.810 --> 00:02:19.100
Here it is, here is a structure Rational2,
it's a lot like the structure Rational1.

36
00:02:19.100 --> 00:02:21.875
It has the same data type binding,
the same exceptions.

37
00:02:21.875 --> 00:02:26.707
make_frac still raises an exception
if y = 0, still make sure

38
00:02:26.707 --> 00:02:32.160
there's no 0 denominator, but
it doesn't reduce the fraction.

39
00:02:32.160 --> 00:02:37.310
So if you call it with 4 and 2,
it'll just return frac(4,2).

40
00:02:37.310 --> 00:02:41.180
Similarly, add never
reduces anything either.

41
00:02:41.180 --> 00:02:43.070
You add two whole numbers,
you get a whole number.

42
00:02:43.070 --> 00:02:46.894
For any of the fraction cases,
we just multiply appropriately.

43
00:02:46.894 --> 00:02:53.348
In particular, frac(a,b) and frac(c,d)
will just return (a*d + b*c, b*d).

44
00:02:53.348 --> 00:02:58.250
Not worrying that, for example,
that two-thirds plus one-third,

45
00:02:58.250 --> 00:03:03.470
we would just end up saying,
I believe, nine-ninths, okay?

46
00:03:03.470 --> 00:03:05.372
It's fine, we'll deal with it later.

47
00:03:05.372 --> 00:03:10.280
In particular, toString is now the only
function that's using gcd and reduce.

48
00:03:10.280 --> 00:03:14.849
So I've gone ahead and made gcd and
reduce local helper functions of toString.

49
00:03:14.849 --> 00:03:19.400
And all toString does, down here in
the body of this let expression,

50
00:03:19.400 --> 00:03:24.080
is reduce its argument before
it converts it to a string.

51
00:03:24.080 --> 00:03:27.055
And I would argue that under
the properties or our specification,

52
00:03:27.055 --> 00:03:29.028
we're still doing everything correctly.

53
00:03:29.028 --> 00:03:32.524
We're not allowing denominators of 0, and

54
00:03:32.524 --> 00:03:36.578
when we return a string it
is always in reduced form.

55
00:03:36.578 --> 00:03:40.752
And this structure, which is different
in its implementation than our earlier

56
00:03:40.752 --> 00:03:45.030
structure, can have all three
signatures we've seen previously.

57
00:03:45.030 --> 00:03:46.970
Here's our first signature, and

58
00:03:46.970 --> 00:03:49.839
it does provide all of these
things at the correct type.

59
00:03:51.140 --> 00:03:55.280
Here is our second signature,
it does provide all these things.

60
00:03:55.280 --> 00:03:58.190
If it provides everything in RATIONAL_A,
it provides everything in RATIONAL_B.

61
00:03:58.190 --> 00:04:01.900
All we've done now,
is made this type abstract.

62
00:04:01.900 --> 00:04:04.744
And in terms of RATIONAL_C,
which is like RATIONAL_B,

63
00:04:04.744 --> 00:04:07.946
except that it has this function whole,
of type int to rational?

64
00:04:07.946 --> 00:04:09.965
Our structure does provide that,

65
00:04:09.965 --> 00:04:15.050
because it has the same data type
binding as our previous structure, okay.

66
00:04:15.050 --> 00:04:17.252
So now let's think about,

67
00:04:17.252 --> 00:04:21.950
if I add some program out there
that was using Rational1.

68
00:04:21.950 --> 00:04:26.685
And I went into that program, and
I replaced all the uses of Rational1 with

69
00:04:26.685 --> 00:04:31.250
Rational2, could the program
behave any differently?

70
00:04:31.250 --> 00:04:37.340
And the answer is, it depends on which
signature we give to those structures.

71
00:04:37.340 --> 00:04:41.887
So if we give both structures
the signature RATIONAL_A,

72
00:04:41.887 --> 00:04:45.148
then clients might behave differently.

73
00:04:45.148 --> 00:04:50.366
And this is because RATIONAL_A,
as we know, allows too much, it allows

74
00:04:50.366 --> 00:04:55.686
clients to use the Frac constructor
to build their on fractions directly.

75
00:04:55.686 --> 00:04:58.494
So if you had some client out there,

76
00:04:58.494 --> 00:05:04.302
that called
Rational1.toString(Rational1.Frac(9,6)),

77
00:05:04.302 --> 00:05:08.550
by violating the abstraction,
it would get 9/6.

78
00:05:08.550 --> 00:05:13.240
But if you replace all the Rational1's
with Rational2's, you'd get 3/2,

79
00:05:13.240 --> 00:05:18.110
because toString, in our new structure,
reduces its argument.

80
00:05:18.110 --> 00:05:23.140
So if you have two modules that give
different answers to the same argument,

81
00:05:23.140 --> 00:05:24.730
they're not equivalent, and

82
00:05:24.730 --> 00:05:28.880
you have to be much more careful
while replacing one with the other.

83
00:05:28.880 --> 00:05:33.540
But the fascinating thing is,
if you use RATIONAL_B or RATIONAL_C,

84
00:05:33.540 --> 00:05:38.429
there is no use of one module that leads
to any different result than the same

85
00:05:38.429 --> 00:05:40.073
use of the other module.

86
00:05:40.073 --> 00:05:45.874
And that basically follows from the fact
that the type rational is abstract.

87
00:05:45.874 --> 00:05:50.489
And given that the type is abstract, both
modules enforce the same properties, and

88
00:05:50.489 --> 00:05:54.370
given the same arguments,
always return the same result.

89
00:05:54.370 --> 00:05:59.310
So being able to replace one module
with another one becomes easier

90
00:05:59.310 --> 00:06:04.400
when you expose less, in particular,
when you make types abstract.

91
00:06:04.400 --> 00:06:06.820
And now we see an example of that.

92
00:06:06.820 --> 00:06:10.737
As one final point,
you might be wondering if under Rational2,

93
00:06:10.737 --> 00:06:14.085
it's okay to go ahead and
expose the Frac constructor,

94
00:06:14.085 --> 00:06:17.593
since toString is going to
reduce things to reduced form?

95
00:06:17.593 --> 00:06:21.724
And the answer is no, this would
still allow negative denominators or

96
00:06:21.724 --> 00:06:23.002
denominators of 0.

97
00:06:23.002 --> 00:06:28.440
So Rational2 is also incorrect if
you expose the Frac constructor,

98
00:06:28.440 --> 00:06:31.330
for most of the reasons
that Rational1 was.

99
00:06:31.330 --> 00:06:33.560
There's just a couple
reasons that Rational2,

100
00:06:33.560 --> 00:06:37.920
as an accident of how it's implemented,
now happens to handle correctly