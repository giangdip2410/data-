WEBVTT

1
00:00:00.012 --> 00:00:06.536
[MUSIC] The last major topic we will 
consider in this section is a deeper and 

2
00:00:06.536 --> 00:00:13.281
more precise understanding of when 2 
functions are the same, or I'll call them 

3
00:00:13.281 --> 00:00:17.034
equivalent. 
So this is important to look at 

4
00:00:17.034 --> 00:00:20.282
carefully. 
I'm not going to show you any new coding 

5
00:00:20.282 --> 00:00:23.279
idioms or clever new things or language 
constructs. 

6
00:00:23.279 --> 00:00:27.510
But it's such a fundamental idea in 
software engineering that I think it's 

7
00:00:27.510 --> 00:00:31.073
worth focusing on. 
we're going to see that you can replace 

8
00:00:31.073 --> 00:00:35.883
one function with another if you're very 
careful and you know what it means for 

9
00:00:35.883 --> 00:00:40.235
two things to be equivalent. 
And we'll see that things are more likely 

10
00:00:40.235 --> 00:00:45.327
to be equivalent when you are using more 
abstraction, and when you have fewer side 

11
00:00:45.327 --> 00:00:48.519
effects. 
If you can assume that other computations 

12
00:00:48.519 --> 00:00:53.699
don't do things like mutate references or 
print things out, then additional things 

13
00:00:53.699 --> 00:00:57.148
are equivalent. 
So let me motivate why we're looking at 

14
00:00:57.148 --> 00:00:59.982
this. 
I believe that developers, people 

15
00:00:59.982 --> 00:01:03.287
programming, think about equivalence all 
the time. 

16
00:01:03.287 --> 00:01:08.102
When you are maintaining code and you say 
oh, I have a nicer style way, I have a 

17
00:01:08.102 --> 00:01:12.817
nicer way to express this, what you're 
really saying is to express the same 

18
00:01:12.817 --> 00:01:17.842
thing, or to express an equivalent thing, 
no one would be able to tell that I did 

19
00:01:17.842 --> 00:01:21.736
this code clean up. 
You are also thinking about this all the 

20
00:01:21.736 --> 00:01:24.996
time when you're looking at backward 
compatibility. 

21
00:01:24.996 --> 00:01:29.859
Can I add new features without changing 
how this software behaves for any of the 

22
00:01:29.859 --> 00:01:33.305
old features? 
It still behaves equivalently for all old 

23
00:01:33.305 --> 00:01:36.775
possibilities. 
Code optimization whether manual when 

24
00:01:36.775 --> 00:01:40.482
you're writing the code or if you're 
implementing a language, 

25
00:01:40.482 --> 00:01:44.635
is all about equivalence. 
Can I speed up this code without changing 

26
00:01:44.635 --> 00:01:49.457
how it behaves on any inputs? And finally 
when we were studying our module system, 

27
00:01:49.457 --> 00:01:53.355
we did this a bit as well. 
Can an external client tell if I replace 

28
00:01:53.355 --> 00:01:57.791
this implementation with another 
implementation? Now, what we're going to 

29
00:01:57.791 --> 00:02:02.060
look at here is not necessarily related 
to modules or abstract types. 

30
00:02:02.060 --> 00:02:05.420
Instead what we'll do is say, here are 
two functions, 

31
00:02:05.420 --> 00:02:10.351
are they equivalent for all possible 
calls to them? So, maybe I'm implementing 

32
00:02:10.351 --> 00:02:13.074
a library. 
I don't know all the clients in my 

33
00:02:13.074 --> 00:02:15.933
library. 
I might be putting this code up on the 

34
00:02:15.933 --> 00:02:20.166
Internet for people to use. 
I want to be able to think about, could I 

35
00:02:20.166 --> 00:02:25.218
replace this function with this other 
function, without any possible call to 

36
00:02:25.218 --> 00:02:30.375
these functions, ever being able to tell? 
That's what equivalence is all about. 

37
00:02:30.375 --> 00:02:35.156
Now we need to define, what it means for 
2 functions to behave the same way. 

38
00:02:35.156 --> 00:02:40.409
And I will say, that they have the same 
observable behavior, if, given equivalent 

39
00:02:40.409 --> 00:02:45.332
arguments, they meet all of these bullet 
points, you see here on the slide. 

40
00:02:45.332 --> 00:02:48.807
Clearly they need to always return the 
same answer. 

41
00:02:48.807 --> 00:02:53.982
If 1 takes 3 and returns 7 and the other 
takes 3 and returns 8, this is no good. 

42
00:02:53.982 --> 00:02:58.332
Right? But that's not enough. 
They also have to have the same non 

43
00:02:58.332 --> 00:03:03.542
termination behavior if one of them 
doesn't terminate on 9 The other needs to 

44
00:03:03.542 --> 00:03:07.794
not terminate on nine. 
And similarly they need to terminate on 

45
00:03:07.794 --> 00:03:12.071
all the same arguments. 
They have to have any effects that they 

46
00:03:12.071 --> 00:03:17.082
have on mutable references that other 
parts of the program can see, be the 

47
00:03:17.082 --> 00:03:20.207
same. 
If one of them updates a reference to a 

48
00:03:20.207 --> 00:03:24.212
different value than the other does, 
then after the call completes, some other 

49
00:03:24.212 --> 00:03:28.352
code in the program might be able to tell 
that you replaced the first function with 

50
00:03:28.352 --> 00:03:31.702
the sec, second function. 
They have to have the same input/output 

51
00:03:31.702 --> 00:03:34.292
behavior. 
We can't have one printing something and 

52
00:03:34.292 --> 00:03:38.272
the other not printing the same thing. 
And then they have to raise the same 

53
00:03:38.272 --> 00:03:41.187
exceptions. 
We can't have one of them choose to raise 

54
00:03:41.187 --> 00:03:44.282
an exception in a situation where the 
other one doesn't. 

55
00:03:44.282 --> 00:03:48.367
And I may have even forgotten things 
here, but I think this is a pretty good 

56
00:03:48.367 --> 00:03:50.717
list. 
Alright? Now notice, it's going to be 

57
00:03:50.717 --> 00:03:55.405
easier for 2 functions to be equivalent 
if users of these functions cannot use 

58
00:03:55.405 --> 00:03:59.575
them with as many arguments. 
For example, if you have a nice strong 

59
00:03:59.575 --> 00:04:04.341
type system, that will ensure that say 
these functions only take string star 

60
00:04:04.341 --> 00:04:08.003
string as our units. 
And we don't have to think about, well 

61
00:04:08.003 --> 00:04:11.402
what would happen if someone passed an 
int instead, 

62
00:04:11.402 --> 00:04:13.837
because no such calls will ever type 
check. 

63
00:04:13.837 --> 00:04:18.462
We will also see that it's much easier 
for two functions to be equivalent if our 

64
00:04:18.462 --> 00:04:22.467
language is a functional language where 
there are fewer ways to make 

65
00:04:22.467 --> 00:04:25.682
side-effects. 
And, sometimes people even assume that 

66
00:04:25.682 --> 00:04:29.562
you won't make side-effects, even if the 
language allows them. 

67
00:04:29.562 --> 00:04:32.902
I'll show you an example of that in just 
a second. 

68
00:04:32.902 --> 00:04:35.787
Kay?' 
So, let's finish up this segment with a 

69
00:04:35.787 --> 00:04:41.355
few examples and then we'll move on to 
some more universal notions of function 

70
00:04:41.355 --> 00:04:44.847
equivalents. 
So on the top here I have 2 functions, f, 

71
00:04:44.847 --> 00:04:48.470
that are equivalent. 
The function on the left takes in an 

72
00:04:48.470 --> 00:04:52.156
argument, returns x + x. 
The one on the right takes in an argument 

73
00:04:52.156 --> 00:04:55.482
and returns y * x. 
This is defined in an environment where y 

74
00:04:55.482 --> 00:04:57.939
is 2. 
Both of these functions always double 

75
00:04:57.939 --> 00:05:00.731
their argument, they have no other side 
effects, 

76
00:05:00.731 --> 00:05:03.982
they always terminate, they are 
equivalent in every way. 

77
00:05:03.982 --> 00:05:08.251
No ML program using the function on the 
left would ever be able to tell if you 

78
00:05:08.251 --> 00:05:10.802
swapped it out for the function on the 
right. 

79
00:05:10.802 --> 00:05:15.899
And vice versa, so that's a good example. 
Here's an example where you might be 

80
00:05:15.899 --> 00:05:21.067
surprised that the two functions are not 
equivalent if we are not careful about 

81
00:05:21.067 --> 00:05:24.848
our assumptions. 
So the function on the left, g, takes in 

82
00:05:24.848 --> 00:05:29.742
a function f in argument x and returns f 
applied to x plus f applied to x. 

83
00:05:29.742 --> 00:05:34.617
The one on the right multiplies f applied 
to x by y and y is bound to 2. 

84
00:05:34.617 --> 00:05:39.767
So these will always return the same 
answer assuming f is a function that 

85
00:05:39.767 --> 00:05:45.472
always returns the same thing when given 
the same argument, but, the code on the 

86
00:05:45.472 --> 00:05:49.502
left calls f twice, and the code on the 
right calls f once. 

87
00:05:49.502 --> 00:05:52.508
And that is a problem if f could have 
side effects. 

88
00:05:52.508 --> 00:05:55.282
Suppose it increments a reference every 
time. 

89
00:05:55.282 --> 00:05:59.890
Well then the code on the left will set 
that reference to 2 more than it used to 

90
00:05:59.890 --> 00:06:01.988
have. 
The code on the right 1 more. 

91
00:06:01.988 --> 00:06:05.682
An even simpler example is if f always 
prints something out. 

92
00:06:05.682 --> 00:06:10.237
Like this function here, if you pass this 
for f, it prints out "hi", and then 

93
00:06:10.237 --> 00:06:13.600
returns it's argument. 
The code on the left will print "hi" 

94
00:06:13.600 --> 00:06:16.467
twice, the code on the right will print 
"hi" once. 

95
00:06:16.467 --> 00:06:20.599
So, when you are in a functional 
programming language, we typically have 

96
00:06:20.599 --> 00:06:23.056
functions that don't do this sort of 
thing. 

97
00:06:23.056 --> 00:06:26.898
And if you assume these things don't 
happen, then the functions are 

98
00:06:26.898 --> 00:06:29.900
equivalent. 
Some languages, like haskell is a good 

99
00:06:29.900 --> 00:06:33.375
example force a notion of pure functional 
programming. 

100
00:06:33.375 --> 00:06:37.974
Most functions in the language, those 
that you can pass to other functions like 

101
00:06:37.974 --> 00:06:42.559
this, cannot do things like print out. 
And as a result, the corresponding code 

102
00:06:42.559 --> 00:06:46.429
in a language like haskell is equivalent 
on the left and the right. 

103
00:06:46.429 --> 00:06:51.214
So this is sort of yet another advantage 
of avoiding side effects in your code. 

104
00:06:51.214 --> 00:06:54.897
Let's do one more example. 
Here are, is a slight, it's, it's a few 

105
00:06:54.897 --> 00:06:58.516
more lines of code but it's actually very 
simple what's going on. 

106
00:06:58.516 --> 00:07:03.297
The function f here on the left, assumes 
we have in our environment some functions 

107
00:07:03.297 --> 00:07:05.979
g and h. 
it calls g with x, calls h with x and 

108
00:07:05.979 --> 00:07:09.881
returns a pair of the results. 
The code on the right is the exact same, 

109
00:07:09.881 --> 00:07:12.922
except it just calls h and g in the 
opposite order. 

110
00:07:12.922 --> 00:07:17.392
So unlike in the previous example, 
there's no number of calls problem here. 

111
00:07:17.392 --> 00:07:19.812
Both of these call g once and call h 
once. 

112
00:07:19.812 --> 00:07:24.462
So are they equivalent? Again if g and h 
are pure functions that don't have side 

113
00:07:24.462 --> 00:07:28.997
effects, they just compute something and 
return a result, then yes, they're 

114
00:07:28.997 --> 00:07:32.375
equivalent. 
But if g and h can have side effects, 

115
00:07:32.375 --> 00:07:36.833
then no, not necessarily. 
Suppose g prints something and h prints 

116
00:07:36.833 --> 00:07:40.419
something. 
Well then the code on the left will print 

117
00:07:40.419 --> 00:07:45.043
those outputs in one order, 
the code on the right will print them in 

118
00:07:45.043 --> 00:07:48.017
the opposite order. 
Here's another example. 

119
00:07:48.017 --> 00:07:53.283
Suppose g sets some mutable reference, 
and h reads that same mutable reference. 

120
00:07:53.283 --> 00:07:58.088
Then the code on left h is going to see 
the new value after whatever g wrote to 

121
00:07:58.088 --> 00:08:00.816
it. 
And in the code on the right, h is going 

122
00:08:00.816 --> 00:08:03.412
to see the value before g does it's 
write. 

123
00:08:03.412 --> 00:08:08.460
Because h executes, before g executes. 
So once you have mutation, side effects, 

124
00:08:08.460 --> 00:08:12.536
printing, we suddenly have to worry about 
the order we do things, 

125
00:08:12.536 --> 00:08:16.631
and different orders, lead to functions 
that are not equivalent. 

126
00:08:16.631 --> 00:08:21.353
But if we stick to a functional style, 
where don't write functions with side 

127
00:08:21.353 --> 00:08:24.475
efefects, 
then we do not have to worry about order, 

128
00:08:24.475 --> 00:08:27.348
and we can execute these functions in 
either order. 

129
00:08:27.348 --> 00:08:30.579
With one final caveat. 
That if g of x, and h of x both raise 

130
00:08:30.579 --> 00:08:33.133
exceptions, and raise different 
exceptions. 

131
00:08:33.133 --> 00:08:37.340
Then the order could matter again. 
And, the code on the left would raise one 

132
00:08:37.340 --> 00:08:41.044
exception, and the code on the right 
would raise another exception. 