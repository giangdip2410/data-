WEBVTT

1
00:00:05.300 --> 00:00:08.090
In this segment we're going to
work through a couple examples

2
00:00:08.090 --> 00:00:10.180
completely to show type inference.

3
00:00:10.180 --> 00:00:11.690
Before we get to the examples,

4
00:00:11.690 --> 00:00:15.050
let's make sure we remember
the key steps here, right?

5
00:00:15.050 --> 00:00:18.570
The idea is to just collect
all the facts we need.

6
00:00:18.570 --> 00:00:21.930
All the facts that have to be true for
something to type-check, and

7
00:00:21.930 --> 00:00:25.200
use those to constrain
the type of the function.

8
00:00:25.200 --> 00:00:27.330
So we're going to do two examples.

9
00:00:27.330 --> 00:00:30.150
Neither of these examples will
involve polymorphism, and

10
00:00:30.150 --> 00:00:34.390
then I'll change one of the examples so,
in fact, it doesn't type check at all, and

11
00:00:34.390 --> 00:00:37.650
we'll see how type inference
can figure that out as well.

12
00:00:37.650 --> 00:00:42.120
So, for the rest of the segment,we'll just
do this over here in the Emacs buffer, and

13
00:00:42.120 --> 00:00:43.280
here's our first example.

14
00:00:43.280 --> 00:00:46.930
It's a fairly silly code that
just takes in a pair of ints and

15
00:00:46.930 --> 00:00:49.290
adds them with absolute value and
what not.

16
00:00:49.290 --> 00:00:52.780
Of course, type inference doesn't
really reason about what the code does,

17
00:00:52.780 --> 00:00:55.350
it just collects facts for type checking.

18
00:00:55.350 --> 00:00:59.500
So it sees a function binding f, and
the first thing it realizes is for

19
00:00:59.500 --> 00:01:04.510
some types, t1 and t2,
f has to have type t1 arrow t2.

20
00:01:04.510 --> 00:01:07.110
Why?
Well, it must be a function, and

21
00:01:07.110 --> 00:01:11.200
we know all functions take one argument.

22
00:01:11.200 --> 00:01:12.410
So, that just has to be.

23
00:01:12.410 --> 00:01:16.690
And in fact, if we look at the pattern,
which is just a variable here for

24
00:01:16.690 --> 00:01:19.440
that argument, x has to have type T1.

25
00:01:19.440 --> 00:01:22.800
There's no other way this function
binding is going to type check.

26
00:01:22.800 --> 00:01:27.390
So now we can go on to the function body
to start gathering additional constraints,

27
00:01:27.390 --> 00:01:30.520
and we first see this binding here,
and we say, okay,

28
00:01:30.520 --> 00:01:34.280
I have two other variables I'm going
to have to figure out types for.

29
00:01:34.280 --> 00:01:37.020
So y is going to have to
have some type t3 and

30
00:01:37.020 --> 00:01:38.600
z is going to have to have some type t4.

31
00:01:38.600 --> 00:01:43.980
And now we can start looking at all the
expressions and patterns in our program

32
00:01:43.980 --> 00:01:50.020
to come up with additional constraints
among these types, t1, t2, and t3 and t4.

33
00:01:50.020 --> 00:01:56.140
So the first thing we see from the pattern
match is that T1 has to be T3 star T4.

34
00:01:56.140 --> 00:01:57.230
There's no other way for

35
00:01:57.230 --> 00:02:01.840
this pattern where we match X
against Y comma Z to type check.

36
00:02:01.840 --> 00:02:06.570
So, else pattern match
does not type check.

37
00:02:06.570 --> 00:02:10.520
We can write down these reasons as we go
just to keep track of what we're doing.

38
00:02:10.520 --> 00:02:14.911
Okay, so the next thing we could
look at is this function call here.

39
00:02:14.911 --> 00:02:19.481
Now, remember, we've already type
checked all earlier bindings,

40
00:02:19.481 --> 00:02:24.205
including things that are built into
the environment, and so we already

41
00:02:24.205 --> 00:02:28.695
know that abs has type int arorw int,
and so for abs of Y to type check,

42
00:02:28.695 --> 00:02:33.130
Y is going to have to have type int,
which means T3 has to equal int.

43
00:02:33.130 --> 00:02:36.534
T3 being the type of y, T3 equals int..

44
00:02:36.534 --> 00:02:40.430
All right, and that's everything
we get from this construct here.

45
00:02:40.430 --> 00:02:43.800
Fortunately, getting int back
because plus will require that,

46
00:02:43.800 --> 00:02:47.960
and that means that this expression
over here will have to be an int, and

47
00:02:47.960 --> 00:02:51.740
since that's z,
we know that T4 has the equal int.

48
00:02:52.760 --> 00:02:53.550
Ha!

49
00:02:53.550 --> 00:02:59.570
This is because we added z to an int,
okay?

50
00:02:59.570 --> 00:03:04.439
So given those three constraints, T1,
our argument type to our function is int

51
00:03:04.439 --> 00:03:08.028
star int, and
we've already inferred the argument type.

52
00:03:08.028 --> 00:03:13.621
Now, in terms of the result type,
we have that abs of y plus z has type int,

53
00:03:13.621 --> 00:03:19.398
so the let expression has type int, so
the body of our function has type int,

54
00:03:19.398 --> 00:03:24.271
and we know that T2 has to be
the type of the body of the function,

55
00:03:24.271 --> 00:03:29.056
so T2 has to equal int and
once we've constrained T1 and T2,

56
00:03:29.056 --> 00:03:34.379
that's the type of F, which is what
we were supposed to be inferring,

57
00:03:34.379 --> 00:03:37.020
and we have our result.

58
00:03:37.020 --> 00:03:38.470
So we just gathered facts and

59
00:03:38.470 --> 00:03:43.580
continued to propagate those constraints
until we had the type we needed for F.

60
00:03:45.250 --> 00:03:48.110
So now let's go on and
do a more interesting function.

61
00:03:48.110 --> 00:03:50.953
A function that's actually useful for
something, and

62
00:03:50.953 --> 00:03:53.660
that's summing all the elements in a list.

63
00:03:53.660 --> 00:03:56.730
So, it's going to start
the same way sum is a function,

64
00:03:56.730 --> 00:03:59.480
so it has to have type T1 arrow T2.

65
00:03:59.480 --> 00:04:01.670
The argument has to be that T1.

66
00:04:01.670 --> 00:04:02.750
Okay?

67
00:04:02.750 --> 00:04:06.130
And now, we're just going to look at
these three lines, which actually have

68
00:04:06.130 --> 00:04:09.779
quite a bit of information about
what T1 and T2 need to be.

69
00:04:10.870 --> 00:04:17.080
So first, because we pattern match a T1,

70
00:04:18.200 --> 00:04:23.892
we know that these other variables x
in that pattern has to have type T3,

71
00:04:23.892 --> 00:04:29.570
and xs' has to have type T3 list.

72
00:04:29.570 --> 00:04:31.660
And the reason why, sorry,

73
00:04:31.660 --> 00:04:37.480
excuse me, is that if we have this
pattern here it can only match lists.

74
00:04:37.480 --> 00:04:40.350
We know the second thing
has to be some list, and

75
00:04:40.350 --> 00:04:41.930
the first thing has to be
an element of the list.

76
00:04:41.930 --> 00:04:46.002
So that have to be related like this,
and in fact T1,

77
00:04:46.002 --> 00:04:51.350
because we are pattern matching
against x's, has to equal T3 list.

78
00:04:51.350 --> 00:04:53.913
There's no other way for
just the patterns,

79
00:04:53.913 --> 00:04:57.365
just the things on the left of
the arrow to type check, okay?

80
00:04:57.365 --> 00:05:02.415
So now we can look at this first branch
here, and we can say, oh, in fact,

81
00:05:02.415 --> 00:05:07.546
since zero has type int, and that has
to be the type of the case expression,

82
00:05:07.546 --> 00:05:12.353
and the case expression is the function
body, we can know already that

83
00:05:12.353 --> 00:05:16.698
the return type has to be int,
because zero might be returned.

84
00:05:16.698 --> 00:05:18.107
Okay, so we know our result type.

85
00:05:18.107 --> 00:05:21.450
Now we just have to look
at this other branch and

86
00:05:21.450 --> 00:05:24.036
figure out what's going on there.

87
00:05:24.036 --> 00:05:29.600
So we know that T3 has to equal int, why?

88
00:05:29.600 --> 00:05:36.102
Because x has type T3,
and we add x to something.

89
00:05:36.102 --> 00:05:38.179
Okay, so we see that just from here,

90
00:05:38.179 --> 00:05:41.798
I'm ignoring here by the way
the plus works on type real as well,

91
00:05:41.798 --> 00:05:45.973
that's an issue I'm going to ignore
in this segment, but that's okay.

92
00:05:45.973 --> 00:05:51.839
So we have quite a bit here,
we just have to deal with the sum of xs'.

93
00:05:51.839 --> 00:05:56.425
And in fact, everything we already
know is enough to type check this.

94
00:05:56.425 --> 00:06:03.140
So we know T3 is int, we know xs'' is
a T3 list, so this has to be an int list.

95
00:06:03.140 --> 00:06:07.130
And int list is T3 list, which is T1.

96
00:06:07.130 --> 00:06:11.300
That is the argument of sums, so
this recursive call already type-checks.

97
00:06:11.300 --> 00:06:13.800
This recursive call has to give back a T2.

98
00:06:13.800 --> 00:06:18.460
We know T2 is int, and that's good
because that's the argument to plus.

99
00:06:18.460 --> 00:06:20.570
So it turns out we don't
get any new facts here.

100
00:06:20.570 --> 00:06:23.260
We already had all the facts we needed.

101
00:06:23.260 --> 00:06:27.300
And it turns out that just
from T1 equaling T3 list and

102
00:06:27.300 --> 00:06:31.760
T3 equaling int,
we know T3 equals int list.

103
00:06:31.760 --> 00:06:37.160
And from that and T2 equals int,
we know that F has typed int list

104
00:06:37.160 --> 00:06:40.640
arrow int, just like we need and
just like we want sum to have.

105
00:06:41.730 --> 00:06:43.780
So that's our second example.

106
00:06:43.780 --> 00:06:46.330
Now what I'm going to do
is break this example, so

107
00:06:46.330 --> 00:06:48.040
that nothing I did here is wrong.

108
00:06:48.040 --> 00:06:49.190
This is correct.

109
00:06:49.190 --> 00:06:53.680
Now let's go and change our code and see
what type inference would do in that case.

110
00:06:53.680 --> 00:06:55.370
So I'm going to make a mistake here.

111
00:06:55.370 --> 00:06:57.030
A mistake that will not type check.

112
00:06:57.030 --> 00:06:59.320
If I make this mistake,
it will type check.

113
00:06:59.320 --> 00:07:01.090
It will just be an infinite loop.

114
00:07:01.090 --> 00:07:03.240
I'm more interested in this mistake,

115
00:07:03.240 --> 00:07:06.830
where I try to recursively call
sum with the head of the list.

116
00:07:06.830 --> 00:07:09.330
This is in fact,
now not going to type check.

117
00:07:09.330 --> 00:07:10.820
So let's see why.

118
00:07:10.820 --> 00:07:12.300
Everything starts how it did before.

119
00:07:12.300 --> 00:07:14.762
Sum still has to be a T1 arrow T2.

120
00:07:14.762 --> 00:07:17.158
xs still has to be that argument type.

121
00:07:17.158 --> 00:07:21.272
x and xs' still have to have
the form T3 and T3 list for

122
00:07:21.272 --> 00:07:26.460
some type T3, because they
are part of a list pattern, okay.

123
00:07:26.460 --> 00:07:31.530
We still have that T1 has to equal
T3 list, and that's because of

124
00:07:31.530 --> 00:07:36.580
xs being pattern matched
against x colon colon xs'.

125
00:07:36.580 --> 00:07:41.810
We still have the T2 as equal int, because
of the zero here that's returning it.

126
00:07:41.810 --> 00:07:45.430
We still have to have the T3 as int,
because we're adding it right here.

127
00:07:46.550 --> 00:07:49.080
And now we're in a very
interesting situation.

128
00:07:49.080 --> 00:07:53.500
So let me delete this, and
just focus in on this sum of X.

129
00:07:53.500 --> 00:08:01.180
So we know from T1 equals T3 list, and T3
equals int, that T1 has to equal int list.

130
00:08:01.180 --> 00:08:03.880
All right?

131
00:08:03.880 --> 00:08:06.500
We also know that T3 equals int.

132
00:08:07.810 --> 00:08:10.510
And that is the type of x.

133
00:08:10.510 --> 00:08:14.700
So now I have to try to call
something that needs an int list,

134
00:08:14.700 --> 00:08:17.120
with something of type int.

135
00:08:17.120 --> 00:08:18.300
And that cannot type check.

136
00:08:18.300 --> 00:08:22.570
There is no way to set up additional
constraints if that's going to work out.

137
00:08:22.570 --> 00:08:26.920
So, I'm going to expect an error message
from the type checker, something along

138
00:08:26.920 --> 00:08:33.080
the lines of I think x has type int and
I think some needs an int list.

139
00:08:33.080 --> 00:08:35.890
Now, that's how we did
type inference here, and

140
00:08:35.890 --> 00:08:39.400
that's the sort of error message we
would get if we went in this order.

141
00:08:39.400 --> 00:08:42.980
But the type inferencer sometimes
has a bit of a mind of its own,

142
00:08:42.980 --> 00:08:48.250
if you will, in the sense that it can
gather constraints in any order it likes

143
00:08:48.250 --> 00:08:53.210
that will not affect its final result,
which is a deep property that's very cool.

144
00:08:53.210 --> 00:08:55.730
But it will report an error as soon as it

145
00:08:55.730 --> 00:08:59.070
gets to a situation where it
reaches the sort of contradiction.

146
00:08:59.070 --> 00:09:01.970
The sort of thing where it says
int has to the equal int list, and

147
00:09:01.970 --> 00:09:03.680
I know that's impossible.

148
00:09:03.680 --> 00:09:08.220
So in fact when I try this out, I think
we'll see a different error message

149
00:09:08.220 --> 00:09:11.430
in a different place in the code,
and that's okay.

150
00:09:11.430 --> 00:09:16.290
I mean, you might not like it, but in some
sense, there are too many facts here for

151
00:09:16.290 --> 00:09:18.140
them all to be true, and

152
00:09:18.140 --> 00:09:21.720
the type error message is just going
to tell you about one of them.

153
00:09:21.720 --> 00:09:26.340
So, if it goes in a slightly different
order, I think it actually complains

154
00:09:26.340 --> 00:09:31.360
about case objects and
rules don't agree, it says that the,

155
00:09:33.090 --> 00:09:37.480
I think what it's saying is that it
thought this was going to be a list, and

156
00:09:37.480 --> 00:09:40.540
something else was an int,
honestly, I'm not really sure.

157
00:09:40.540 --> 00:09:44.670
I can try to fix that by putting in
type annotations or what not, but

158
00:09:44.670 --> 00:09:50.040
it's actually complaining up
here that it figured out that

159
00:09:50.040 --> 00:09:55.200
xs is going to have to have type int,
because of how we called it down here.

160
00:09:55.200 --> 00:09:57.460
But now you're matching
it against an int list.

161
00:09:57.460 --> 00:10:01.420
So all it really did, if I had to guess,
was it worked on these facts

162
00:10:01.420 --> 00:10:05.420
before the pattern matching facts, so
you got a different error message.

163
00:10:05.420 --> 00:10:08.670
But it always detects,
because this is how type inference works,

164
00:10:08.670 --> 00:10:13.010
that there's no way for the entire thing
to type check, and so it gives you one

165
00:10:13.010 --> 00:10:18.340
error message about where it ran out of
room to try to figure out a good answer.

166
00:10:18.340 --> 00:10:21.270
Okay, so that's our examples of
working through type inference.

167
00:10:21.270 --> 00:10:25.400
We'll see more examples next, where we're
going to end up with polymorphic types for

168
00:10:25.400 --> 00:10:26.430
the results of our function.