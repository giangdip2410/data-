WEBVTT

1
00:00:00.012 --> 00:00:06.835
As we begin our study of type inference I 
want to start by making sure whereas 

2
00:00:06.835 --> 00:00:13.554
clear as we can be about what type 
inference is and what problem its trying 

3
00:00:13.554 --> 00:00:17.056
to solve. 
So, when you have type-checking at 

4
00:00:17.056 --> 00:00:22.833
compile time, which is called static 
type-checking, it lets us reject programs 

5
00:00:22.833 --> 00:00:27.557
before we ever run them. 
And we do this to prevent the possibility 

6
00:00:27.557 --> 00:00:30.940
of some errors. 
So statistically typed programming 

7
00:00:30.940 --> 00:00:33.928
languages are languages that have this 
feature. 

8
00:00:33.928 --> 00:00:38.766
So you might have some function that does 
not type check because potentially it 

9
00:00:38.766 --> 00:00:41.982
might say try to call a number, treat a 
number as. 

10
00:00:41.982 --> 00:00:46.622
The function.We don't actually have to 
execute the function to get that error, 

11
00:00:46.622 --> 00:00:51.017
we get that error before we ever run a 
program.Conversely dynamically type 

12
00:00:51.017 --> 00:00:55.577
languages do little or perhaps none of 
that's what of checking so, you have to 

13
00:00:55.577 --> 00:01:00.297
actually not just call the function but 
actually get the particular problematic 

14
00:01:00.297 --> 00:01:03.615
expression. 
To evaluate with variables bound to the 

15
00:01:03.615 --> 00:01:06.546
right things before you see the potential 
error. 

16
00:01:06.546 --> 00:01:11.491
Now the relative advantages of static and 
dynamic type-checking is a major concept 

17
00:01:11.491 --> 00:01:16.099
in the course and we're going to study it 
but I want to do that after we've used 

18
00:01:16.099 --> 00:01:19.492
the dynamically typed programming 
language for a while. 

19
00:01:19.492 --> 00:01:23.005
And Racket is one so we'll be in good 
shape Right there. 

20
00:01:23.005 --> 00:01:27.408
At this point we've only seen ML and ML 
like Java, C, Scala etc. 

21
00:01:27.408 --> 00:01:31.739
is statically typed. 
It has this property that certain things 

22
00:01:31.739 --> 00:01:36.957
don't type check even before we run them. 
And what all of these statically typed 

23
00:01:36.957 --> 00:01:41.207
languages have in common is every 
variable we introduce is given a type. 

24
00:01:41.207 --> 00:01:45.157
Every binding has some type. 
And for the scope that it's usable, it 

25
00:01:45.157 --> 00:01:48.577
maintains that type and can only hold 
values of that type. 

26
00:01:48.577 --> 00:01:52.812
So we keep our strings, and our booles, 
and our functions and out tuples 

27
00:01:52.812 --> 00:01:56.251
separate. 
Now the reason why I'm emphasizing this 

28
00:01:56.251 --> 00:02:01.487
is that, even though ML is statically 
typed, it is implicitly typed. 

29
00:02:01.487 --> 00:02:06.826
Ever since the beginning of section 2 or 
so, we have not been writing down the 

30
00:02:06.826 --> 00:02:11.537
types of any of our variables. 
We never did for valve bindings, and only 

31
00:02:11.537 --> 00:02:16.107
at the beginning of the course when you 
were using hash 1 and hash 2, did we for 

32
00:02:16.107 --> 00:02:19.942
arguments to a function. 
So just because ml is implicitly typed, 

33
00:02:19.942 --> 00:02:24.262
it can sometimes be confusing to remember 
that it is statically typed. 

34
00:02:24.262 --> 00:02:29.386
In this first function here f, the 2 
variables f and x both have a type. 

35
00:02:29.386 --> 00:02:34.781
F has type n 0 int, x has type int and 
they're just as statically typed as if 

36
00:02:34.781 --> 00:02:39.823
this were Java or C, where we have to 
write down the types of all of our 

37
00:02:39.823 --> 00:02:44.713
variables when we introduce them. 
That is why when we have a function like 

38
00:02:44.713 --> 00:02:49.157
g we under put the type error, the reason 
for the type error here is that one of 

39
00:02:49.157 --> 00:02:53.526
the type checking rules in and all is 
that the then branch and the else branch 

40
00:02:53.526 --> 00:02:56.312
of the conditional have to have the same 
type. 

41
00:02:56.312 --> 00:03:00.867
So that, that can be the type of the 
entire if expression and in this case 

42
00:03:00.867 --> 00:03:05.607
therefore the return type of g and so 
when these don't match like a bull here 

43
00:03:05.607 --> 00:03:10.022
and a int here we get a type error.This 
is exactly the sort of thing in a 

44
00:03:10.022 --> 00:03:14.827
dynamically typed language I would expect 
to be allowed and depending on the 

45
00:03:14.827 --> 00:03:20.123
argument to g you either get back a bull. 
Or an int, okay, so in that sense of 

46
00:03:20.123 --> 00:03:26.688
static type checking ML is more like Java 
or C and less like JavaScript or Python. 

47
00:03:26.688 --> 00:03:32.345
So what then is the type inference 
problem? The type inference problem is 

48
00:03:32.345 --> 00:03:37.816
take a program, like we saw in the 
previous slide, and try to give every 

49
00:03:37.816 --> 00:03:42.317
variable and binding and expression in 
that program a type. 

50
00:03:43.450 --> 00:03:48.278
Such that, if you wrote down all those 
types, type checking would succeed. 

51
00:03:48.278 --> 00:03:52.985
So we need to infer all the types such 
that the program would type check. 

52
00:03:52.985 --> 00:03:58.059
If we cannot do so, if it is impossible 
to give such types, like in that second 

53
00:03:58.059 --> 00:04:02.779
example where true and x * 2 simply do 
not have the same type, then it's the 

54
00:04:02.779 --> 00:04:06.725
role of type inference to fail, and 
presumably give some sort of error 

55
00:04:06.725 --> 00:04:09.381
message. 
So, in principle, you could set it up 

56
00:04:09.381 --> 00:04:12.818
exactly like this. 
You could have a type inference procedure 

57
00:04:12.818 --> 00:04:17.124
that wrote down the types for everything, 
and then have a type checker, that 

58
00:04:17.124 --> 00:04:20.586
checked those types. 
In practice, and in implementation of a 

59
00:04:20.586 --> 00:04:24.321
language like SML, we often don't 
separate things out so cleanly. 

60
00:04:24.321 --> 00:04:27.932
We just have the type inferencer and type 
checker be the same. 

61
00:04:27.932 --> 00:04:31.273
Staying, and either your program 
type-checks, or it does not. 

62
00:04:31.273 --> 00:04:35.352
The last thing I want to emphasize, 
before the next segment, when we get into 

63
00:04:35.352 --> 00:04:39.613
type inference for ML, this segment was 
really about type inference in general, 

64
00:04:39.613 --> 00:04:42.399
and what it is. 
As the type inference can be easy, or 

65
00:04:42.399 --> 00:04:47.507
difficult, or impossible, it depends, on 
the type system, that That you're trying 

66
00:04:47.507 --> 00:04:52.132
to infer types four. 
So as 2 extreme view points if if every 

67
00:04:52.132 --> 00:04:55.782
program type checks, that's very easy to 
infer. 

68
00:04:55.782 --> 00:05:01.712
Just say yes, if no program type checks 
that's also easy to infer, just say no. 

69
00:05:01.712 --> 00:05:06.573
So type inference doesn't get easier or 
harder necessarily by having a type 

70
00:05:06.573 --> 00:05:10.567
system that accepts more programs or 
excepts fewer programs. 

71
00:05:10.567 --> 00:05:15.143
It's not so simply to figure that out. 
This is part of the difficulty of 

72
00:05:15.143 --> 00:05:17.857
language design if you want type 
inference. 

73
00:05:17.857 --> 00:05:21.942
But the reason why we're going to study 
ML type inference is that it is a bit 

74
00:05:21.942 --> 00:05:26.267
subtle, but it's also extremely elegant, 
and it may at this point in the course 

75
00:05:26.267 --> 00:05:29.252
seem magical. 
We've seen these polymorphic types sort 

76
00:05:29.252 --> 00:05:33.577
of inferred for us, but through a series 
of examples I want to convince you that 

77
00:05:33.577 --> 00:05:36.945
it's actually a fairly elegant and 
straightforward procedure. 