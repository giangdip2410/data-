WEBVTT

1
00:00:00.012 --> 00:00:09.068
[MUSIC] This segment is about mutual 
recursion. 

2
00:00:09.068 --> 00:00:18.174
It's a small topic that we just didn't 
need before, but, it would be a mistake 

3
00:00:18.174 --> 00:00:18.174
to move on from ML without discussing it. 
Mutual recursion is just when you have 

4
00:00:18.174 --> 00:00:18.862
two or more functions that need to call 
each other. 

5
00:00:18.862 --> 00:00:23.049
So what if you wanted to have f call g 
sometimes and g call f sometimes? 

6
00:00:23.049 --> 00:00:26.724
Now, is this useful? Yes, 
it's useful in a number of idioms and 

7
00:00:26.724 --> 00:00:31.521
patterns that come up and we'll show a 
particular example in this segment where 

8
00:00:31.521 --> 00:00:35.922
we're going to implement a little state 
machine but there's a problem. 

9
00:00:35.922 --> 00:00:41.129
And that problem is that we've seen in ML 
that you have to introduce bindings in 

10
00:00:41.129 --> 00:00:45.150
order, that the only functions in your 
environment are things that were defined 

11
00:00:45.150 --> 00:00:48.281
earlier into the environment and yourself 
for recursion. 

12
00:00:48.281 --> 00:00:52.210
So, how are we going to get f to call g 
and g to call f? Well, I'll show you two 

13
00:00:52.210 --> 00:00:54.501
ways. 
The first way is ML does have special 

14
00:00:54.501 --> 00:00:57.545
support for this and you should use that 
special support, 

15
00:00:57.545 --> 00:01:00.427
because it's good style when you want 
mutual recursion. 

16
00:01:00.427 --> 00:01:04.852
And second, I'll point out that we don't 
actually need the special support, 

17
00:01:04.852 --> 00:01:09.892
there is a workaround with high order 
functions and it's just another example 

18
00:01:09.892 --> 00:01:13.852
of using high order functions to 
accomplish something useful. 

19
00:01:13.852 --> 00:01:17.887
So, here is the built-in support I just 
never showed you before. 

20
00:01:17.887 --> 00:01:22.702
It turns out that if you have a bunch of 
function bindings in a row, and if for 

21
00:01:22.702 --> 00:01:27.834
after the first one you use the word and 
instead of fun. So it's fun f1, and f1's 

22
00:01:27.834 --> 00:01:33.261
definition, and f2, definition, and F3 
and you can have as many of those as you 

23
00:01:33.261 --> 00:01:36.143
want, 
then, this is all in some sense one 

24
00:01:36.143 --> 00:01:41.507
bundle of mutually recursive functions 
They are all allowed to call each other. 

25
00:01:41.507 --> 00:01:46.222
They are all added to the environment for 
all of the others and they're type 

26
00:01:46.222 --> 00:01:49.342
checked and evaluated as, as one package 
if you will. 

27
00:01:49.342 --> 00:01:53.832
So that is all we really need to have f 
call g and g call f, we just have to put 

28
00:01:53.832 --> 00:01:57.674
them next to each other in our file and 
use the key word and. 

29
00:01:57.674 --> 00:02:02.426
Now interestingly, we can also do this 
for data type findings, this is really a 

30
00:02:02.426 --> 00:02:06.806
separate construct, but suppose you 
wanted to introduce two types that 

31
00:02:06.806 --> 00:02:11.819
referred to each other, so one of the 
constructors of t1 holds a t2 and one of 

32
00:02:11.819 --> 00:02:16.120
the constructors of t2 holds a t1. 
We also have not been able to do that 

33
00:02:16.120 --> 00:02:20.804
before, and it's the same idea where we 
replace the keyword datatype with the 

34
00:02:20.804 --> 00:02:24.126
keyword and. Okay? 
So that's the, it, kind of it for the 

35
00:02:24.126 --> 00:02:27.079
language construct. 
Now, let's see this thing useful. 

36
00:02:27.079 --> 00:02:31.695
The idiom I want to show you for using 
mutually recursive functions is just one 

37
00:02:31.695 --> 00:02:35.926
of several things mutual recursion is 
useful for, is implementing a little 

38
00:02:35.926 --> 00:02:38.569
state machine. 
Now, in case you've never seen a 

39
00:02:38.569 --> 00:02:42.812
finite-state machine, it's a very 
important concept in computer science, I 

40
00:02:42.812 --> 00:02:47.567
encourage you to learn about it. 
But the idea is that we want to process 

41
00:02:47.567 --> 00:02:52.872
some input of unknown length, so some 
list of input that can have any size. 

42
00:02:52.872 --> 00:02:58.657
And as we process it, we're always in one 
of a finite number of known states and we 

43
00:02:58.657 --> 00:03:03.829
read the next level of the input and that 
tells us what state to go to next. 

44
00:03:03.829 --> 00:03:09.232
And then when we're all done with the 
input, certain states are, true, yes, we 

45
00:03:09.232 --> 00:03:12.972
accept, and certain states are false, no, 
we reject. 

46
00:03:12.972 --> 00:03:15.612
That's the idea of a finite state 
machine, 

47
00:03:15.612 --> 00:03:19.807
they come up all the time in computing. 
So the way we can implement a 

48
00:03:19.807 --> 00:03:24.548
finite-state machine with mutually 
recursive functions is we just have one 

49
00:03:24.548 --> 00:03:28.380
function for each state. 
So we could call those states state one, 

50
00:03:28.380 --> 00:03:32.661
state two, and so on it, depends what 
kind of state machine we're implementing. 

51
00:03:32.661 --> 00:03:37.282
They would all take the remaining input, 
they would all look at the first element 

52
00:03:37.282 --> 00:03:42.080
of that input, and then they would just 
call whatever function represents the 

53
00:03:42.080 --> 00:03:45.429
next state. 
So let me show an example of that, since 

54
00:03:45.429 --> 00:03:50.753
I don't expect you got it from the slide. 
Here's a function, match, that takes in, 

55
00:03:50.753 --> 00:03:55.772
in this case, an int list, and what it 
does, is it only accepts lists of ints 

56
00:03:55.772 --> 00:03:59.972
that look like 1, 2, 1, 2 some number of 
times. 

57
00:03:59.972 --> 00:04:06.337
So the empty list would actually pass, 
because it has 1, 2 zero times but, if 

58
00:04:06.337 --> 00:04:12.772
it's anything other than a 1 or a 2, it's 
going to reject and otherwise, it's going 

59
00:04:12.772 --> 00:04:16.146
to be 1, 2, 1, 2, 1, 2 and it has to end 
with a 2. 

60
00:04:16.146 --> 00:04:21.060
So, all I'm going to do inside my body of 
match is call this helper function I 

61
00:04:21.060 --> 00:04:25.254
defined s_need_one on the whole list. 
These are my two states, 

62
00:04:25.254 --> 00:04:30.268
need_one is the state that says I better 
have a one next if I have anything and 

63
00:04:30.268 --> 00:04:33.452
s_need_2 is I better have a two next if I 
have anything. 

64
00:04:33.452 --> 00:04:37.082
So here is how it works, 
s_need_one looks at that list, 

65
00:04:37.082 --> 00:04:41.799
if there's nothing left, then on before 
when I need a one, so that's true. 

66
00:04:41.799 --> 00:04:44.961
I saw a two last or I started with the 
empty list. 

67
00:04:44.961 --> 00:04:49.703
Otherwise, if I have a one first and I 
don't think I ever showed you, you can 

68
00:04:49.703 --> 00:04:54.825
put integer constants in patterns, but 
that really is an orthogonal issue not 

69
00:04:54.825 --> 00:04:58.585
particularly relevant here. 
then what I want to do is switch to state 

70
00:04:58.585 --> 00:05:01.735
two with the rest of my list. 
Now, in general, for finite-state 

71
00:05:01.735 --> 00:05:05.364
machines, I could have other 
possibilities where I have other states, 

72
00:05:05.364 --> 00:05:09.242
but there's particularly simple example 
where I just have two states, I go back 

73
00:05:09.242 --> 00:05:12.112
and forth between. 
And, any other case, I'm going to 

74
00:05:12.112 --> 00:05:17.062
immediately reject and return false. 
S_need_two takes in the input list, 

75
00:05:17.062 --> 00:05:22.422
if there's nothing more, it says false, 
because whenever I call s_need_2, I need 

76
00:05:22.422 --> 00:05:27.032
another two because I just saw a one. 
If I have a two at the beginning of my 

77
00:05:27.032 --> 00:05:30.572
list, then call s_need_one with the rest 
of the list. 

78
00:05:30.572 --> 00:05:34.575
And so on, we go back and forth, if I see 
anything other than a two, I return 

79
00:05:34.575 --> 00:05:37.055
false. 
Now, let me be honest with you this is 

80
00:05:37.055 --> 00:05:40.518
not the simplest way to implement this 
particular function, 

81
00:05:40.518 --> 00:05:45.177
but this is a particularly simple problem 
that can be answered with a finite-state 

82
00:05:45.177 --> 00:05:48.463
machine. 
Anything, any function that processes a 

83
00:05:48.463 --> 00:05:53.352
list of say integers or strings or 
whatever by looking at one element of it 

84
00:05:53.352 --> 00:05:56.809
at a time, 
and moving between things that don't need 

85
00:05:56.809 --> 00:06:01.772
to keep track of any more state than a 
finite number of possibilities can be 

86
00:06:01.772 --> 00:06:06.318
implemented in exactly this way. 
You could actually even automatically 

87
00:06:06.318 --> 00:06:10.688
take a description of a finite state 
machine and translate it down into a 

88
00:06:10.688 --> 00:06:13.451
collection of mutually recursive 
functions. 

89
00:06:13.451 --> 00:06:18.139
So I thought I would show you that idiom 
as a general phenomenon in computing. 

90
00:06:18.139 --> 00:06:22.785
Alright, let's do a second example. 
This example is going to be silly just to 

91
00:06:22.785 --> 00:06:25.631
keep it short. 
[COUGH] But what I have here is a 

92
00:06:25.631 --> 00:06:30.344
mutually recursive datatype binding. 
So type t1 is either a Foo of int or Bar 

93
00:06:30.344 --> 00:06:35.507
of t2 and data type t2, I really am 
defining two datatypes here, is either a 

94
00:06:35.507 --> 00:06:40.137
Baz of String or a Quux of t1. 
So each of these datatypes refer to the 

95
00:06:40.137 --> 00:06:44.262
other one. Alright? 
Now, suppose I wanted to write a function 

96
00:06:44.262 --> 00:06:48.564
that took either a t1 or a t2, these will 
be different functions, 

97
00:06:48.564 --> 00:06:53.855
and made sure that there were no zeros 
anywhere in it and no empty strings 

98
00:06:53.855 --> 00:06:57.264
anywhere in it. Okay? So, here is how I 
would do it. 

99
00:06:57.264 --> 00:07:01.413
I would write a function 
no_zeros_or_empty_strings_t1 that took in 

100
00:07:01.413 --> 00:07:04.451
an x. 
If it's made out of the Foo constructor, 

101
00:07:04.451 --> 00:07:09.070
I need to make sure i <> 0. 
If it's made out of the Bar constructor, 

102
00:07:09.070 --> 00:07:13.742
then what I have here in y is a t2. 
So I want to call this other function I 

103
00:07:13.742 --> 00:07:17.661
wrote for no_zeros_or_empty_strings_t2 
with that argument y. 

104
00:07:17.661 --> 00:07:22.496
And here is that other function, I've 
made these two mutually recursive because 

105
00:07:22.496 --> 00:07:27.412
that other function, well, if x is a Baz, 
then just make sure it's not empty, its 

106
00:07:27.412 --> 00:07:30.887
size is greater than zero. 
But if it's a Quux, then I want to call 

107
00:07:30.887 --> 00:07:34.287
the first function I wrote. 
So there is no good order here. I really 

108
00:07:34.287 --> 00:07:36.572
do need them to be mutually recursive. 
Okay? 

109
00:07:36.572 --> 00:07:40.332
So that works, that's fine, it's not a 
particularly interesting example. 

110
00:07:40.332 --> 00:07:44.062
thought I would use this example to show 
you a different work around. 

111
00:07:44.062 --> 00:07:48.087
So a work around if you did not want to 
necessarily put these next to each other 

112
00:07:48.087 --> 00:07:51.842
or if you were in some setting for some 
reason that you really could not use 

113
00:07:51.842 --> 00:07:55.521
mutual recursion. 
So the idea is to use our old friend, the 

114
00:07:55.521 --> 00:08:00.952
higher-order function and have one of 
these functions take in the other one as 

115
00:08:00.952 --> 00:08:04.649
an argument. 
So here, what I've done is I've written a 

116
00:08:04.649 --> 00:08:08.009
version where they are not mutually 
recursive, 

117
00:08:08.009 --> 00:08:13.269
so this thing takes a t2 and make sure 
that it doesn't have any zeros or empty 

118
00:08:13.269 --> 00:08:16.182
strings. 
So the Baz case is still the same, make 

119
00:08:16.182 --> 00:08:20.786
sure you don't have the empty string. 
For the other case, I want to call this 

120
00:08:20.786 --> 00:08:24.260
function up here. 
Now, this function up here is not 

121
00:08:24.260 --> 00:08:28.161
going to be able to call this function 
directly, because it's not in its 

122
00:08:28.161 --> 00:08:31.183
environment, 
but I could still pass it as an extra 

123
00:08:31.183 --> 00:08:33.778
argument. 
So what I've done is I've made my 

124
00:08:33.778 --> 00:08:38.516
function over t1 take not just an element 
of type t1, but also take a function, 

125
00:08:38.516 --> 00:08:42.844
this function f happens to have type t2 
-> bool, Alright? 

126
00:08:42.844 --> 00:08:49.047
So I could pass in any t2 -> bool, but 
the one I'm going to pass in right here 

127
00:08:49.047 --> 00:08:53.731
is the function I want to call. 
So one way you can get an earlier 

128
00:08:53.731 --> 00:08:59.282
function in your file to call a later one 
is to pass it as an argument, and once we 

129
00:08:59.282 --> 00:09:03.472
can do that, everything works out just 
fine and this is an equivalent solution 

130
00:09:03.472 --> 00:09:06.917
to the one that used the built-in support 
for mutual recursion. 

131
00:09:06.917 --> 00:09:10.602
By the way, this is a slower 
implementation, the built-in support will 

132
00:09:10.602 --> 00:09:15.047
implement this in a much more direct and 
efficient way, but I just thought I would 

133
00:09:15.047 --> 00:09:19.252
show you this as a technique and flip 
back to the slides quickly to show you in 

134
00:09:19.252 --> 00:09:24.259
general what we do. That if you want to 
have some earlier function, call a later 

135
00:09:24.259 --> 00:09:29.345
function, change your earlier function to 
take in an extra argument f, and then, 

136
00:09:29.345 --> 00:09:33.579
when you call the earlier function, pass 
in, I'm sorry not f here. 

137
00:09:33.579 --> 00:09:37.788
I'll fix this after I finish the 
recording, pass in later, right? 

138
00:09:37.788 --> 00:09:41.749
So call earlier with later and y and 
everything will work out correctly. 

139
00:09:41.749 --> 00:09:44.869
And that's really everything I have to 
tell you about mutual recursion. 