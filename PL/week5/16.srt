WEBVTT

1
00:00:00.012 --> 00:00:04.407
[SOUND] In this segment, I'm going to 
share with you some well-known 

2
00:00:04.407 --> 00:00:09.442
equivalences between functions. 
Things that programming languages people 

3
00:00:09.442 --> 00:00:14.108
have studied very carefully and 
understand well when two functions are 

4
00:00:14.108 --> 00:00:19.145
equivalent and what you have to be 
careful of to make sure you're following 

5
00:00:19.145 --> 00:00:23.570
all the assumptions carefully. 
So we'll just go through a few of these 

6
00:00:23.570 --> 00:00:26.529
examples. 
The first one is actually by definition. 

7
00:00:26.529 --> 00:00:30.445
We've seen a bunch of examples of 
syntactic sugar, and if something is 

8
00:00:30.445 --> 00:00:34.903
syntactic sugar, it's always equivalent 
with the thing that is syntactic sugar 

9
00:00:34.903 --> 00:00:37.459
for. 
That's really kind of the definition of 

10
00:00:37.459 --> 00:00:41.500
syntactic sugar. 
So for example we saw that E1 and also E2 

11
00:00:41.500 --> 00:00:47.015
is sugar for if E1 then E2 else false. 
So if you saw a function like you have 

12
00:00:47.015 --> 00:00:52.975
here on the left, takes an x and computes 
x and g of x for some g that's presumably 

13
00:00:52.975 --> 00:00:56.652
in the environment, 
you could always replace that with if x 

14
00:00:56.652 --> 00:00:59.727
then g of x else false, 
which is not good style but a language 

15
00:00:59.727 --> 00:01:03.942
implementation might do that, so that it 
only has to implement if then else and 

16
00:01:03.942 --> 00:01:07.652
not have to also implement and also by 
duplicating a bunch of codes. 

17
00:01:07.652 --> 00:01:11.822
And you know you can go the other way if 
you see something like on the right, it 

18
00:01:11.822 --> 00:01:15.452
would be a good style to replace it with 
the thing on the left. 

19
00:01:15.452 --> 00:01:21.197
The thing to be careful about here is 
evaluation order and also is only sugar 

20
00:01:21.197 --> 00:01:25.726
if you evaluate the arguments x first 
then g of x only if x is false. 

21
00:01:25.726 --> 00:01:30.180
So, the code on the left is not 
equivalent with this version you see 

22
00:01:30.180 --> 00:01:35.351
here, because the version on the right 
always calls g or the version on the left 

23
00:01:35.351 --> 00:01:38.761
only calls g if x is false. 
So that's our first example, 

24
00:01:38.761 --> 00:01:42.003
it is really by definition. 
Here is another example. 

25
00:01:42.003 --> 00:01:47.324
This is the first of three that are sort 
of a well understood by programming 

26
00:01:47.324 --> 00:01:52.255
language people, and we work hard when 
designing our languages to make sure that 

27
00:01:52.255 --> 00:01:56.716
they hold by treating variables properly, 
and so on. 

28
00:01:56.716 --> 00:02:01.555
And that is that you should be able to 
rename the variables in your function 

29
00:02:01.555 --> 00:02:05.721
without causing problems. 
So, I have code on the left here, takes 

30
00:02:05.721 --> 00:02:07.896
in x, returns x+y+x, 
so 2x+14, 

31
00:02:07.896 --> 00:02:10.812
right? 
The code on the right is exactly like the 

32
00:02:10.812 --> 00:02:15.867
code on the left, except it called the 
function parameter z instead of calling 

33
00:02:15.867 --> 00:02:17.294
it x, 
so it's z+y+z. 

34
00:02:17.294 --> 00:02:21.723
And we really want these to be 
equivalent, because we shouldn't have a 

35
00:02:21.723 --> 00:02:25.423
language where the callee can have its 
parameter name changed, 

36
00:02:25.423 --> 00:02:29.544
like you're cleaning up somebody's code 
and you say, oh, that's not a very good 

37
00:02:29.544 --> 00:02:33.584
variable name, here is a better one, and 
have suddenly callers be able to tell 

38
00:02:33.584 --> 00:02:37.263
that you've made that change. 
So you really want in your language that 

39
00:02:37.263 --> 00:02:40.643
this equivalence holds. 
That said, sometimes people get a little 

40
00:02:40.643 --> 00:02:44.907
sloppy, and think that this means you can 
rename parameters to anything and have it 

41
00:02:44.907 --> 00:02:48.627
always work. 
Here are two subtle mistakes where you 

42
00:02:48.627 --> 00:02:53.449
actually cannot do this. 
First, suppose we took the code on the 

43
00:02:53.449 --> 00:02:56.845
left, 
it's the same that we had up above, and 

44
00:02:56.845 --> 00:03:00.802
instead of replacing x with z, we 
replaced x with y. 

45
00:03:00.802 --> 00:03:06.589
Well, if you just do that naively you end 
up with f taking in y returning y+y+y. 

46
00:03:06.589 --> 00:03:12.052
That's not the same function. 
The function f on the right multiplies 

47
00:03:12.052 --> 00:03:16.253
its argument by three, 
the function on the left returns twice 

48
00:03:16.253 --> 00:03:20.371
its argument plus 14. 
The mistake here is if you rename your 

49
00:03:20.371 --> 00:03:25.485
parameter to something that you were 
already using in the function body to 

50
00:03:25.485 --> 00:03:30.678
refer to some outer thing, you're 
introducing shadowing that was not there 

51
00:03:30.678 --> 00:03:33.677
before and your function is not 
equivalent. 

52
00:03:33.677 --> 00:03:39.016
There is a related subtlety that comes up 
where maybe y is not something already in 

53
00:03:39.016 --> 00:03:43.072
the environment, but instead, it's a 
locally defined variable. 

54
00:03:43.072 --> 00:03:48.429
So here, the function on the left defines 
a local variable y for three, returns 

55
00:03:49.469 --> 00:03:52.420
x+y. 
So we know that this function just 

56
00:03:52.420 --> 00:03:57.777
returns its argument plus three. 
The code on the right always returns six, 

57
00:03:57.777 --> 00:04:03.322
that's not the same thing. 
Even though, again, all I did was replace 

58
00:04:03.322 --> 00:04:08.077
every x with y. 
Now, this x I had here and x+y, is now 

59
00:04:08.077 --> 00:04:13.117
referring to the shadowing of y, the 
three instead of the parameter. 

60
00:04:13.117 --> 00:04:18.442
So you have to be careful with this stuff 
and not reuse variables you are already 

61
00:04:18.442 --> 00:04:21.727
using for some other purpose. 
Let's do another one. 

62
00:04:21.727 --> 00:04:26.422
It turns out that you should always be 
able to choose whether or not to use a 

63
00:04:26.422 --> 00:04:29.727
helper function without callers being 
able to tell. 

64
00:04:29.727 --> 00:04:34.707
So here, I have some code on the left 
that just, I think returns three times 

65
00:04:34.707 --> 00:04:38.926
its argument plus 14. 
The code on the right also always returns 

66
00:04:38.926 --> 00:04:43.991
three times its argument plus 14, but it 
does it by using this helper function f. 

67
00:04:43.991 --> 00:04:49.319
Alright? So the code on the right calls f 
as a helper function the code on the left 

68
00:04:49.319 --> 00:04:54.501
does not use f. It shouldn't matter if I 
move out some of the function body and 

69
00:04:54.501 --> 00:04:58.476
end to a properly used helper function. 
So, that is all fine, 

70
00:04:58.476 --> 00:05:03.653
you just have to be careful that when you 
do this, all the variables still refer to 

71
00:05:03.653 --> 00:05:07.722
what they did before. 
So, in this slightly different example, 

72
00:05:07.722 --> 00:05:12.367
the code on the left is actually 
returning three times its argument plus 

73
00:05:12.367 --> 00:05:17.843
seven, because of this shadowed y. 
And the code on the right is using a 

74
00:05:17.843 --> 00:05:24.648
helper function f, and this helper 
function f is the exact same code, as it 

75
00:05:24.648 --> 00:05:29.144
was up above, but now it doesn't mean the 
same thing, 

76
00:05:29.144 --> 00:05:32.889
because f's is y and g's y are not the 
same y, 

77
00:05:32.889 --> 00:05:38.840
right? And so, if I replace what was 
z+y+z with (f z), I end up using 14 where 

78
00:05:38.840 --> 00:05:41.710
I should use seven. 
And you can check this by typing into the 

79
00:05:41.710 --> 00:05:45.576
REPL that the function g on the left and 
the function g on the right are, are 

80
00:05:45.576 --> 00:05:48.558
simply not the same. 
The last one I want to talk about, we 

81
00:05:48.558 --> 00:05:52.523
actually have talked about plenty of 
times, and this is unnecessary function 

82
00:05:52.523 --> 00:05:57.395
wrapping. 
So on the left here, function g takes in 

83
00:05:57.395 --> 00:06:01.797
a y and returns f with y. 
And as I've emphasized a few times now, a 

84
00:06:01.797 --> 00:06:07.212
simpler way to define g is to just say 
val g=f, alright? They're both functions 

85
00:06:07.212 --> 00:06:12.324
that take in one argument and return 
whatever the body of f returns, in this 

86
00:06:12.324 --> 00:06:16.969
case doubling the argument. 
The [INAUDIBLE] the subtlety is you have 

87
00:06:16.969 --> 00:06:20.700
to be a little careful. 
It's fine here where the function 

88
00:06:20.700 --> 00:06:25.624
recalling is just the variable, but if 
instead we have an expression that we 

89
00:06:25.624 --> 00:06:31.058
evaluate to get a function, then whether 
we're using function wrapping or not can, 

90
00:06:31.058 --> 00:06:33.836
can affect how many times we execute 
things. 

91
00:06:33.836 --> 00:06:38.464
And if you have side effects like 
printing or mutable references, that can 

92
00:06:38.464 --> 00:06:41.963
make a difference. 
So let me show you two things that are 

93
00:06:41.963 --> 00:06:45.556
not equivalent. 
On the left here, alright, I have f which 

94
00:06:45.556 --> 00:06:50.737
just doubles its argument, 
h a zero argument function takes any unit 

95
00:06:50.737 --> 00:06:56.487
that when you call it, prints out hi and 
then returns the function f. 

96
00:06:56.487 --> 00:07:00.362
So this function g of y, every time you 
call g, 

97
00:07:00.362 --> 00:07:06.299
it calls h which prints hi, then takes 
the result, and calls y with it. 

98
00:07:06.299 --> 00:07:13.005
So, function g, every time you call it, 
prints hi and then doubles its argument. 

99
00:07:13.005 --> 00:07:19.271
The code on the right defines g the other 
way by just saying val g equals h appied 

100
00:07:19.271 --> 00:07:22.576
to unit. 
What that will do is we will one time 

101
00:07:22.576 --> 00:07:27.612
call h, which will print hi, 
then return f, and so val g is bound to 

102
00:07:27.612 --> 00:07:30.124
f, 
g and f are the same function. 

103
00:07:30.124 --> 00:07:35.979
So the code on the right will print hi 
once before you ever call g and will 

104
00:07:35.979 --> 00:07:38.810
never print hi again. 
Let me say that again. 

105
00:07:38.810 --> 00:07:43.708
The code on the right will print hi once 
and never call and never print again. 

106
00:07:43.708 --> 00:07:47.654
They're both double argument. 
The code on the left does not print at 

107
00:07:47.654 --> 00:07:51.341
all until you call g, but then prints 
every time you call g. 

108
00:07:51.341 --> 00:07:55.479
So if h might have side effects like 
this, it makes a difference, 

109
00:07:55.479 --> 00:07:57.333
they're not the same. 
Okay. 

110
00:07:57.333 --> 00:08:02.381
One more that I just kind of like because 
it helps explain let expressions and 

111
00:08:02.381 --> 00:08:05.479
functions. 
We've also mentioned this once before, 

112
00:08:05.479 --> 00:08:09.812
but it's good to repeat it now that we're 
talking about equivalents. 

113
00:08:09.812 --> 00:08:15.487
I claim that the code on the left and the 
code on the right will always do the same 

114
00:08:15.487 --> 00:08:16.892
thing. 
Here is why. 

115
00:08:16.892 --> 00:08:19.917
The code on the left evaluates as 
follows. 

116
00:08:19.917 --> 00:08:25.332
Evaluate e1 to a value, extend the 
environment so that x maps to that value, 

117
00:08:25.332 --> 00:08:30.666
evaluate e2, and that's your answer. 
What about the code on the right? 

118
00:08:30.666 --> 00:08:33.787
Well, this is already a value on the 
left. 

119
00:08:33.787 --> 00:08:38.661
So evaluate e1 to a value, 
then, evaluate e2 in the environment 

120
00:08:38.661 --> 00:08:43.152
where x is bound the result of e1, 
and that's our entire answer. 

121
00:08:43.152 --> 00:08:46.837
The left and the right do the exact same 
sequence of steps. 

122
00:08:46.837 --> 00:08:51.667
They both evaluate e1, then evaluate e2 
in the same extended environment, and 

123
00:08:51.667 --> 00:08:55.447
then return the result of e2. 
So there's no way they can't be 

124
00:08:55.447 --> 00:08:59.058
equivalent. 
And you really can think of these as 

125
00:08:59.058 --> 00:09:04.364
being the same expression as if one were 
syntactic sugar for the other. 

126
00:09:04.364 --> 00:09:09.720
Now, in ML, there's a type system 
difference, which is that the code on the 

127
00:09:09.720 --> 00:09:14.732
left can give x a polymorphic type. 
The code on the right will never give x a 

128
00:09:14.732 --> 00:09:18.257
polymorphic type. 
So there are programs, where the version 

129
00:09:18.257 --> 00:09:23.062
on the left type checks, and the version 
on the right doesn't, but that's a detail 

130
00:09:23.062 --> 00:09:26.572
of ML's type system. 
For any expressions that do both type 

131
00:09:26.572 --> 00:09:30.802
check, they are equivalent and will 
always produce the same result. 

132
00:09:30.802 --> 00:09:36.344
So overall, I've now shown you, I think, 
five examples of general situations where 

133
00:09:36.344 --> 00:09:41.937
two things are equivalent and some of the 
subtleties where you have to think about, 

134
00:09:41.937 --> 00:09:45.227
shadowing, or side effects, and similar 
ideas. 

135
00:09:45.227 --> 00:09:50.255
And, if you understand these subtle 
distinctions, then you should understand 

136
00:09:50.255 --> 00:09:54.656
the role of variables and the meaning of 
functions at a very fundamental level. 

137
00:09:54.656 --> 00:09:58.544
These things are not ML specific. 
These are things that should be true 

138
00:09:58.544 --> 00:10:01.757
whenever you're programming with 
variables and functions. 