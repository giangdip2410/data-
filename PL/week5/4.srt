WEBVTT

1
00:00:00.000 --> 00:00:05.033
[MUSIC]

2
00:00:05.033 --> 00:00:08.450
In this segment, we'll continue
with our type inference examples.

3
00:00:08.450 --> 00:00:13.430
But the examples here are all going to
produce functions with polymorphic types.

4
00:00:13.430 --> 00:00:16.080
So the key ideas, we'll start the same,

5
00:00:16.080 --> 00:00:19.470
we're still going to collect all
the facts we need for type-checking.

6
00:00:19.470 --> 00:00:23.540
We're still going to use these facts,
to constrain the type of the function.

7
00:00:23.540 --> 00:00:27.521
The only difference is,
we'll end up with so few constraints,

8
00:00:27.521 --> 00:00:31.370
that some of the arguments of our
result can still be any type.

9
00:00:31.370 --> 00:00:35.489
And we'll use that information to
then figure out a polymorphic type.

10
00:00:35.489 --> 00:00:37.339
Where some of the arguments and

11
00:00:37.339 --> 00:00:41.050
results might need to be the same
type as some others, or not.

12
00:00:41.050 --> 00:00:44.100
And then we'll have inferred
polymorphic functions.

13
00:00:44.100 --> 00:00:47.220
So even though this is conceptually
perhaps more difficult,

14
00:00:47.220 --> 00:00:50.340
it's actually easier ,because we have
fewer constraints to deal with, all right.

15
00:00:51.680 --> 00:00:55.230
So let's just go over here, and let's
start with an example that's a lot like

16
00:00:55.230 --> 00:00:59.560
the sum of the elements in the int list
that we saw in the previous segment.

17
00:00:59.560 --> 00:01:02.390
This is just computing
the length of a list, but

18
00:01:02.390 --> 00:01:04.510
we sort of know what
the answer's going to be.

19
00:01:04.510 --> 00:01:08.537
We know that length on a list can work for
any type of list, so

20
00:01:08.537 --> 00:01:11.854
we'll be building up to
showing a list -> int.

21
00:01:11.854 --> 00:01:16.938
So we start, as we always do, by saying
that length better have T1 -> T2,

22
00:01:16.938 --> 00:01:21.962
because it's a function, and its
argument better have the argument type.

23
00:01:21.962 --> 00:01:25.090
Everything continues as we
did in the previous segment.

24
00:01:25.090 --> 00:01:30.440
We notice that since we're
pattern-matching with x, and xs'.

25
00:01:30.440 --> 00:01:35.120
There's going to have to be some
type T3 such that x has type T3, and

26
00:01:35.120 --> 00:01:38.450
xs' is type T3 list,
just from that pattern.

27
00:01:38.450 --> 00:01:41.685
Since we are pattern-matching against xs,

28
00:01:41.685 --> 00:01:46.680
that means that T1, the type of xs,
has to equal T3 list.

29
00:01:46.680 --> 00:01:50.930
We know from trying to return 0 as
a possible result of our function,

30
00:01:50.930 --> 00:01:53.620
that T2 has to equal int.

31
00:01:53.620 --> 00:01:56.655
And let's see, that's about it.

32
00:01:56.655 --> 00:02:00.205
1 is type int, so
we can have that be an argument to plus.

33
00:02:00.205 --> 00:02:04.841
length is our recursive call,
so we better call it with a T1.

34
00:02:04.841 --> 00:02:11.880
While xs' has type T3 list, and
we already know that T1 = T3 list.

35
00:02:11.880 --> 00:02:13.260
So we have no more constraints,

36
00:02:13.260 --> 00:02:16.910
everything type-checks with
what I've already written down.

37
00:02:16.910 --> 00:02:21.334
Therefore, putting all
those constraints together,

38
00:02:21.334 --> 00:02:27.390
I end up with T3 list -> int,
and there's nothing more to say.

39
00:02:27.390 --> 00:02:33.259
There's no constraint on what T3, the type
of the list elements of xs, need to be.

40
00:02:33.259 --> 00:02:35.838
After all,
we never used any of the elements.

41
00:02:35.838 --> 00:02:40.413
The contents of them, here, we could have
written a underscore there, instead of x.

42
00:02:40.413 --> 00:02:45.442
So when we have a type like this, and
it cannot be further constrained?

43
00:02:45.442 --> 00:02:50.480
What we do is we take all these T's that
are in there, there's one in this case,

44
00:02:50.480 --> 00:02:54.400
and we replace them consistently
with type variables.

45
00:02:54.400 --> 00:02:58.351
So in this example, we take that T3,
we replace it with the first letter of

46
00:02:58.351 --> 00:03:01.893
the alphabet, 'a, -> int, and
that is the type we would give.

47
00:03:01.893 --> 00:03:04.751
We would say for all types 'a, or alpha,

48
00:03:04.751 --> 00:03:08.750
we can take in a list of 'a's and
return an int.

49
00:03:08.750 --> 00:03:10.950
And that's how you type-check
the length function.

50
00:03:10.950 --> 00:03:16.230
The 'a simply falls out, from having no
reason to prefer any particular type for

51
00:03:16.230 --> 00:03:16.977
the list elements, okay?

52
00:03:18.580 --> 00:03:21.393
So now,
let's do a more sophisticated example.

53
00:03:21.393 --> 00:03:24.939
It's a less interesting function,
in terms of actually wanting to use it for

54
00:03:24.939 --> 00:03:25.546
something.

55
00:03:25.546 --> 00:03:30.419
But it's this function, f, that takes
in three arguments, x, y, and z,

56
00:03:30.419 --> 00:03:33.637
and either returns (x, y, z) or (y, x, z).

57
00:03:33.637 --> 00:03:36.409
Now you can look at this function and
say, well, if true,

58
00:03:36.409 --> 00:03:38.289
it's always going to return this one.

59
00:03:38.289 --> 00:03:40.731
But the type-checker follows
the type-checking rules.

60
00:03:40.731 --> 00:03:43.239
And the type-checking rules for
a conditional is,

61
00:03:43.239 --> 00:03:46.470
that we don't know which
branch might be returned.

62
00:03:46.470 --> 00:03:50.368
So, let's just go through this and pretend
we're the computer, doing type inference.

63
00:03:50.368 --> 00:03:55.494
So, f, I'm going to go ahead and
say it takes a T1 * T2 * T3 -> T4.

64
00:03:55.494 --> 00:03:58.619
I could write out more steps, and
say well, it takes one argument, and

65
00:03:58.619 --> 00:04:00.247
then that one argument is a pattern.

66
00:04:00.247 --> 00:04:04.835
But if you just look at this, it's going
to have to take in some triple and

67
00:04:04.835 --> 00:04:06.881
return some fourth type, T4.

68
00:04:06.881 --> 00:04:10.838
And certainly, x1 has type T1,

69
00:04:10.838 --> 00:04:15.632
y has type T2, and z has type T3, okay?

70
00:04:15.632 --> 00:04:19.956
So at this point, we don't need to type
check this is true, that is type bool,

71
00:04:19.956 --> 00:04:21.866
just like if/then/else needs.

72
00:04:21.866 --> 00:04:24.914
And we just noticed that we're
either going to return this, or

73
00:04:24.914 --> 00:04:26.298
we're going to return this.

74
00:04:26.298 --> 00:04:33.140
So T4 either has to
have type T1 * T2 * T3,

75
00:04:33.140 --> 00:04:38.238
or T4 has to have T2 * T1 * T3.

76
00:04:38.238 --> 00:04:40.279
And in fact, those both have to be true,

77
00:04:40.279 --> 00:04:43.901
because the type-checker doesn’t
know which of these might happen.

78
00:04:43.901 --> 00:04:49.165
So the result type has to be the type
has to be the type of (x, y, z) and

79
00:04:49.165 --> 00:04:54.364
the type of (y, x, z), so
both these constraints have to be true.

80
00:04:54.364 --> 00:05:01.110
And the only way those can both
be true is if T1 = T2, right?

81
00:05:01.110 --> 00:05:07.210
There's no other way for T4 for
to equal both of those things.

82
00:05:07.210 --> 00:05:10.997
So that's enough, then we'll have
the same thing in both cases.

83
00:05:10.997 --> 00:05:16.089
So if we put it all together,
the type of f is

84
00:05:16.089 --> 00:05:21.902
T1 * T1 * T3, aecause I know T1 equals T2.

85
00:05:21.902 --> 00:05:23.811
And I want to write down the type for f,

86
00:05:23.811 --> 00:05:26.228
that incorporates all
the constraints I have.

87
00:05:26.228 --> 00:05:33.495
-> not T4, but what T4 has to equal after
all my constraints, so T1 * T1 * T3.

88
00:05:33.495 --> 00:05:36.020
And what this type says, is that x and

89
00:05:36.020 --> 00:05:40.670
y have to have the same type,
z can have a possibly different type.

90
00:05:40.670 --> 00:05:45.315
So there are no other constraints, there's
no reason to prefer anything in particular

91
00:05:45.315 --> 00:05:48.594
for T1 and T3, and T1 and
T3 do not have to be the same type.

92
00:05:48.594 --> 00:05:55.660
So at this point, we replace these
capital T's with 'a and 'b, consistently.

93
00:05:55.660 --> 00:05:58.520
So we can pick any letters
of the alphabet, but

94
00:05:58.520 --> 00:06:03.330
every T1 has to be 'a, and
every single T3 has to be 'b.

95
00:06:04.360 --> 00:06:08.580
And so we end up with this type,
which is actually correct.

96
00:06:08.580 --> 00:06:11.343
You can call this with any types
of arguments you want, but x and

97
00:06:11.343 --> 00:06:12.609
y have to have the same type.

98
00:06:12.609 --> 00:06:15.668
z can have the same type, or
it can have a different type.

99
00:06:15.668 --> 00:06:20.138
It's exactly the sort of polymorphic type
we've seen before, now we just know how to

100
00:06:20.138 --> 00:06:23.449
infer it, and how type inference works for
this sort of thing.

101
00:06:24.540 --> 00:06:28.610
Okay, so that's our second example,
we saw two typed variables here.

102
00:06:28.610 --> 00:06:31.200
Let's do a final example that's
actually going to have three,

103
00:06:31.200 --> 00:06:33.330
and is actually one of
our favorite functions.

104
00:06:33.330 --> 00:06:35.590
So here is function composition.

105
00:06:35.590 --> 00:06:39.440
We've written this before, is takes
in two function arguments, f, g, and

106
00:06:39.440 --> 00:06:43.710
returns a function that takes in an x and
returns f (g x).

107
00:06:43.710 --> 00:06:46.737
And type inference will work for
this just fine.

108
00:06:46.737 --> 00:06:51.639
compose takes a pair for
its arguments, so let's call that

109
00:06:51.639 --> 00:06:56.700
T1 * T2 -> T3, where f has type T1,
and g has type T2.

110
00:06:56.700 --> 00:07:04.514
All right, now we just need to
look at this function body,

111
00:07:04.514 --> 00:07:09.946
and see that it is a anonymous function.

112
00:07:09.946 --> 00:07:16.035
So we have this argument x, and
it's going to have to take in some T4.

113
00:07:16.035 --> 00:07:21.775
And the body, being a function,

114
00:07:21.775 --> 00:07:25.674
has type T4 -> T5.

115
00:07:25.674 --> 00:07:28.754
The body of compose here has
to be some function, and

116
00:07:28.754 --> 00:07:31.417
that has to equal
the return type of compose.

117
00:07:31.417 --> 00:07:37.800
So let's say that T3 has to equal that,
okay, for some T4 and T5.

118
00:07:37.800 --> 00:07:42.940
So from g being passed x,
which has type T4,

119
00:07:42.940 --> 00:07:47.080
we actually know that T2,
which is g, g has to be a function.

120
00:07:47.080 --> 00:07:50.689
If you're going to write g space x,
it's going to have to be a function,

121
00:07:50.689 --> 00:07:51.590
so g has type T2.

122
00:07:51.590 --> 00:07:57.297
T2 is going to have to equal T4 -> T6 for
some T6.

123
00:07:57.297 --> 00:08:01.230
T4 is the type of x, okay.

124
00:08:01.230 --> 00:08:06.783
So now,
from f being passed the result of g, T1,

125
00:08:06.783 --> 00:08:13.140
the type of f, is also going to
have to equal some function.

126
00:08:13.140 --> 00:08:17.462
And it's going to have to equal
a function that's the return type of g,

127
00:08:17.462 --> 00:08:19.111
as its argument, so T6.

128
00:08:19.111 --> 00:08:25.437
And then some T7, say, for
what it returns, for some T7.

129
00:08:25.437 --> 00:08:27.381
Okay, we've looked at everything.

130
00:08:27.381 --> 00:08:33.280
But now we have to say, from f being
the body of the anonymous function.

131
00:08:33.280 --> 00:08:36.300
Remember, our anonymous
function was this T4 -> T5.

132
00:08:36.300 --> 00:08:41.828
From a call to f being the body that
function, we know that T7, the return

133
00:08:41.828 --> 00:08:47.728
type of f, has to be equal to T5, the
return type of that anonymous function.

134
00:08:47.728 --> 00:08:51.800
Because we call f, and
then that's our result, okay.

135
00:08:51.800 --> 00:08:56.574
So now we can just put it out together,
so put it all together.

136
00:08:56.574 --> 00:09:00.480
We end up with the T1, the type of f,

137
00:09:00.480 --> 00:09:06.170
has to be T6 -> T5,
because we just decided T7 = T5.

138
00:09:06.170 --> 00:09:11.020
We had T2 = T4 -> T6,
that was the type of g.

139
00:09:11.020 --> 00:09:17.074
And T3, which is our result for
compose, well, that's T4 -> T5, okay?

140
00:09:17.074 --> 00:09:23.042
And if we actually put this all together,
just for T1 * T2 -> T3 here.

141
00:09:23.042 --> 00:09:29.309
What we end up with is (T6 ->T5)

142
00:09:29.309 --> 00:09:36.596
* (T4 ->T6) -> (T4->T5).

143
00:09:36.596 --> 00:09:39.237
And that’s actually a good type for
compose.

144
00:09:39.237 --> 00:09:44.594
Take in something, g takes a T4,
returns a T6, f takes a T6,

145
00:09:44.594 --> 00:09:50.065
returns a T5, so the whole thing
takes in a T4 and returns a T5.

146
00:09:50.065 --> 00:09:54.066
But we always replace these capital T's
consistently with type variables shen

147
00:09:54.066 --> 00:09:57.580
we're all done,
there are no additional constraints here.

148
00:09:57.580 --> 00:10:00.290
So let's just use a,
we'll just go left to right.

149
00:10:00.290 --> 00:10:03.970
So the first thing that we see is T6,
so we'll use a for that.

150
00:10:03.970 --> 00:10:06.250
The second thing that we see is T5,
so we'll use b for that.

151
00:10:06.250 --> 00:10:09.770
The third thing that we see is T4,
so we'll use c for that.

152
00:10:09.770 --> 00:10:13.743
And now when see another T6,
we have to use a again.

153
00:10:13.743 --> 00:10:17.108
And when we see another T4,
we have to use c again.

154
00:10:17.108 --> 00:10:20.396
And when we see a T5,
we have to use b again.

155
00:10:20.396 --> 00:10:24.621
And except for these unnecessary
parentheses over here on the right,

156
00:10:24.621 --> 00:10:28.854
this is exactly what the repl will
print out, as the type for compose.

157
00:10:28.854 --> 00:10:33.013
It's something that takes in
a function from 'a to 'b, and

158
00:10:33.013 --> 00:10:37.610
a function from 'c to 'a, and
returns a function from 'c to 'b.

159
00:10:37.610 --> 00:10:41.033
So the process was exactly the same as for
the other examples.

160
00:10:41.033 --> 00:10:44.766
Gather all your facts,
constrain everything as much as you can.

161
00:10:44.766 --> 00:10:50.290
And then replace any unconstrained
types consistently with type variables.

162
00:10:50.290 --> 00:10:52.610
And that is our examples
of type inference.