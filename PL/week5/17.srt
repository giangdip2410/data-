WEBVTT

1
00:00:00.273 --> 00:00:05.070
[MUSIC]

2
00:00:05.070 --> 00:00:08.964
I want to finish our discussion of
function equivalence by dealing with

3
00:00:08.964 --> 00:00:12.450
the fact that we have not been
talking about performance.

4
00:00:12.450 --> 00:00:14.954
That we've ignored any
notion of how slow or

5
00:00:14.954 --> 00:00:18.686
fast something is when saying
the two functions are equivalent.

6
00:00:18.686 --> 00:00:23.663
This is just the definition from
a programming language perspective, and

7
00:00:23.663 --> 00:00:29.198
that definition by ignoring performance
is both a feature and a limitation.

8
00:00:29.198 --> 00:00:31.460
And I want to talk about the pluses and

9
00:00:31.460 --> 00:00:35.800
minuses of ignoring performance
when talking about equivalence.

10
00:00:35.800 --> 00:00:39.260
So, just to be clear,
this can make a big difference.

11
00:00:39.260 --> 00:00:44.240
If you remember back to when we
studied the necessary efficiencies of

12
00:00:44.240 --> 00:00:48.270
let expressions, I showed you an example
of computing the max of a list.

13
00:00:48.270 --> 00:00:51.730
It was before pattern matching, so
it didn't look quite like this, but

14
00:00:51.730 --> 00:00:53.230
the idea is the same.

15
00:00:53.230 --> 00:00:57.610
It turns out the code on the left
is sometimes very, very slow.

16
00:00:57.610 --> 00:01:00.960
Exponentially slow in
the length of certain lists.

17
00:01:00.960 --> 00:01:05.330
So for a list of length 50, it could
literally take centuries to complete,

18
00:01:05.330 --> 00:01:07.870
whereas the code on
the right is always fast.

19
00:01:07.870 --> 00:01:11.140
It takes time proportional
to the length of the list.

20
00:01:11.140 --> 00:01:14.550
But our definition of equivalence
said same side effects,

21
00:01:14.550 --> 00:01:19.490
same termination behavior,
same result for any argument.

22
00:01:19.490 --> 00:01:22.850
And technically, the code on the left,
if you're willing to wait a few centuries,

23
00:01:22.850 --> 00:01:24.150
will terminate.

24
00:01:24.150 --> 00:01:27.650
So by our definition,
these are equivalent to each other.

25
00:01:27.650 --> 00:01:31.380
Now I acknowledge that in the real world,
these are not equivalent.

26
00:01:31.380 --> 00:01:35.620
One of them is useful in many
situations where the other is not, but

27
00:01:35.620 --> 00:01:38.740
our definition says that
they are equivalent.

28
00:01:38.740 --> 00:01:42.120
So why is that a good thing,
and why is that a limitation?

29
00:01:42.120 --> 00:01:45.220
Well, the way I like to think of
it is that in computer science,

30
00:01:45.220 --> 00:01:47.850
there are many definitions of equivalence.

31
00:01:47.850 --> 00:01:52.190
And in particular,
there are three that I use all the time.

32
00:01:52.190 --> 00:01:56.450
And it's okay to have three definitions,
as long as I'm using them all

33
00:01:56.450 --> 00:02:00.770
appropriately and when I need
to think at sort of that level.

34
00:02:00.770 --> 00:02:03.640
So the first one is the programming
languages equivalence that we've

35
00:02:03.640 --> 00:02:04.980
been studying here.

36
00:02:04.980 --> 00:02:07.640
It says that given the same inputs,
you have the same outputs and

37
00:02:07.640 --> 00:02:09.020
the same effects.

38
00:02:09.020 --> 00:02:13.064
This is a feature, because what it would
do is let us take the bad version of max

39
00:02:13.064 --> 00:02:14.490
on the previous slide.

40
00:02:14.490 --> 00:02:19.040
Replace it with the good one, and
say it's okay I didn't break any clients,

41
00:02:19.040 --> 00:02:22.270
because I did an equivalent thing,
and now, it performs better.

42
00:02:22.270 --> 00:02:26.260
And performance is not part of the
definition of two things being the same.

43
00:02:26.260 --> 00:02:29.520
Of course, it's a bad thing because it
would let you take the good one and

44
00:02:29.520 --> 00:02:31.150
replace it with the bad one.

45
00:02:31.150 --> 00:02:36.890
So as long as you use the definition
appropriately to justify good things and

46
00:02:36.890 --> 00:02:39.429
not bad things,
it seems perfectly reasonable.

47
00:02:40.510 --> 00:02:42.690
Now if you take a course
in data structures or

48
00:02:42.690 --> 00:02:45.510
algorithms, you study
a different kind of equivalence.

49
00:02:45.510 --> 00:02:47.533
This is asymptotic equivalence.

50
00:02:47.533 --> 00:02:52.539
This is where you look at an algorithm,
and you decide its running time or

51
00:02:52.539 --> 00:02:57.317
its running space or some other
property as it relates to its inputs.

52
00:02:57.317 --> 00:03:00.351
And you're willing to
ignore small inputs and

53
00:03:00.351 --> 00:03:04.938
just say as the inputs grow very large,
how does the running time react

54
00:03:04.938 --> 00:03:08.070
proportionally to those
change in the inputs?

55
00:03:08.070 --> 00:03:10.384
So this is good for studying algorithms.

56
00:03:10.384 --> 00:03:14.810
It's good for understanding why one
version of max is better than another.

57
00:03:14.810 --> 00:03:18.870
It's a very powerful definition
of equivalence or one thing being

58
00:03:18.870 --> 00:03:23.060
better than another than being tied,
which is how equivalence comes in.

59
00:03:23.060 --> 00:03:27.080
And it's very effective and you should be
familiar with that definition as well for

60
00:03:27.080 --> 00:03:29.060
studying algorithms.

61
00:03:29.060 --> 00:03:31.769
It's still limiting
because it says that if

62
00:03:31.769 --> 00:03:35.208
one version of the program is
always four times faster or

63
00:03:35.208 --> 00:03:39.394
nine times faster than the other one,
those programs are the same.

64
00:03:39.394 --> 00:03:42.728
And the same way we might prefer
the nine times faster one, but

65
00:03:42.728 --> 00:03:45.190
this definition says they're the same.

66
00:03:45.190 --> 00:03:49.930
It's limiting the same way the programming
language definition is limiting,

67
00:03:49.930 --> 00:03:51.850
just to a lesser extent, okay?

68
00:03:53.370 --> 00:03:56.350
So there's a third definition
that sort of says wait,

69
00:03:56.350 --> 00:03:59.210
practical considerations matter too.

70
00:03:59.210 --> 00:04:01.020
We should account for those things.

71
00:04:01.020 --> 00:04:06.060
And maybe when I'm performance-tuning
a system or I care about how it reacts to

72
00:04:06.060 --> 00:04:10.560
representative workloads in the real
world, I should take care to make sure

73
00:04:10.560 --> 00:04:15.150
that I don't swap out an implementation
that behaves fundamentally differently.

74
00:04:15.150 --> 00:04:18.930
That maybe being 10% off is okay,
it's a little faster for some,

75
00:04:18.930 --> 00:04:20.890
it's a little slower for others.

76
00:04:20.890 --> 00:04:25.260
But I expect the system to behave mostly
the same, and because I'm dealing with

77
00:04:25.260 --> 00:04:29.710
a live system or something like that, I
should only make sort of code changes that

78
00:04:29.710 --> 00:04:33.090
are not going to have large effects
on performance, one way or the other.

79
00:04:34.150 --> 00:04:38.000
The limitation of this more fine
grain notion of equivalence

80
00:04:38.000 --> 00:04:40.970
is that it tends to focus
on inputs you've studied.

81
00:04:40.970 --> 00:04:44.290
It doesn't study the general algorithm,
maybe even for

82
00:04:44.290 --> 00:04:48.940
inputs you haven't seen, and it doesn't
study the general notion of equivalence,

83
00:04:48.940 --> 00:04:53.040
maybe for clients of your code
library that you've never seen.

84
00:04:53.040 --> 00:04:58.067
So for example, maybe if you focus on
systems equivalence for lists that only

85
00:04:58.067 --> 00:05:02.957
have length up to 20, then maybe those
two versions of max look the same.

86
00:05:02.957 --> 00:05:06.656
And it's a limitation of your thinking
that you don't realize that they actually

87
00:05:06.656 --> 00:05:10.230
behave very differently for
inputs you haven't seen yet.

88
00:05:10.230 --> 00:05:13.550
Okay, so I love all of these definitions.

89
00:05:13.550 --> 00:05:16.780
My claim, which you've probably already
seen here at the bottom of the slide,

90
00:05:16.780 --> 00:05:18.060
is that software developers and

91
00:05:18.060 --> 00:05:23.200
computer scientists probably use all
of these definitions almost every day.

92
00:05:23.200 --> 00:05:27.380
That when you're thinking about a problem
that you are working on, you're dealing

93
00:05:27.380 --> 00:05:31.600
with abstractions, and those abstractions
allow different implementations.

94
00:05:31.600 --> 00:05:34.260
And that's what programming
language equivalence is all about.

95
00:05:34.260 --> 00:05:37.270
You're thinking about algorithms and
it's something general and

96
00:05:37.270 --> 00:05:41.040
efficient in all cases, and that's
what the middle definition is about.

97
00:05:41.040 --> 00:05:44.830
And then you're thinking about how your
software will perform in practice,

98
00:05:44.830 --> 00:05:47.816
and are there inputs where you
need to tune it and improve it.

99
00:05:47.816 --> 00:05:50.140
And that's more of a systems perspective.

100
00:05:50.140 --> 00:05:52.010
None of these are better than the other.

101
00:05:52.010 --> 00:05:56.620
They are all mental tools,
intellectual tools that we need

102
00:05:56.620 --> 00:06:00.060
in order to reason about our
sophisticated software in today's world.