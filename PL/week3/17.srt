WEBVTT

1
00:00:00.000 --> 00:00:04.940

2
00:00:04.940 --> 00:00:09.233
I want to wrap up our discussion of 
pattern matching by giving a precise 

3
00:00:09.233 --> 00:00:11.880
definition of when a pattern matches a 
value. 

4
00:00:11.880 --> 00:00:16.644
And this is a bit more complicated now 
that we have nested patterns but it leads 

5
00:00:16.644 --> 00:00:19.644
to a very natural and elegant recursive 
definition. 

6
00:00:19.644 --> 00:00:23.878
So just to be clear, what I'm doing here 
is describing the semantics, the 

7
00:00:23.878 --> 00:00:28.760
evaluation rules for the part of pattern 
matching where you have a pattern and you 

8
00:00:28.760 --> 00:00:32.289
have a value and you want to know whether 
they match or not. 

9
00:00:32.289 --> 00:00:36.994
So for example the value would be the 
result of the expression between the word 

10
00:00:36.994 --> 00:00:40.520
case and the word of. 
And then the patterns would be each 

11
00:00:40.520 --> 00:00:45.675
branch of the case expression in order. 
Now these rules also applied when you had 

12
00:00:45.675 --> 00:00:50.639
patterns in function bindings or in 
variable bindings, but the key issue is 

13
00:00:50.639 --> 00:00:55.220
here's a pattern, here's a value, do they 
match, and if they do match, what 

14
00:00:55.220 --> 00:00:59.230
variables are introduced and what are 
those variables bound to? 

15
00:00:59.230 --> 00:01:01.803
Okay? 
So in the presence of nested patterns 

16
00:01:01.803 --> 00:01:06.412
this is a recursive definition and we 
would have one case of this definition 

17
00:01:06.412 --> 00:01:11.140
for every way of writing down patterns. 
So I haven't written an exhaustive list 

18
00:01:11.140 --> 00:01:15.749
here on the slide but I think by going 
through these examples you'll get the 

19
00:01:15.749 --> 00:01:20.297
sense of it and you'll get a sense of how 
pattern matching is itself in the 

20
00:01:20.297 --> 00:01:22.811
language definition a recursive 
procedure. 

21
00:01:22.811 --> 00:01:27.180
So let's start with the base cases of 
that recursion and that's when the 

22
00:01:27.180 --> 00:01:31.490
pattern is either a variable or that 
wildcard, that underscore character. 

23
00:01:31.490 --> 00:01:37.969
So, we have a pattern, we have a value. 
One case of our definition is the pattern 

24
00:01:37.969 --> 00:01:42.070
is a variable. 
If that's the case, the match always 

25
00:01:42.070 --> 00:01:48.303
succeeds, no matter what the value is, 
and we bind the variable to the entire 

26
00:01:48.303 --> 00:01:50.760
value v. 
That makes sense. 

27
00:01:50.760 --> 00:01:55.722
The and, the underscore case, the 
wildcard case, is exactly the same, the 

28
00:01:55.722 --> 00:01:59.550
match also always succeeds, and we don't 
bind anything. 

29
00:01:59.550 --> 00:02:04.530
Okay, good the other cases are recursive, 
they build out of the smaller nesting 

30
00:02:04.530 --> 00:02:07.786
patterns. 
Those nested patterns might be base cases 

31
00:02:07.786 --> 00:02:12.447
like variables, that is how our we 
started using pattern matching or they 

32
00:02:12.447 --> 00:02:17.300
could be nested patterns in which case 
this recursive definition will apply. 

33
00:02:17.300 --> 00:02:21.130
So for example, suppose we have a tuple 
pattern. 

34
00:02:21.130 --> 00:02:25.530
So we'll have some pattern of the form 
P1, P2, up to PN. 

35
00:02:25.530 --> 00:02:32.294
Then that will only match values that are 
also tuples with N values inside of them. 

36
00:02:32.294 --> 00:02:36.695
And it will only match if P1 matches V1. 
P2 matches V2. 

37
00:02:36.695 --> 00:02:42.481
And so on, up to PN matching VN. 
That recursive matching is appealing to 

38
00:02:42.481 --> 00:02:48.186
the same recursive definition. 
So we would use a recursive call, if you 

39
00:02:48.186 --> 00:02:51.417
will, to the pattern match procedure. 
Okay? 

40
00:02:51.417 --> 00:02:56.172
Now if all of those sub-patterns, those 
nested patterns, match then they will all 

41
00:02:56.172 --> 00:03:01.045
introduce various bindings of variables 
to values and the overall pattern will be 

42
00:03:01.045 --> 00:03:05.206
the union of all those bindings. 
So all the variables introduced by P1, 

43
00:03:05.206 --> 00:03:09.723
all the variables introduced by P2 up to 
all the variables introduced by PN. 

44
00:03:09.723 --> 00:03:14.537
The one extra rule in pattern matching is 
you're never allowed to use a variable 

45
00:03:14.537 --> 00:03:17.866
more than once. 
If you try to use the same variable more 

46
00:03:17.866 --> 00:03:22.739
than once in a pattern the compiler will 
reject that and, and tell you directly 

47
00:03:22.739 --> 00:03:26.880
that you're not allowed to do that. 
Let's do one more interesting case. 

48
00:03:26.880 --> 00:03:29.942
This is the case for when we're using a 
constructor. 

49
00:03:29.942 --> 00:03:34.535
So on the slide there where you see that 
capital c, assume that, that is one of 

50
00:03:34.535 --> 00:03:38.480
the constructors for some data type 
that's been previously defined. 

51
00:03:38.480 --> 00:03:43.777
So one kind of pattern we can write down 
is that constructor C, followed by a 

52
00:03:43.777 --> 00:03:47.492
nested pattern P1. 
The nested pattern is often a tuple. 

53
00:03:47.492 --> 00:03:51.551
but it doesn't have to be. 
It can be any kind of pattern. 

54
00:03:51.551 --> 00:03:55.542
Now, if we have a constructor with a 
pattern underneath it. 

55
00:03:55.542 --> 00:04:00.564
The only thing that will match is a value 
that was built out of the same 

56
00:04:00.564 --> 00:04:04.258
constructor. 
And a value that matches the pattern. 

57
00:04:04.258 --> 00:04:10.694
So we need the same C an we also need p1 
to match z one and then whatever variable 

58
00:04:10.694 --> 00:04:16.897
bindings are produced by the recursive 
match of p1 matching v1 are the variable 

59
00:04:16.897 --> 00:04:22.790
bindings that we have for the larger 
pattern c of p1 with the value c of v1. 

60
00:04:22.790 --> 00:04:25.700
So hopefully that gives you a sense of 
how. 

61
00:04:25.700 --> 00:04:28.542
Pattern matching is a recursive 
procedure. 

62
00:04:28.542 --> 00:04:31.791
an we can use this to understand much 
better. 

63
00:04:31.791 --> 00:04:37.205
What it means when these nested patterns 
are matching against, values of certain 

64
00:04:37.205 --> 00:04:39.506
shapes. 
So here are three examples. 

65
00:04:39.506 --> 00:04:42.958
In the first example here, you see A. 
the pattern. 

66
00:04:42.958 --> 00:04:47.385
A Cons onto B, cons onto C, cons onto D. 
And if you follow the recursive 

67
00:04:47.385 --> 00:04:49.993
procedure. 
Using colon, colon as a constructor. 

68
00:04:49.993 --> 00:04:54.631
What we have are the nest in pattern A 
and then the nest in pattern B cons onto 

69
00:04:54.631 --> 00:04:57.356
c cons on to cons onto D and so on 
recursively. 

70
00:04:57.356 --> 00:05:01.878
And what this will end up matching is any 
list that has greater than or three 

71
00:05:01.878 --> 00:05:04.487
elements. 
Because we will recursively match A 

72
00:05:04.487 --> 00:05:08.371
against the first element, B against the 
second C against the third. 

73
00:05:08.371 --> 00:05:12.140
And then D against the rest of the list. 
If the list is too short. 

74
00:05:12.140 --> 00:05:17.401
We'll end up trying to match the empty 
list constructor value against the cons 

75
00:05:17.401 --> 00:05:20.418
constructor pattern, that simply fails to 
match. 

76
00:05:20.418 --> 00:05:23.177
That's okay, 
we would move to the next case. 

77
00:05:23.177 --> 00:05:28.091
The next branch in our case expression. 
Then second pattern, A cons onto B, cons 

78
00:05:28.091 --> 00:05:32.914
onto C, cons onto empty list, would match 
all lists with exactly three elements. 

79
00:05:32.914 --> 00:05:36.685
Matching A to the first ONP to the second 
and C to the third. 

80
00:05:36.685 --> 00:05:41.632
If the list is too short, then just like 
in the previous example, we'll have some 

81
00:05:41.632 --> 00:05:46.392
empty list value that fails to match. 
If the list is too long, we'll end up in 

82
00:05:46.392 --> 00:05:51.092
the recursive position where we have the 
empty list pattern trying to match 

83
00:05:51.092 --> 00:05:54.740
against a non empty list value, and that 
will fail to match. 

84
00:05:54.740 --> 00:06:00.241
And then in this third example, we have 
some more nested patterns, where we have 

85
00:06:00.241 --> 00:06:04.976
a cons constructor pattern with a 
variable on the right, that's that 

86
00:06:04.976 --> 00:06:10.617
variable e, and then on the left we have 
the sort of pattern that requires a pair 

87
00:06:10.617 --> 00:06:14.204
of two nested pairs. 
So this will only match against a 

88
00:06:14.204 --> 00:06:17.367
non-empty list whose elements are pairs 
of pairs. 

89
00:06:17.367 --> 00:06:20.401
And then we'll introduce five variable 
binates. 

90
00:06:20.401 --> 00:06:25.371
So, that is our more precise definition. 
Hopefully it gives you the sense that 

91
00:06:25.371 --> 00:06:29.761
pattern matching is not a fuzzy concept, 
it's a very precise concept. 

92
00:06:29.761 --> 00:06:34.538
And that better explains, that more 
completely explains examples we saw in 

93
00:06:34.538 --> 00:06:35.700
previous segments. 