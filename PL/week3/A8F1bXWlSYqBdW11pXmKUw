WEBVTT

1
00:00:04.940 --> 00:00:08.453
All right let's talk about records. 
These are a new kind of each of type. 

2
00:00:08.453 --> 00:00:12.113
They're not particularly complicated but 
then they'll let us have a really 

3
00:00:12.113 --> 00:00:16.017
interesting conversation where we can 
start comparing and contrasting them with 

4
00:00:16.017 --> 00:00:19.190
two poles which are the other way we know 
to build each of types. 

5
00:00:19.190 --> 00:00:23.991
So I think it will be easiest to just 
jump over to the read a valve print loop, 

6
00:00:23.991 --> 00:00:28.124
and start showing you records. 
So how about I bind a variable X to a 

7
00:00:28.124 --> 00:00:31.102
record? 
this is a new kind of an expression we 

8
00:00:31.102 --> 00:00:34.322
haven't seen before. 
The syntax is we're going to put 

9
00:00:34.322 --> 00:00:38.515
something in between curly braces we 
haven't used those before in ML. 

10
00:00:38.515 --> 00:00:42.707
And what were going to do is we're 
going to have field names which are not 

11
00:00:42.707 --> 00:00:45.989
variables but can be any sequences of 
letters we want. 

12
00:00:45.989 --> 00:00:48.723
So maybe I want a record to have a field 
bar, 

13
00:00:48.723 --> 00:00:50.668
and a field foo, 
and a field bas. 

14
00:00:50.668 --> 00:00:56.940
I need to separate these by commas. 
And I need to have an expression to 

15
00:00:56.940 --> 00:00:59.955
evaluate to create the contents for each 
field. 

16
00:00:59.955 --> 00:01:03.483
So maybe for bar I want to evaluate this 
expression. 

17
00:01:03.483 --> 00:01:07.139
It can be any expression in the entire 
language as usual. 

18
00:01:07.139 --> 00:01:12.079
How about true and also true, which is a 
really dumb and fancy way of writing 

19
00:01:12.079 --> 00:01:13.016
true. 
All right. 

20
00:01:13.016 --> 00:01:18.074
And then maybe for foo I want to have the 
expression three comma four and for baz I 

21
00:01:18.074 --> 00:01:22.084
want to have false comma nine. 
And this should be a perfectly legal 

22
00:01:22.084 --> 00:01:25.661
expression, that we will evaluate and 
bind the result to X. 

23
00:01:25.661 --> 00:01:30.781
And sure enough the read-eval-print loop 
comes back and says you now have a record 

24
00:01:30.781 --> 00:01:35.263
value bound to X. 
Where bar holds, three comma true, base 

25
00:01:35.263 --> 00:01:39.330
holds false comma nine, and foo equals 
seven. 

26
00:01:39.330 --> 00:01:42.459
So we see two things here. 
One is it evaluated each of our 

27
00:01:42.459 --> 00:01:45.265
expressions to a value and then that was 
the result. 

28
00:01:45.265 --> 00:01:47.531
Same thing happened when we did two 
poles. 

29
00:01:47.531 --> 00:01:51.794
When we built the two pole we evaluated 
all the pieces and that was the result. 

30
00:01:51.794 --> 00:01:55.841
The second is the read-eval-print loop 
seems to have re-ordered our fields. 

31
00:01:55.841 --> 00:01:58.269
what it actually did was alphabetize 
them. 

32
00:01:58.269 --> 00:02:02.747
The order of fields and records does not 
matter and so the REPL chooses to present 

33
00:02:02.747 --> 00:02:06.686
them in a uniform or canonical order. 
And it just chooses alphabetization. 

34
00:02:06.686 --> 00:02:08.197
It doesn't matter. 
All right? 

35
00:02:08.197 --> 00:02:11.929
And as always we have the type. 
And records have a different type than 

36
00:02:11.929 --> 00:02:14.199
anything we've seen in the language 
before. 

37
00:02:14.199 --> 00:02:16.840
So this is a new kind of type, a new 
compound type. 

38
00:02:16.840 --> 00:02:19.830
And these types are written with curly 
braces, 

39
00:02:19.830 --> 00:02:23.637
the field names, a colon instead of 
equals, just because that's ML's way, 

40
00:02:23.637 --> 00:02:27.278
and then the type of each field. 
And those are separated by commas. 

41
00:02:27.278 --> 00:02:31.693
So indeed, we see we've just built a 
record where bar is type int star bool 

42
00:02:31.693 --> 00:02:35.500
baz is type bool star int. 
And foo is type int. 

43
00:02:35.500 --> 00:02:38.645
We could nest records. 
We could pass records to functions. 

44
00:02:38.645 --> 00:02:42.452
We could do all the normal things. 
Perhaps the only things that seems 

45
00:02:42.452 --> 00:02:44.825
strange, 
if you try to compare them to Java 

46
00:02:44.825 --> 00:02:49.184
classes or c strucks or Python classes is 
we didn't have to declare our record 

47
00:02:49.184 --> 00:02:51.763
type, 
the same way we could just anywhere write 

48
00:02:51.763 --> 00:02:55.986
and int-star bool without having to say 
anything ahead of time. 

49
00:02:55.986 --> 00:03:00.428
We can write this record, which has a 
BAR-field, a BAS-field and a FOO-field of 

50
00:03:00.428 --> 00:03:03.115
particular types. 
And the type checker, using type 

51
00:03:03.115 --> 00:03:06.296
inference, just figures out the type of 
the record we have. 

52
00:03:06.296 --> 00:03:10.738
And we can say, what is the type of X. 
It says it has the type that it had back 

53
00:03:10.738 --> 00:03:13.645
when we created it. 
So let me show you a couple other 

54
00:03:14.748 --> 00:03:19.036
examples of records just to make sure we 
have the hang of it. 

55
00:03:19.036 --> 00:03:22.185
Here's one that kind of represents my 
niece. 

56
00:03:22.185 --> 00:03:24.731
she has a name, 
that name is Amelia. 

57
00:03:24.731 --> 00:03:29.019
And she has a birthday. 
She doesn't actually have an ID which 

58
00:03:29.019 --> 00:03:34.282
maybe is the result of this calculation. 
And sure enough, I get a record where the 

59
00:03:34.282 --> 00:03:39.195
ID is 411111, and the name is Amelia. 
And that has type ID colon and name colon 

60
00:03:39.195 --> 00:03:41.967
string. 
And again, you just create any record 

61
00:03:41.967 --> 00:03:46.502
with any field names you want. 
and the way, I haven't shown you how to 

62
00:03:46.502 --> 00:03:50.156
get the pieces yet back. 
You do that with hash ID, and then 

63
00:03:50.156 --> 00:03:54.250
something like my niece. 
So the same way we had hash one and hash 

64
00:03:54.250 --> 00:03:59.164
two for tuples, for now we have hash 
field name to get the corresponding piece 

65
00:03:59.164 --> 00:04:02.441
of a record. 
And there's no rule that you have to use 

66
00:04:02.441 --> 00:04:05.270
different, field names for different 
things. 

67
00:04:05.270 --> 00:04:10.314
So here is something that also has a 
field name that as far as M L is the same 

68
00:04:10.314 --> 00:04:15.295
can be concerned is the same as one of 
the field names in Amelia, and my niece, 

69
00:04:15.295 --> 00:04:18.678
but this usually pronounced id but it's 
the same as ID, 

70
00:04:18.678 --> 00:04:22.799
it's spelled the same way. 
And sure enough this created a perfectly 

71
00:04:22.799 --> 00:04:27.903
good record holding three bools, two of 
which are false, one of which are true. 

72
00:04:27.903 --> 00:04:30.610
And the field names are ego, ID, and 
superego. 

73
00:04:30.610 --> 00:04:33.075
Okay, so that's your little demo of 
records. 

74
00:04:33.075 --> 00:04:36.630
Now let's talk about them from a more 
interesting perspective. 

75
00:04:36.630 --> 00:04:40.700
Take a step back to come up with the 
rules for how you create them and use 

76
00:04:40.700 --> 00:04:43.033
them. 
So we have a new kind of value in our 

77
00:04:43.033 --> 00:04:44.824
language. 
These are record values. 

78
00:04:44.824 --> 00:04:49.002
These are things where you have field 
names and each thing is a value that's 

79
00:04:49.002 --> 00:04:52.041
the result of evaluating something that 
builds a record. 

80
00:04:52.041 --> 00:04:56.383
The types are these record types, where 
you have the names of the fields and the 

81
00:04:56.383 --> 00:05:00.019
type that each field has. 
As I've emphasized in the examples we 

82
00:05:00.019 --> 00:05:04.697
went through, the order of fields in a 
record or ty value or record type never 

83
00:05:04.697 --> 00:05:07.036
matters. 
So the rapport prints them out 

84
00:05:07.036 --> 00:05:12.014
alphabetically but the something with the 
foo holding two and a bar holding four is 

85
00:05:12.014 --> 00:05:16.692
exactly the same as a bar holding four 
and a foo holding two because we access 

86
00:05:16.692 --> 00:05:21.670
the pieces by name with the hash my filed 
name, the order of the fields is not part 

87
00:05:21.670 --> 00:05:24.400
of a rapport definition. 
Okay. 

88
00:05:24.400 --> 00:05:28.991
So, we've seen this example and I 
emphasized as we went through it that we 

89
00:05:28.991 --> 00:05:33.463
didn't have to declare any records types, 
that we just create a record with 

90
00:05:33.463 --> 00:05:37.577
expressions that have certain types and 
then we have a record of the 

91
00:05:37.577 --> 00:05:40.938
corresponding type. 
The thing I want to emphasize is that 

92
00:05:40.938 --> 00:05:45.024
these are a lot like tuples. 
So we now have two ways to do each of 

93
00:05:45.024 --> 00:05:47.871
types. 
If we wanted something that had in it a 

94
00:05:47.871 --> 00:05:52.700
four, a seven, and a nine, we could write 
the triple, four comma seven comma nine, 

95
00:05:52.700 --> 00:05:56.476
or we could write a record using three 
different field name,. 

96
00:05:56.476 --> 00:05:59.510
maybe F equals four, G equals seven, H 
equals nine. 

97
00:05:59.510 --> 00:06:03.919
So which should we prefer? 
Which is better? And you know as anything 

98
00:06:03.919 --> 00:06:07.144
in language design or software design it 
depends. 

99
00:06:07.144 --> 00:06:12.277
So the Tuples version is shorter, right? 
Fewer characters to type but the records 

100
00:06:12.277 --> 00:06:16.292
are a little easier to remember or which 
part is which, right? 

101
00:06:16.292 --> 00:06:21.294
I don't have to remember that oh, my 
niece's name came first and then her 

102
00:06:21.294 --> 00:06:25.374
birthday came second. 
I had useful field names to remind me of 

103
00:06:25.374 --> 00:06:29.107
that using a name and ID. 
Okay, so generally the choice here is a 

104
00:06:29.107 --> 00:06:32.693
bit of a matter of taste. 
The one thing I would emphasize is if you 

105
00:06:32.693 --> 00:06:36.815
have a lot of fields, like say eight, or 
ten, or twelve, or six, usually a record 

106
00:06:36.815 --> 00:06:39.973
is a better choice. 
I know I can't keep track of, wait which 

107
00:06:39.973 --> 00:06:41.846
thing came fifth? 
Is that hash five? 

108
00:06:41.846 --> 00:06:44.830
Or am I supposed to use hash seven? 
Okay. 

109
00:06:44.830 --> 00:06:49.662
But even more generally what I find 
fascinating about Tuples and records, 

110
00:06:49.662 --> 00:06:54.892
this is just one example of a standard 
choice when you're designing a language 

111
00:06:54.892 --> 00:06:58.003
construct. 
Which is, if you have multiple things, 

112
00:06:58.003 --> 00:07:03.233
you want to indicate which is which by 
position, the second place, the fourth 

113
00:07:03.233 --> 00:07:08.396
place, the fifth place or by some sort of 
name, the foo field, the bar field, the 

114
00:07:08.396 --> 00:07:12.103
name field, alright? 
And each construct that has multiple 

115
00:07:12.103 --> 00:07:15.480
things you can kind of see which way it's 
doing it. 

116
00:07:15.480 --> 00:07:19.762
And to point out a common kind of hybrid, 
it's a little bit of each, look at 

117
00:07:19.762 --> 00:07:24.329
function arguments as we've been using 
them in ML or even Java method arguments 

118
00:07:24.329 --> 00:07:27.808
and similarly in Python. 
For the caller, to a method or function, 

119
00:07:27.808 --> 00:07:31.215
it's always by position, 
the first argument, the second argument, 

120
00:07:31.215 --> 00:07:34.514
the third argument. 
That's how you write down the method call 

121
00:07:34.514 --> 00:07:38.113
or the function call. 
But then, in the callee we don't access 

122
00:07:38.113 --> 00:07:40.913
them by position. 
We access them by name using the 

123
00:07:40.913 --> 00:07:45.393
variables or formal parameters we used 
then defining the function or the method. 

124
00:07:45.393 --> 00:07:49.593
So it's kind of a strange hybrid. 
And there are other programming languages 

125
00:07:49.593 --> 00:07:54.352
out there, where the caller, specifies 
the arguments sort of by name, I want the 

126
00:07:54.352 --> 00:07:57.992
foo argument to be seven and the bar 
argument to be nine. 

127
00:07:57.992 --> 00:08:02.192
And there are probably languages, 
although I can't think of any off the top 

128
00:08:02.192 --> 00:08:05.776
of my head where the callee accesses 
arguments by position. 

129
00:08:05.776 --> 00:08:09.080
The second argument, the fourth argument, 
the fifth argument. 

130
00:08:09.080 --> 00:08:13.278
So whenever learning a concert we have 
another design choice to think about, 

131
00:08:13.278 --> 00:08:16.360
which is how you access the pieces, by 
name or by position. 

132
00:08:16.360 --> 00:08:20.558
There isn't a huge difference between 
those and that's why in the next segment 

133
00:08:20.558 --> 00:08:24.757
I'll actually show you that tuples and 
records are even more similar than they 

134
00:08:24.757 --> 00:08:25.129
appear. 