WEBVTT

1
00:00:04.190 --> 00:00:08.715
In this segment we're going to start our discussion of tail recursion.

2
00:00:08.715 --> 00:00:12.845
This is a new topic relevant to reasoning about how efficient

3
00:00:12.845 --> 00:00:17.959
your recursive functions are in ML and in other functional languages.

4
00:00:17.959 --> 00:00:22.050
At this point we've written a lot of recursive functions and so hopefully you're

5
00:00:22.050 --> 00:00:26.840
convinced that writing a recursive function is no more difficult than writing a loop.

6
00:00:26.840 --> 00:00:28.335
In fact, I've never shown you a loop.

7
00:00:28.335 --> 00:00:31.260
I could even pretend that I don't even know what a loop is.

8
00:00:31.260 --> 00:00:33.739
I would even argue that recursion while never

9
00:00:33.739 --> 00:00:36.830
harder than a loop is often easier than a loop.

10
00:00:36.830 --> 00:00:38.600
Whenever you're processing a tree,

11
00:00:38.600 --> 00:00:42.425
like when you're evaluating an arithmetic expression you really want recursion.

12
00:00:42.425 --> 00:00:46.700
Examples like appending two lists together became much easier when we just thought

13
00:00:46.700 --> 00:00:49.700
recursively and basically these recursive functions

14
00:00:49.700 --> 00:00:53.160
avoid any need for mutation even of local variables.

15
00:00:53.160 --> 00:00:56.180
If you have something like a four loop you always end up incrementing

16
00:00:56.180 --> 00:01:01.100
that index I and we're really trying to stay away from mutable variables.

17
00:01:01.100 --> 00:01:04.100
But what we haven't talked about yet is whether recursion is

18
00:01:04.100 --> 00:01:08.494
efficient or in what situations does it lead to fast code?

19
00:01:08.494 --> 00:01:11.265
A lot of times people think recursion is inefficient.

20
00:01:11.265 --> 00:01:15.890
That's not necessarily the case and even when it is the case it often doesn't matter.

21
00:01:15.890 --> 00:01:18.050
But what we're going to do is see the importance of

22
00:01:18.050 --> 00:01:20.450
this idea called tail recursion and then in

23
00:01:20.450 --> 00:01:23.300
subsequent segments see how to use

24
00:01:23.300 --> 00:01:28.350
common idioms in order to get tail recursion using things like an accumulator.

25
00:01:28.350 --> 00:01:31.495
So just to be clear, I'm not showing you any new language features here.

26
00:01:31.495 --> 00:01:35.090
Just new programming idioms and new ways to reason about

27
00:01:35.090 --> 00:01:40.160
the efficiency of code that we've already been writing.

28
00:01:40.160 --> 00:01:45.845
To understand recursion and tail recursion I have to tell you a little bit about

29
00:01:45.845 --> 00:01:49.250
how function calls are implemented and all you have to

30
00:01:49.250 --> 00:01:53.029
understand is the high level idea of a call stack.

31
00:01:53.029 --> 00:01:56.390
When a program runs there is a call stack

32
00:01:56.390 --> 00:02:00.515
of all the functions that you have called and that aren't done yet.

33
00:02:00.515 --> 00:02:04.109
When you call a function F,

34
00:02:04.109 --> 00:02:08.365
what that does is it pushes onto the stack some instance,

35
00:02:08.365 --> 00:02:11.675
some thing that is going to stay on that stack

36
00:02:11.675 --> 00:02:15.489
until the call to F finishes and when the call to F finishes,

37
00:02:15.489 --> 00:02:17.560
we will pop it from the stack.

38
00:02:17.560 --> 00:02:21.620
So, at any given time the stack contains all the calls that have

39
00:02:21.620 --> 00:02:23.780
started and not finished and there can be lots of

40
00:02:23.780 --> 00:02:26.550
them because one function calls another one.

41
00:02:26.550 --> 00:02:30.144
What's in these stack things which I'll call stack frames?

42
00:02:30.144 --> 00:02:33.380
Will they store information like what are the local variables

43
00:02:33.380 --> 00:02:36.710
bound to and they store information like what work is

44
00:02:36.710 --> 00:02:39.680
left for this function to do after

45
00:02:39.680 --> 00:02:43.880
any function that it called is done with its evaluation.

46
00:02:43.880 --> 00:02:46.535
Now notice that if we have a recursive function where

47
00:02:46.535 --> 00:02:49.275
F calls F which calls F which calls F. We're

48
00:02:49.275 --> 00:02:54.940
going to have multiple stack frames on our stack that are all for the same piece of code,

49
00:02:54.940 --> 00:03:00.529
the function F. That makes perfect sense and it's what recursion is really about.

50
00:03:00.529 --> 00:03:01.905
So let's see an example.

51
00:03:01.905 --> 00:03:05.180
Suppose I have a factorial function here, so it just computes.

52
00:03:05.180 --> 00:03:10.185
If you pass it N it returns N times N minus one times N minus two down to one.

53
00:03:10.185 --> 00:03:14.120
It only works correctly for non-negative numbers.

54
00:03:14.120 --> 00:03:16.189
Suppose I call fact with threes.

55
00:03:16.189 --> 00:03:17.930
I'll eventually get the answer six back,

56
00:03:17.930 --> 00:03:20.270
three times two times one.

57
00:03:20.270 --> 00:03:26.180
My first call is here on this single element stack you see I'm calling fact with three.

58
00:03:26.180 --> 00:03:32.265
Then when I call fact with three it ends up calling fact with two three minus one and

59
00:03:32.265 --> 00:03:35.030
so I'm going to represent that by adding to

60
00:03:35.030 --> 00:03:38.715
my stack that there is now a call of fact two.

61
00:03:38.715 --> 00:03:43.190
What fact three is remembering to do in its stack frame is when it gets

62
00:03:43.190 --> 00:03:47.860
its result back it's going to multiply it by three and then that will be its answer.

63
00:03:47.860 --> 00:03:52.380
So, three times whatever I get back from the call to fact two.

64
00:03:52.380 --> 00:03:55.012
Similarly fact two is going to call fact one,

65
00:03:55.012 --> 00:03:59.840
so now I have a bigger stack where fact two is waiting to get the results of

66
00:03:59.840 --> 00:04:05.089
the call and multiply it by two and even fact one ends up calling fact zero.

67
00:04:05.089 --> 00:04:07.520
At this point I have a stack with four elements on

68
00:04:07.520 --> 00:04:10.340
it but then when I call fact with zero,

69
00:04:10.340 --> 00:04:13.490
it evaluates the f expression and returns one.

70
00:04:13.490 --> 00:04:16.249
There's no additional call put on the stack.

71
00:04:16.249 --> 00:04:18.015
It ends up saying, "All right,

72
00:04:18.015 --> 00:04:22.940
I'm going to return one" and when you return you pop that off your call stack.

73
00:04:22.940 --> 00:04:28.865
So now we have a smaller stack and now fact one has it's recursive result it needs.

74
00:04:28.865 --> 00:04:30.710
It multiplies one by one,

75
00:04:30.710 --> 00:04:33.260
gets one and now we pop it off,

76
00:04:33.260 --> 00:04:34.870
get two by one.

77
00:04:34.870 --> 00:04:38.795
We now pop off the recursive call of fact with argument two,

78
00:04:38.795 --> 00:04:43.029
with fact of three and then fact of three would eventually return six.

79
00:04:43.029 --> 00:04:45.005
Alright. This is how call stacks work.

80
00:04:45.005 --> 00:04:50.010
This is exactly what I would expect to happen when we evaluate fact.

81
00:04:50.010 --> 00:04:54.700
Now here is a second version of factorial that is more complicated.

82
00:04:54.700 --> 00:04:57.080
I'm going to show you in a minute that it's actually more

83
00:04:57.080 --> 00:05:00.319
efficient but we can't see that yet.

84
00:05:00.319 --> 00:05:03.570
Let's first understand how this version of factorial works.

85
00:05:03.570 --> 00:05:06.800
What it does is all it does is it calls a helper function locally

86
00:05:06.800 --> 00:05:10.730
defined although that's not important that I've called aux for auxiliary,

87
00:05:10.730 --> 00:05:14.450
for helper function and this helper function takes in

88
00:05:14.450 --> 00:05:18.619
a number but also acc which is short for accumulator.

89
00:05:18.619 --> 00:05:19.670
What it does is it says,

90
00:05:19.670 --> 00:05:23.216
if N equals zero then just return whatever is an accumulator,

91
00:05:23.216 --> 00:05:30.349
otherwise call aux with N minus one and go ahead and multiply the accumulator by N.

92
00:05:30.349 --> 00:05:34.325
And I'm going to show you that this will actually compute factorial correctly.

93
00:05:34.325 --> 00:05:36.597
Instead of our simple recursive function,

94
00:05:36.597 --> 00:05:43.065
what we're doing now is we're multiplying into this second argument accumulator as we go.

95
00:05:43.065 --> 00:05:46.124
So when N is zero we just end up returning accumulator.

96
00:05:46.124 --> 00:05:48.725
So this is still recursive, aux is recursive.

97
00:05:48.725 --> 00:05:54.259
It's more complicated but when aux calls aux,

98
00:05:54.259 --> 00:06:00.275
the result of the recursive call is the result for the caller.

99
00:06:00.275 --> 00:06:02.490
There is no extra work to do.

100
00:06:02.490 --> 00:06:03.670
When I got back here...

101
00:06:03.670 --> 00:06:06.035
In the first version of factorial

102
00:06:06.035 --> 00:06:08.870
after the recursive call the caller had more work to do.

103
00:06:08.870 --> 00:06:14.195
It had to multiply by N. Here there is no more work for the caller.

104
00:06:14.195 --> 00:06:16.755
The result of the recursive call is the result.

105
00:06:16.755 --> 00:06:20.240
And that's going to be the key difference but before I show that let me

106
00:06:20.240 --> 00:06:24.660
show you how the call stacks would look given what I've shown you so far.

107
00:06:24.660 --> 00:06:26.160
So I start with fact three.

108
00:06:26.160 --> 00:06:29.090
Fact three is going to call aux with three and

109
00:06:29.090 --> 00:06:33.740
one because that's the initial value for the accumulator if you look back at the code.

110
00:06:33.740 --> 00:06:35.180
Then aux of three,

111
00:06:35.180 --> 00:06:39.615
one will end up calling aux with two and three.

112
00:06:39.615 --> 00:06:45.710
So three minus one is two and three times the current accumulator one is three.

113
00:06:45.710 --> 00:06:49.100
Now notice that these callers on my stack are just waiting

114
00:06:49.100 --> 00:06:52.760
to get their results back and immediately return them.

115
00:06:52.760 --> 00:06:55.395
So then aux two three will call aux one six,

116
00:06:55.395 --> 00:06:57.960
aux one six will call aux zero six.

117
00:06:57.960 --> 00:07:00.080
At this point I have a bigger stack than I actually had with

118
00:07:00.080 --> 00:07:04.220
my previous version but now aux zero six will return six.

119
00:07:04.220 --> 00:07:07.444
Aux one six will return that six,

120
00:07:07.444 --> 00:07:09.889
aux two three will return that six,

121
00:07:09.889 --> 00:07:13.445
aux three one will return that six and fact three will turn that six.

122
00:07:13.445 --> 00:07:17.330
This will just continue until I'm done with my program. All right.

123
00:07:17.330 --> 00:07:20.570
So now we get to the key idea of

124
00:07:20.570 --> 00:07:25.160
an important optimization that you should understand functional languages do.

125
00:07:25.160 --> 00:07:29.855
It is simply unnecessary to keep around a stack frame if

126
00:07:29.855 --> 00:07:35.760
all it is going to do is take the result from the callee and immediately return it.

127
00:07:35.760 --> 00:07:39.560
So such a situation is called a tail call

128
00:07:39.560 --> 00:07:43.860
for reasons I've never fully understood but that is what everyone calls them.

129
00:07:43.860 --> 00:07:47.210
And the compiler, the implementation of the language

130
00:07:47.210 --> 00:07:51.440
recognizes these function calls and treats them differently.

131
00:07:51.440 --> 00:07:57.110
What it does is it removes the caller's stack frame before it makes

132
00:07:57.110 --> 00:08:04.245
the call so that the callee just reuses the same stack space that the caller was using.

133
00:08:04.245 --> 00:08:08.060
And along with a couple other optimizations I'm not going to show you,

134
00:08:08.060 --> 00:08:12.140
this makes recursive functions that use tail calls

135
00:08:12.140 --> 00:08:16.940
absolutely as efficient as loops in other languages.

136
00:08:16.940 --> 00:08:20.600
It is reasonable to assume it is guaranteed by another language that you

137
00:08:20.600 --> 00:08:24.900
can assume this kind of efficiency for tail calls.

138
00:08:24.900 --> 00:08:27.440
So in fact what I showed you before for

139
00:08:27.440 --> 00:08:32.085
this more complicated version of factorial is not what happens.

140
00:08:32.085 --> 00:08:34.485
We do start with our stack factor of

141
00:08:34.485 --> 00:08:38.385
three but right here where I see this call for fact three,

142
00:08:38.385 --> 00:08:41.540
this is a tail call, there's nothing more for fact to

143
00:08:41.540 --> 00:08:45.264
do when it calls aux of N and one than return it.

144
00:08:45.264 --> 00:08:47.480
We will reuse the stack space.

145
00:08:47.480 --> 00:08:53.705
We will replace the stack frame for fact three with the stack frame for aux three one.

146
00:08:53.705 --> 00:08:56.570
Now we're evaluating the aux function with three and

147
00:08:56.570 --> 00:08:59.960
one and when we get down here to the recursive call,

148
00:08:59.960 --> 00:09:02.779
there is no more work to do afterwards.

149
00:09:02.779 --> 00:09:04.850
This is also a tail call.

150
00:09:04.850 --> 00:09:10.139
We will reuse this stack space for the recursive call of aux two and three.

151
00:09:10.139 --> 00:09:13.490
The same thing will happen with the next recursive call and with

152
00:09:13.490 --> 00:09:18.829
the next recursive call and so we never build up a stack and when aux zero,

153
00:09:18.829 --> 00:09:22.910
six returns six, we immediately have our answer.

154
00:09:22.910 --> 00:09:28.340
So that is why this more complicated version of factorial is in fact more

155
00:09:28.340 --> 00:09:31.610
efficient and if you are planning to use factorial on

156
00:09:31.610 --> 00:09:35.375
very large numbers where you cared about this sort of efficiency,

157
00:09:35.375 --> 00:09:37.620
this would be a better way to write it.

158
00:09:37.620 --> 00:09:40.744
On the other hand if you were just computing factorial of three,

159
00:09:40.744 --> 00:09:44.599
its more complicated and I would probably prefer the simplest solution.