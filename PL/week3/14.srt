WEBVTT

1
00:00:00.000 --> 00:00:05.259
[MUSIC]

2
00:00:05.259 --> 00:00:10.209
In this segment, I want to continue our
discussion of how ML's polymorphism allows

3
00:00:10.209 --> 00:00:13.048
some types to be more
general than other types.

4
00:00:13.048 --> 00:00:16.539
And then also point out this strange
feature of ML, equality types,

5
00:00:16.539 --> 00:00:21.650
that you might accidentally run across on
homework two, and it's okay if you do.

6
00:00:21.650 --> 00:00:24.470
So, to take a simple example, suppose that

7
00:00:24.470 --> 00:00:28.280
you were required on a homework
assignment, or just as part of your job,

8
00:00:28.280 --> 00:00:33.470
to write an ML function that took two list
of strings and appended them together.

9
00:00:33.470 --> 00:00:37.540
And you went off and you wrote a wonderful
function for append like you see here.

10
00:00:37.540 --> 00:00:41.890
And you expected it to have type string
list * string list -> string list, but

11
00:00:41.890 --> 00:00:46.090
as we've seen code like this in
fact gets a polymorphic type

12
00:00:46.090 --> 00:00:49.410
of alpha list * alpha list -> alpha list.

13
00:00:49.410 --> 00:00:53.302
This is okay, your job is done and
we want to talk about why.

14
00:00:53.302 --> 00:00:57.459
Now we already know the informal story
that if you do write this code and

15
00:00:57.459 --> 00:01:01.828
it has this type, you'll be able to
call a pen with two lists of strings and

16
00:01:01.828 --> 00:01:05.092
get back a list of strings
that has four elements in it.

17
00:01:05.092 --> 00:01:09.730
Or, even though this wasn't part of your
job, you could call with two list of ints.

18
00:01:09.730 --> 00:01:14.140
But what you couldn't do is call
the list of ints and a list of strings.

19
00:01:14.140 --> 00:01:17.488
And in fact you can tell
that just from the type,

20
00:01:17.488 --> 00:01:22.761
because what I want to convince you of is
that even though this quote a this alpha,

21
00:01:22.761 --> 00:01:27.888
can be any type, it has to be the same
type throughout the overall types.

22
00:01:27.888 --> 00:01:33.125
So these three uses of alpha have to be
replaced consistently with some type,

23
00:01:33.125 --> 00:01:37.899
whether it's an int or string or
pair of ints or whatever you'd like.

24
00:01:37.899 --> 00:01:41.470
So let me explain how that works,
in general.

25
00:01:41.470 --> 00:01:46.384
We can say that the type alpha list
* alpha list -> alpha list is more

26
00:01:46.384 --> 00:01:51.385
general than the type string list
* string list -> string list, and

27
00:01:51.385 --> 00:01:56.660
in fact this polymorphic type can
be used at any less general type.

28
00:01:56.660 --> 00:02:01.470
So it could also be used at int list
* int list -> int list, but it is not

29
00:02:01.470 --> 00:02:06.230
more general than something where
the first alpha is replaced by int and

30
00:02:06.230 --> 00:02:09.950
the second alpha is replaced by string and
the third alpha is replaced by int.

31
00:02:09.950 --> 00:02:14.030
Because we did not replace
alpha consistently.

32
00:02:14.030 --> 00:02:20.473
So the general rule is,
a type t1 is more general than a type t2.

33
00:02:20.473 --> 00:02:25.063
If you can take t1,
replace it's type variable consistently so

34
00:02:25.063 --> 00:02:30.821
every alpha replace with one type, every
beta with another type either the same or

35
00:02:30.821 --> 00:02:36.100
different with what you replaced
alpha with and so on to get t2.

36
00:02:36.100 --> 00:02:40.170
So you can replace alpha with int * int,
you can replace alpha with bool and

37
00:02:40.170 --> 00:02:41.290
beta with bool.

38
00:02:41.290 --> 00:02:44.030
You can replace alpha with bool and
beta beta with int.

39
00:02:44.030 --> 00:02:49.040
You could even replace each beta with
alpha and each alpha with alpha.

40
00:02:49.040 --> 00:02:52.560
And I don't have an example of that here
but you could take a really polymorphic

41
00:02:52.560 --> 00:02:57.130
function and come up with a different
type that was a bit less general but

42
00:02:57.130 --> 00:03:00.040
still had some polymorphism in it, okay.

43
00:03:00.040 --> 00:03:02.870
So that is what we have been doing.

44
00:03:02.870 --> 00:03:07.960
Let me now combine this with a couple
other rules I have told you about before.

45
00:03:07.960 --> 00:03:11.640
Remember our whole idea that
if you see type synonyms,

46
00:03:11.640 --> 00:03:16.980
it doesn't matter whether you see the type
name or what it's a synonym for, and

47
00:03:16.980 --> 00:03:21.080
remember that with record types
the order of the field doesn't matter.

48
00:03:21.080 --> 00:03:22.490
So, here's an example on the slides,

49
00:03:22.490 --> 00:03:27.720
supposed I have some types synonyms
where type foo = int * int.

50
00:03:27.720 --> 00:03:33.400
And supposed that you write some homework
function and the type you get for

51
00:03:33.400 --> 00:03:37.940
some part of it, is some record type,
where I have a quux field of type beta,

52
00:03:37.940 --> 00:03:43.380
a bar field of type int * alpha,
and a baz field of type beta.

53
00:03:43.380 --> 00:03:48.360
Now, the question is,
is that more general than this type here,

54
00:03:48.360 --> 00:03:50.870
the second record type
you see on this slide?

55
00:03:50.870 --> 00:03:53.760
Because if I asked for
this second one, and

56
00:03:53.760 --> 00:03:59.020
you wrote something of the type first one
and it's more general, then that's okay.

57
00:03:59.020 --> 00:04:03.376
And it turns out that it is, because for
this record type to be more general than

58
00:04:03.376 --> 00:04:06.943
in the next one, it has to have
all the same fields, and it does.

59
00:04:06.943 --> 00:04:11.744
It has quux, bar, and baz, quux, bar,
and baz, and each field of the less

60
00:04:11.744 --> 00:04:16.930
general line has to be created by this
sort of consistent instantiation.

61
00:04:16.930 --> 00:04:20.460
And every beta has been
replaced by string and

62
00:04:20.460 --> 00:04:24.950
then there's bar field is even more
interesting, if you replace the alpha with

63
00:04:24.950 --> 00:04:29.580
int and it's the only alpha, so
we are replacing the alphas consistently.

64
00:04:29.580 --> 00:04:34.822
You would get int * int and
since foo is the same thing as int * int,

65
00:04:34.822 --> 00:04:40.520
indeed this second type is less
general than the first type.

66
00:04:40.520 --> 00:04:44.520
Another thing that is less general than
the first type is this written here.

67
00:04:44.520 --> 00:04:49.800
It turns out this last type is absolutely
equivalent to the middle type.

68
00:04:49.800 --> 00:04:53.473
It has all the same fields, and
all those fields have the same type.

69
00:04:53.473 --> 00:04:58.239
The only difference is, I've re-ordered
the fields, which never matters,

70
00:04:58.239 --> 00:05:01.890
and I've replaced the foo for
the type of bar with int * int.

71
00:05:01.890 --> 00:05:04.970
So, this is the sort of thing you
might have to do on homework two,

72
00:05:04.970 --> 00:05:09.240
that ML type checker tells you one thing
and you'll have to check using your own

73
00:05:09.240 --> 00:05:15.170
brain that it's more general than
the type that you needed to produce.

74
00:05:15.170 --> 00:05:17.870
So, that's one thing that
you might trip across,

75
00:05:17.870 --> 00:05:20.220
here's an even somewhat stranger thing.

76
00:05:20.220 --> 00:05:24.435
You might see some types that have
two quotes before a type variable.

77
00:05:24.435 --> 00:05:27.500
So ' ' a instead of just ' a.

78
00:05:27.500 --> 00:05:31.600
So for example, here's a type that says
I take an alpha list and an alpha and

79
00:05:31.600 --> 00:05:36.150
return a bool, but these alphas have
this extra apostrophe at the beginning.

80
00:05:36.150 --> 00:05:39.950
What that means is that
these are equality types.

81
00:05:39.950 --> 00:05:43.330
So indeed a function of this
type is polymorphic, but

82
00:05:43.330 --> 00:05:47.200
you can't replace the quote quote
alpha with any type you want.

83
00:05:47.200 --> 00:05:52.614
You can only replace it with types that
you can use the equals operator on.

84
00:05:52.614 --> 00:05:56.900
Now we have mostly only used the equal
operator for int, to compare to ints, or

85
00:05:56.900 --> 00:06:00.870
for string to see if they are the same
strings, but it turns out it works for

86
00:06:00.870 --> 00:06:01.750
a lots of types.

87
00:06:01.750 --> 00:06:02.400
It works for

88
00:06:02.400 --> 00:06:07.170
tuples as long as all the pieces of
the tuples are themselves equality types.

89
00:06:07.170 --> 00:06:11.180
But not everything is an equality type,
it turns out that ML in order to enforce

90
00:06:11.180 --> 00:06:15.780
good style doesn't let you compare values
of type real floating point numbers with

91
00:06:15.780 --> 00:06:18.740
equals, because that's pretty
much always a bad idea, and

92
00:06:18.740 --> 00:06:21.550
doesn't let you compare
function types with equals.

93
00:06:21.550 --> 00:06:24.170
Something that will get
into in subsequent segments

94
00:06:24.170 --> 00:06:27.740
when we're passing functions
to other functions and stuff.

95
00:06:27.740 --> 00:06:30.160
So, the rules are exactly the same.

96
00:06:30.160 --> 00:06:32.107
If you see a type like this, it works for

97
00:06:32.107 --> 00:06:35.127
any type as long as you instantiate
the alpha consistently.

98
00:06:35.127 --> 00:06:38.575
But certain instantiations
won't be allowed.

99
00:06:38.575 --> 00:06:41.540
So this is a rather strange feature of ML.

100
00:06:41.540 --> 00:06:46.418
It basically treats this equal operator
specially, has special support in the type

101
00:06:46.418 --> 00:06:50.207
system for things that can be
compared with the equals operator.

102
00:06:50.207 --> 00:06:54.321
And it's not something that I plan to
study in depth, but in case you see it,

103
00:06:54.321 --> 00:06:56.920
I wanted to prepare you for it.

104
00:06:56.920 --> 00:06:59.440
Here's a very short example
of how it may come up.

105
00:06:59.440 --> 00:07:02.890
Suppose you wrote this function,
which is takes an x and a y, and

106
00:07:02.890 --> 00:07:06.190
if they're the same turns the string yes,
or else is string no, and

107
00:07:06.190 --> 00:07:10.010
maybe you thought you were intending x and
y to type int, but instead,

108
00:07:10.010 --> 00:07:14.780
you will get a type like
' ' a * ' ' a -> string.

109
00:07:14.780 --> 00:07:19.330
You would also get a warning from the ML
type checker about calling polyEqual.

110
00:07:19.330 --> 00:07:21.270
You can ignore that warning.

111
00:07:21.270 --> 00:07:23.910
But you might not ever
see this sort of warning.

112
00:07:23.910 --> 00:07:29.000
So here's the second function that uses
the equals operator on this argument x.

113
00:07:29.000 --> 00:07:30.660
But since it compares x to 3,

114
00:07:30.660 --> 00:07:35.820
the type checker knows that you can only
ever compare two things of the same type.

115
00:07:35.820 --> 00:07:37.630
That's the typing rule for equals.

116
00:07:37.630 --> 00:07:39.582
So in fact x has to have type int.

117
00:07:39.582 --> 00:07:42.833
You would see that over all this
function has type int error string,

118
00:07:42.833 --> 00:07:45.629
because it must take an int and
it must return a string, and

119
00:07:45.629 --> 00:07:49.180
there is nowhere we had equality
types anywhere to be seen.

120
00:07:49.180 --> 00:07:51.262
So those are the strange
things to look for.

121
00:07:51.262 --> 00:07:55.510
There's a very nice precise rule of one
type being more general than another, and

122
00:07:55.510 --> 00:07:59.630
you'll now get a lot less confused
if you see unexpected polymorphosis

123
00:07:59.630 --> 00:08:00.400
on your next homework