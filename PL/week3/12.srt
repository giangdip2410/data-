WEBVTT

1
00:00:00.000 --> 00:00:05.204
[MUSIC]

2
00:00:05.204 --> 00:00:08.405
Okay, welcome to one of my favorite
segments in the entire course,

3
00:00:08.405 --> 00:00:12.003
whereby extending our definition of
pattern-matching just a little bit,

4
00:00:12.003 --> 00:00:15.940
we're gonna learn the truth about
a lot of what we've been doing.

5
00:00:15.940 --> 00:00:20.030
So what we're about to find out is that
we've been using a lot more syntactic

6
00:00:20.030 --> 00:00:23.390
sugar in our ML programs
than we even realized.

7
00:00:23.390 --> 00:00:25.530
That in fact, every value binding and

8
00:00:25.530 --> 00:00:29.108
every function binding can
use pattern-matching, and

9
00:00:29.108 --> 00:00:34.440
that in ML, as a result,
every function takes exactly one argument.

10
00:00:34.440 --> 00:00:36.360
Not zero, not two, not three.

11
00:00:36.360 --> 00:00:40.710
And this is a very flexible,
elegant way to design your language.

12
00:00:40.710 --> 00:00:43.160
But before we get to
that great punch line,

13
00:00:43.160 --> 00:00:47.250
I need to extend our definition
of pattern-matching a little bit.

14
00:00:47.250 --> 00:00:53.115
So so far, we used pattern-matching only
on our one of types, on our data type

15
00:00:53.115 --> 00:00:58.185
bindings, and that's because we
needed some way to access the values.

16
00:00:58.185 --> 00:01:02.515
The only way we could take something
that had one of our data type types,

17
00:01:02.515 --> 00:01:04.975
see which constructor it was built from,
and

18
00:01:04.975 --> 00:01:08.190
get the underlying pieces out,
was with pattern-matching.

19
00:01:08.190 --> 00:01:09.960
And that's still the case, but

20
00:01:09.960 --> 00:01:14.300
it turns out that pattern-matching
also works for each-of types.

21
00:01:14.300 --> 00:01:18.280
It works for records, and since tuples
are always just syntactic sugar for

22
00:01:18.280 --> 00:01:20.840
records, it works for tuples as well.

23
00:01:20.840 --> 00:01:24.620
So let me tell you how that works, and
then I'll show you a number of examples

24
00:01:24.620 --> 00:01:28.940
which we'll use in increasingly
good style as we go along.

25
00:01:28.940 --> 00:01:31.150
So here's a new kind of pattern.

26
00:01:31.150 --> 00:01:35.020
What you can do,
is in a place where you put a pattern,

27
00:01:35.020 --> 00:01:40.430
you can put a tuple pattern, which looks
a little bit like a tuple expression,

28
00:01:40.430 --> 00:01:43.670
except between the commas
we have variables.

29
00:01:43.670 --> 00:01:47.700
And what that's going to do, is if you
pattern match one of those expressions

30
00:01:47.700 --> 00:01:51.220
against a tuple value, it will bind.

31
00:01:51.220 --> 00:01:55.850
It will introduce a local variable where
x1 is the first component of the tuple,

32
00:01:55.850 --> 00:01:58.480
x2 is the second component
of the tuple and so on,

33
00:01:58.480 --> 00:02:02.190
up to xn being matched against
the last component of the tuple.

34
00:02:02.190 --> 00:02:06.300
And the type checker will insist that the
number of pieces of your tuple correspond

35
00:02:06.300 --> 00:02:08.760
to the number of variables
in your pattern.

36
00:02:08.760 --> 00:02:10.960
You're not allowed to mess that up.

37
00:02:10.960 --> 00:02:15.800
Similarly for records, we have a new kind
of pattern where you write field name

38
00:02:15.800 --> 00:02:20.130
equal variable name,
separated by commas inside of braces, and

39
00:02:20.130 --> 00:02:24.460
that matches a record value that
has those same field names.

40
00:02:24.460 --> 00:02:27.430
As usual the order of the field
names doesn't matter.

41
00:02:27.430 --> 00:02:31.640
And what happens when you do this match,
is the variable x1 will be bound to

42
00:02:31.640 --> 00:02:37.750
the value in the f1 field,
x2 in the f2 field, and so on, all right?

43
00:02:37.750 --> 00:02:40.890
So that was a little abstract,
let's see some examples.

44
00:02:40.890 --> 00:02:45.250
This is poor style, but it helps explain
how the pattern-matching works, and

45
00:02:45.250 --> 00:02:47.009
we'll get to the better
style in just a second.

46
00:02:48.250 --> 00:02:53.260
So first, suppose I had a triple,
a threetuple, where each component

47
00:02:53.260 --> 00:02:57.450
was an integer, and I just want a little
function to add those three numbers up.

48
00:02:57.450 --> 00:03:00.530
So what I could do,
is I could have a function sum_triple,

49
00:03:00.530 --> 00:03:03.790
that took in some argument,
call it triple.

50
00:03:03.790 --> 00:03:07.210
Then I could have a case
expression where my pattern

51
00:03:07.210 --> 00:03:11.035
matches against tuples
that have three parts.

52
00:03:11.035 --> 00:03:16.430
And in fact, since I use x, y, and z to
bind to the corresponding three pieces

53
00:03:16.430 --> 00:03:21.991
of data inside that triple, I can use
those variables on the right-hand side,

54
00:03:21.991 --> 00:03:26.732
and since I add them together,
those pieces must all have type int.

55
00:03:26.732 --> 00:03:31.833
And so the type of sum_triple is int
star int star int, the type of three,

56
00:03:31.833 --> 00:03:37.455
in tuples holding three integer things,
and the return type is int, all right?

57
00:03:37.455 --> 00:03:40.400
And similarly here's a function full_name.

58
00:03:40.400 --> 00:03:44.940
It takes a record where you have
fields first, middle, and last.

59
00:03:44.940 --> 00:03:46.580
Here I'm concatenating them all.

60
00:03:46.580 --> 00:03:50.950
This caret character is ML's operator for
concatenating strings, so

61
00:03:50.950 --> 00:03:55.440
in fact, the three fields are going
to have to hold data of type string.

62
00:03:55.440 --> 00:03:59.965
And this pattern here is extracting,
it's binding to x whatever is in the first

63
00:03:59.965 --> 00:04:03.004
field, binding to y whatever
is in the middle field,

64
00:04:03.004 --> 00:04:05.652
and binding to z whatever
is in the last field.

65
00:04:05.652 --> 00:04:09.157
So we're using pattern-matching
to get the pieces out,

66
00:04:09.157 --> 00:04:13.104
we're just doing it on each-of types,
instead of one of types.

67
00:04:13.104 --> 00:04:13.656
Okay, so

68
00:04:13.656 --> 00:04:19.020
now let me tell you another feature that
gives us a better way to write this down.

69
00:04:19.020 --> 00:04:22.750
So it turns out, ever since
the very beginning of section one,

70
00:04:22.750 --> 00:04:29.840
I told you that val-bindings were written
by val variable name equals expression.

71
00:04:29.840 --> 00:04:32.970
And it turns out that's true,
but it's not the whole truth.

72
00:04:32.970 --> 00:04:38.140
That what you can actually write
is val pattern equals expression,

73
00:04:38.140 --> 00:04:42.630
and variables are just a special kind
of pattern, where the variable matches

74
00:04:42.630 --> 00:04:47.790
against the entire result of
evaluating the expression e.

75
00:04:47.790 --> 00:04:50.260
But if you put a different pattern there,

76
00:04:50.260 --> 00:04:56.200
then it will match against the expression
e as well, and extract the various pieces.

77
00:04:56.200 --> 00:05:00.000
This is great for
extracting the pieces of an each-of type,

78
00:05:00.000 --> 00:05:02.890
you can even only get some of
the pieces out that you need.

79
00:05:02.890 --> 00:05:06.520
It's bad style to do this where that e

80
00:05:06.520 --> 00:05:10.010
is one of the constructors
of a data type binding.

81
00:05:10.010 --> 00:05:13.434
And the reason is, this is gonna
be like a one-arm case expression,

82
00:05:13.434 --> 00:05:15.990
a case expression with only one branch.

83
00:05:15.990 --> 00:05:19.860
That's great for each-of types,
cuz you only want one branch, but for

84
00:05:19.860 --> 00:05:22.570
data types you really want
all the different branches.

85
00:05:22.570 --> 00:05:27.580
If you just put one here, you will get
an error at run time if you're wrong,

86
00:05:27.580 --> 00:05:31.674
and you're giving up the advantage of
using case expressions where the type

87
00:05:31.674 --> 00:05:35.480
checker makes sure you cover
all the possibilities.

88
00:05:35.480 --> 00:05:39.250
Okay, so
here's how our examples would look now.

89
00:05:39.250 --> 00:05:41.540
Instead of using a one-arm
case expression,

90
00:05:41.540 --> 00:05:45.980
which is bad style,
let's use a let expression instead.

91
00:05:45.980 --> 00:05:49.790
So now my function sum_triple is
gonna take in this triple, and

92
00:05:49.790 --> 00:05:53.640
what I'm gonna do is pattern match
it with this val binding here.

93
00:05:53.640 --> 00:05:55.694
So that will indeed evaluate triple.

94
00:05:55.694 --> 00:05:59.800
It will look up triple in a dynamic
environment, it's gonna get some value,

95
00:05:59.800 --> 00:06:03.520
and it's gonna make sure that x is bound
to the first piece, y to the second piece,

96
00:06:03.520 --> 00:06:04.880
z to the third piece.

97
00:06:04.880 --> 00:06:09.330
Then x, y and z will all be local
variables that are in scope in this let

98
00:06:09.330 --> 00:06:11.595
expression, and I can add them together.

99
00:06:11.595 --> 00:06:16.865
So the type checker will make sure that
indeed triple is a tuple with three parts,

100
00:06:16.865 --> 00:06:17.905
all of type int,

101
00:06:17.905 --> 00:06:21.853
because otherwise the rest of this
expression wouldn't type check.

102
00:06:21.853 --> 00:06:26.945
And my full_name function works similarly,
except now I have a record pattern, and

103
00:06:26.945 --> 00:06:31.065
since I'm concatenating x, y, and
z, r has to be a record that has

104
00:06:31.065 --> 00:06:34.960
exactly the fields first, middle,
and last, all holding strings.

105
00:06:34.960 --> 00:06:40.660
So this is actually quite nice style, but
I'm gonna show you something even better.

106
00:06:40.660 --> 00:06:43.910
So here's the final version of how
I wanna write these things, and

107
00:06:43.910 --> 00:06:46.350
I have to tell you one
more truth about ML.

108
00:06:47.370 --> 00:06:53.370
It turns out that a function argument can
be a pattern and not just a variable.

109
00:06:53.370 --> 00:06:57.350
So the same way I used to tell you
that function bindings looked like

110
00:06:57.350 --> 00:07:00.730
name of function variable equals body,

111
00:07:00.730 --> 00:07:04.240
it turns out what goes right
there is actually a pattern.

112
00:07:04.240 --> 00:07:05.830
Again if it's just a variable,

113
00:07:05.830 --> 00:07:09.480
it's gonna be matched against the entire
argument to the function, but

114
00:07:09.480 --> 00:07:13.410
if it's a pattern, we'll go ahead and
extract pieces of the argument.

115
00:07:13.410 --> 00:07:16.885
So now what I have are these
beautiful functions.

116
00:07:16.885 --> 00:07:22.130
Sum_triple takes an argument that
will then be pattern-matched

117
00:07:22.130 --> 00:07:27.160
against this tuple pattern, binding x to
the first piece, y to the second piece, z

118
00:07:27.160 --> 00:07:31.460
to the third piece, and then the body can
do whatever it wants, add them together.

119
00:07:31.460 --> 00:07:32.550
Full names similarly,

120
00:07:32.550 --> 00:07:36.350
will have to be passed something
that can match against this pattern.

121
00:07:36.350 --> 00:07:40.680
Only record expressions with first, middle
and last fields will match appropriately,

122
00:07:40.680 --> 00:07:43.690
and since x, y and
z are used as strings in the body,

123
00:07:43.690 --> 00:07:48.030
the type checker will require full_name
to take a record where first, middle,

124
00:07:48.030 --> 00:07:52.560
and last all hold values of type string,
okay?

125
00:07:52.560 --> 00:07:56.310
So now that we can do this, and
now that we have pattern-matching for

126
00:07:56.310 --> 00:07:58.120
extracting pieces of tuples and

127
00:07:58.120 --> 00:08:02.550
records, we can write this much
more concise, elegant, simple code.

128
00:08:02.550 --> 00:08:06.145
And to make sure you get practice with
this, we're gonna have a rule on Homework

129
00:08:06.145 --> 00:08:10.780
2, which says that you're not allowed
to use anything with the # character,

130
00:08:10.780 --> 00:08:14.220
this pound character on your keyboard,
Shift+3 for me.

131
00:08:14.220 --> 00:08:18.486
That's how we used to get pieces of
tuples out, with hash one and hash two,

132
00:08:18.486 --> 00:08:22.143
how we used to get pieces of records
out with hash fieldname, but

133
00:08:22.143 --> 00:08:26.072
on Homework 2 we want you to instead
always use pattern-matching,

134
00:08:26.072 --> 00:08:28.201
cuz that's what we're working on.

135
00:08:28.201 --> 00:08:32.226
And one of the nice benefits, is because
you're writing down these patterns,

136
00:08:32.226 --> 00:08:35.950
the type checker will always be able
to figure out the type of thing you're

137
00:08:35.950 --> 00:08:40.034
matching against, so you will no longer
need to write down any explicit types for

138
00:08:40.034 --> 00:08:44.650
the arguments to your functions or any
other variables that you're using, okay?

139
00:08:44.650 --> 00:08:48.990
So now that we know how to do this,
let me switch over to the code and

140
00:08:48.990 --> 00:08:51.310
show you something really interesting.

141
00:08:51.310 --> 00:08:54.763
So here in the file I have the three
versions of both full_name and

142
00:08:54.763 --> 00:08:56.410
sum_triple we've been working on.

143
00:08:56.410 --> 00:09:00.694
So this first version is bad style cuz it
uses one-armed branches which don't make

144
00:09:00.694 --> 00:09:01.880
a lot of sense.

145
00:09:01.880 --> 00:09:06.050
The second version is okay because
it uses a val binding instead,

146
00:09:06.050 --> 00:09:10.230
and then this third version is
the simple one where in fact,

147
00:09:10.230 --> 00:09:14.570
we put the pattern directly
in the function argument.

148
00:09:14.570 --> 00:09:18.730
Now these are just three ways of
implementing the same thing, so

149
00:09:18.730 --> 00:09:21.890
one is really syntactic sugar if you like,
for another.

150
00:09:21.890 --> 00:09:25.150
So if I go over here and run this, or

151
00:09:25.150 --> 00:09:30.830
at least load all these things in,
you'll see that

152
00:09:30.830 --> 00:09:36.262
all three versions of sum_triple have type
give me a tuple that takes three ints and

153
00:09:36.262 --> 00:09:41.930
returns an int, and that's the type of all
three versions of sum_triple you see here.

154
00:09:41.930 --> 00:09:46.270
And similarly for full_name, they
always take in a record of first, last,

155
00:09:46.270 --> 00:09:48.170
middle, string and return a string.

156
00:09:48.170 --> 00:09:52.520
And indeed, these are three ways
of writing the same thing, so

157
00:09:52.520 --> 00:09:57.300
you get a 12 if you do it that way,
and I'll try one other here.

158
00:09:57.300 --> 00:10:00.100
You get a 12 if you do it this way.

159
00:10:00.100 --> 00:10:02.820
So in all cases take a triple,
return an int.

160
00:10:02.820 --> 00:10:06.580
But, I hope some of you are almost
ready to jump out of your chair saying,

161
00:10:06.580 --> 00:10:08.650
wait a minute, wait a minute,
wait a minute,

162
00:10:08.650 --> 00:10:12.880
let's look at this third possibility here,
this sum_triple.

163
00:10:12.880 --> 00:10:18.350
That looks to me like a function
that takes three arguments.

164
00:10:18.350 --> 00:10:20.330
That's how we used to write things
that take three arguments, and

165
00:10:20.330 --> 00:10:25.030
now you're telling me that it's a function
that takes one triple as an argument, so

166
00:10:25.030 --> 00:10:27.930
how can ML tell which
of it I'm trying to do?

167
00:10:27.930 --> 00:10:30.410
When I define the function there and
also, oh sorry,

168
00:10:30.410 --> 00:10:35.350
when I call it as I meant to here with
the third version, not the first one,

169
00:10:35.350 --> 00:10:39.290
how does it know to pass in one triple and
pattern match against it,

170
00:10:39.290 --> 00:10:43.880
instead of passing in three arguments,
a 3, a 4, and a 5, okay?

171
00:10:43.880 --> 00:10:46.300
So let me put this another way.

172
00:10:46.300 --> 00:10:52.220
Here on the top of the slide is a function
that takes one triple of type int*int*int,

173
00:10:52.220 --> 00:10:53.210
and returns an int, and

174
00:10:53.210 --> 00:10:56.870
it does it via pattern-matching,
as I've just taught you in this segment.

175
00:10:56.870 --> 00:11:01.520
Here on the bottom, is a function
that like we learned a long time ago,

176
00:11:01.520 --> 00:11:06.080
takes three arguments, x, y, and z,
and adds them together and returns it.

177
00:11:06.080 --> 00:11:09.030
So if you see some difference
between the top half and

178
00:11:09.030 --> 00:11:13.450
the bottom half, you're seeing something I
don't, because they're exactly the same.

179
00:11:13.450 --> 00:11:18.810
And in fact, Every function in ML
takes one argument, not three, and

180
00:11:18.810 --> 00:11:23.750
we've actually been using pattern-matching
all along, I just didn't tell you.

181
00:11:23.750 --> 00:11:25.421
So here is the big truth.

182
00:11:25.421 --> 00:11:29.731
In ML, every function takes
exactly one argument, and

183
00:11:29.731 --> 00:11:34.685
what we have been calling
multi-argument functions are really

184
00:11:34.685 --> 00:11:38.916
just functions that take one
argument that is a tuple.

185
00:11:38.916 --> 00:11:44.170
And those functions are implemented by
using pattern-matching on that tuple so

186
00:11:44.170 --> 00:11:47.580
that you get the different
pieces of that tuple out.

187
00:11:47.580 --> 00:11:51.186
This is extremely elegant and
flexible, and I'm not gonna kid you.

188
00:11:51.186 --> 00:11:56.048
Everyone when they talk about ML code,
talks about a multi-argument function,

189
00:11:56.048 --> 00:12:00.002
a three argument function,
a four argument function, and so on.

190
00:12:00.002 --> 00:12:03.563
But we know that what's really
going on in terms of the language,

191
00:12:03.563 --> 00:12:05.720
is that that's just syntactic sugar.

192
00:12:05.720 --> 00:12:08.650
We're passing one argument that
is a tuple, and then we're using

193
00:12:08.650 --> 00:12:13.780
pattern matching to get the pieces out,
and this is actually a useful thing to do.

194
00:12:13.780 --> 00:12:16.470
So I have a short example here on
the slide that I'll use to finish up

195
00:12:16.470 --> 00:12:17.540
this segment.

196
00:12:17.540 --> 00:12:22.920
Here is a very simple program
to rotate the pieces of a tuple.

197
00:12:22.920 --> 00:12:28.065
So how about I just implement that
real fast over here, rotate_left

198
00:12:28.065 --> 00:12:34.880
(x,y,z) = (y,z,x), all right?

199
00:12:34.880 --> 00:12:39.884
So now if I call rotate_left (3,4,5),

200
00:12:39.884 --> 00:12:47.399
and I actually spell it correctly,
I get (4,5,3), all right?

201
00:12:47.399 --> 00:12:52.519
So I took in some tuple, and I returned
a tuple, and that's all great, but

202
00:12:52.519 --> 00:12:57.639
what I could do is I could take that
thing that was returned, and pass it into

203
00:12:57.639 --> 00:13:03.412
another function, like rotate_left,
in which case I would get (5,3,4),

204
00:13:03.412 --> 00:13:08.128
or directly into say sum_triple3,
in which case I should still get

205
00:13:08.128 --> 00:13:13.690
12 because the order doesn't matter
when you're summing things up.

206
00:13:13.690 --> 00:13:16.310
This is something you can't do in
a lot of programming languages.

207
00:13:16.310 --> 00:13:21.270
It's usually very awkward to return
multiple things from one function, and

208
00:13:21.270 --> 00:13:25.770
immediately pass them to another,
but in ML every function takes and

209
00:13:25.770 --> 00:13:27.135
returns one argument.

210
00:13:27.135 --> 00:13:30.830
Rotate_left takes one
triple as an argument, so

211
00:13:30.830 --> 00:13:35.810
if I have some expression that returns
a triple, like rotate_left does,

212
00:13:35.810 --> 00:13:39.850
I can immediately take that thing and
pass it to another function.

213
00:13:39.850 --> 00:13:42.580
So I have another example
here on the slide which is,

214
00:13:42.580 --> 00:13:47.980
I could write a rotate_right function
that takes in some triple t,

215
00:13:47.980 --> 00:13:51.000
and just implements it by
rotate_left(rotate_left t),

216
00:13:51.000 --> 00:13:55.280
cuz it turns out if you have a triple,
two left rotations is one right rotation.

217
00:13:55.280 --> 00:13:59.150
So it's a silly example, but
it's nonetheless an elegant example of how

218
00:13:59.150 --> 00:14:05.150
having this policy of every function takes
and returns one argument, it becomes much

219
00:14:05.150 --> 00:14:10.230
easier to take the results of one function
and pass them directly to another.

220
00:14:10.230 --> 00:14:12.810
So now we know the truth
about ML functions.

221
00:14:12.810 --> 00:14:14.390
Everything takes one argument.

222
00:14:14.390 --> 00:14:18.810
This is one of those great segments where
we made our language bigger by adding new

223
00:14:18.810 --> 00:14:22.451
kinds of patterns,
pattern-matching over each-of types, but

224
00:14:22.451 --> 00:14:26.936
as a result we made our language smaller,
because we now know that there's no need

225
00:14:26.936 --> 00:14:30.140
to have a special concept of
multi-argument functions.