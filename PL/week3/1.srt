WEBVTT

1
00:00:04.940 --> 00:00:07.123
Okay. 
What I want to do in this segment, is 

2
00:00:07.123 --> 00:00:10.235
give a general way to think about how to 
build new types. 

3
00:00:10.235 --> 00:00:13.347
In fact this is going to be more general 
than even in ML. 

4
00:00:13.347 --> 00:00:17.114
But we're going to be able to use this 
idea, these concepts, to better 

5
00:00:17.114 --> 00:00:19.570
understand what it is we've been doing in 
ML. 

6
00:00:19.570 --> 00:00:23.228
And what we're going to, going to 
continue to be doing in the upcoming 

7
00:00:23.228 --> 00:00:26.610
segments. 
So the way I want you to think about all 

8
00:00:26.610 --> 00:00:30.190
the types out there is that there are 
base types and compound types. 

9
00:00:30.190 --> 00:00:35.674
So base types are things like int, bool, 
unit, char, real that describes sort of 

10
00:00:35.674 --> 00:00:40.802
the basic values in your language. 
And then compound types, are ways that 

11
00:00:40.802 --> 00:00:44.719
you build new types with other types 
inside of them. 

12
00:00:44.719 --> 00:00:50.559
So tuples, are compound types because we 
can take any t1 and t2 and make a pair of 

13
00:00:50.559 --> 00:00:54.548
a t1 and a t2. 
Lists and options are also compound types 

14
00:00:54.548 --> 00:00:59.890
because we have a t list for some type t 
or an option type for some type t. 

15
00:00:59.890 --> 00:01:03.426
And in the upcoming segments we're 
going to learn new ways to make our own 

16
00:01:03.426 --> 00:01:05.931
compound types. 
We're going to learn records, and we're 

17
00:01:05.931 --> 00:01:08.780
going to learn data types, which are even 
more interesting. 

18
00:01:08.780 --> 00:01:13.296
But before we get there I want to take 
this step back and basically tell you 

19
00:01:13.296 --> 00:01:17.753
that in any programming language there 
are really three fundamental ways to 

20
00:01:17.753 --> 00:01:22.211
build compound types out of other types 
that are part of the pieces and all 

21
00:01:22.211 --> 00:01:26.551
though these aren't the standard names 
I'm going to call them each of, one of, 

22
00:01:26.551 --> 00:01:29.981
and self reference. 
So when you build an each of type, the 

23
00:01:29.981 --> 00:01:36.257
entire idea is to build a new type T 
where values of type T have each of some 

24
00:01:36.257 --> 00:01:41.406
other collections of type. 
So if it were a triple with a T1, a T2, 

25
00:01:41.406 --> 00:01:45.187
and a T3, 
that would be an each of type because 

26
00:01:45.187 --> 00:01:50.980
values of that compound have a T1 and 
they have a T2 and they have a T3. 

27
00:01:50.980 --> 00:01:56.182
Conversely, a one of type, is a type 
where a value of the new type has either 

28
00:01:56.182 --> 00:02:01.385
a tau one or a tau of two, a T two, or a 
T three for some collection of types. 

29
00:02:01.385 --> 00:02:06.793
I'll sometimes say tau, the Greek letter 
that's closest to T for types, it's all 

30
00:02:06.793 --> 00:02:07.715
the same. 
Okay? 

31
00:02:07.715 --> 00:02:12.353
And the third way you can build a new 
type is with some notion of recursion. 

32
00:02:12.353 --> 00:02:17.052
So, if you just add each of and one of, 
you can't describe things like list or 

33
00:02:17.052 --> 00:02:19.743
trees. 
Because values of a list type include 

34
00:02:19.743 --> 00:02:23.940
other lists that are smaller. 
And so you need some way to say an int 

35
00:02:23.940 --> 00:02:28.014
list is either the empty list or it's an 
int and another int list. 

36
00:02:28.014 --> 00:02:32.149
So you need that self reference. 
And what's remarkable is, once your 

37
00:02:32.149 --> 00:02:35.420
programming language supports some way to 
do each of. 

38
00:02:35.420 --> 00:02:38.815
Some way to do one of, 
and one way to do self reference, 

39
00:02:38.815 --> 00:02:43.937
you have an amazing way to describe a lot 
of interesting data in terms of types. 

40
00:02:43.937 --> 00:02:48.258
And that's why pretty much every 
programming language has some way to 

41
00:02:48.258 --> 00:02:51.154
build these kinds of compound types. 
All right. 

42
00:02:51.154 --> 00:02:56.619
So in terms of examples we've seen, as I 
mentioned tuples pretty directly capture 

43
00:02:56.619 --> 00:03:00.668
the idea of each of. 
If you have int str boule that contains 

44
00:03:00.668 --> 00:03:04.429
an int and a boule. 
Options really are a one of type, but 

45
00:03:04.429 --> 00:03:09.789
their a bit of a strange example, because 
you either have something, or you don't. 

46
00:03:09.789 --> 00:03:14.613
So, there's always this or involved. 
So, int option, either contains an int, 

47
00:03:14.613 --> 00:03:19.236
or it does not contain and int. 
That's an or, there's no each over and 

48
00:03:19.236 --> 00:03:22.481
involved. 
And then when we create a list it turns 

49
00:03:22.481 --> 00:03:27.500
out it uses all three building blocks. 
So an int list, if you just say it out 

50
00:03:27.500 --> 00:03:31.925
loud has all three concepts. 
An int list either contains an int and 

51
00:03:31.925 --> 00:03:35.491
another int list. 
So that's each off in self reference. 

52
00:03:35.491 --> 00:03:38.860
Or it contains no data. 
And that's the one of idea. 

53
00:03:38.860 --> 00:03:43.477
Alright and of course these things can 
nest arbitrarily to let us describe 

54
00:03:43.477 --> 00:03:47.663
interesting shapes of data. 
So there's an example here on the bottom 

55
00:03:47.663 --> 00:03:52.157
of the slide where either we have some 
data or we don't and that data is 

56
00:03:52.157 --> 00:03:56.035
described by two things. 
Either a pair of ints or nothing and a 

57
00:03:56.035 --> 00:04:00.960
list of a list of ints which itself can 
be described in terms of each of, one of 

58
00:04:00.960 --> 00:04:04.161
and self reference. 
So where we're going with this is I'm 

59
00:04:04.161 --> 00:04:07.691
about to show you how to another way to 
build each of types in ML. 

60
00:04:07.691 --> 00:04:10.952
And that's going to be records. 
Records are a lot like tuples, 

61
00:04:10.952 --> 00:04:15.337
except they have named fields instead of 
a first position, a second position and a 

62
00:04:15.337 --> 00:04:18.171
third position. 
And we're going to see, they're so much 

63
00:04:18.171 --> 00:04:22.502
like tuples, that we can describe tuples 
in terms of records using this important 

64
00:04:22.502 --> 00:04:26.082
idea called syntactic sugar. 
After that we're going to see a way to 

65
00:04:26.082 --> 00:04:30.594
build our own one-of types, so if you 
look at that previous slide, we can build 

66
00:04:30.594 --> 00:04:35.338
our own each-of types with int str bool, 
but for one-of types so far, we only have 

67
00:04:35.338 --> 00:04:38.508
options and lists. 
ML has a great way to define our own 

68
00:04:38.508 --> 00:04:42.056
types that maybe say either you have an 
end or you have a string. 

69
00:04:42.056 --> 00:04:46.259
We don't have a way to do that yet. 
And once we have such types we need a way 

70
00:04:46.259 --> 00:04:49.534
to access the pieces. 
And we're going to use what will probably 

71
00:04:49.534 --> 00:04:53.955
seem very unusual to you if you've only 
programmed in Java or C or Python before. 

72
00:04:53.955 --> 00:04:56.302
And that's a thing called pattern 
matching. 

73
00:04:56.302 --> 00:04:59.849
It's incredibly powerful. 
And we'll get comfortable using it even 

74
00:04:59.849 --> 00:05:02.524
though it's not like anything you've seen 
before. 

75
00:05:02.524 --> 00:05:06.345
And then much later in the course we'll 
get around to object oriented 

76
00:05:06.345 --> 00:05:09.035
programming. 
Because you might be thinking, wait a 

77
00:05:09.035 --> 00:05:11.620
minute, 
I know how to program in Java, or C plus, 

78
00:05:11.620 --> 00:05:13.490
plus. 
I've never seen one of types. 

79
00:05:13.490 --> 00:05:15.973
It turns out you have seen one of the 
types, 

80
00:05:15.973 --> 00:05:20.262
but OOP, Object Oriented Programming, 
does them in a very different way, using 

81
00:05:20.262 --> 00:05:23.083
sub-classes and sub-types. 
It's a very elegant way. 

82
00:05:23.083 --> 00:05:26.751
In fact it's the exact opposite way that 
languages like ML do it. 

83
00:05:26.751 --> 00:05:30.194
And once we've seen both we'll be able to 
make that contrast. 

84
00:05:30.194 --> 00:05:34.314
And it's one of the most fun in general 
takeaway lessons from the course. 