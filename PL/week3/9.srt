WEBVTT

1
00:00:00.000 --> 00:00:04.590
[MUSIC] In this segment, I want to 
introduce type synonyms which are a 

2
00:00:04.590 --> 00:00:07.492
seperate thing from what we've seen 
before. 

3
00:00:07.492 --> 00:00:12.082
And a bit of a digression, of a 
digression from data type bindings and 

4
00:00:12.082 --> 00:00:17.685
case expressions but nonetheless helpful 
for the next homework and a nice contrast 

5
00:00:17.685 --> 00:00:21.870
with data type bindings. 
So, data type bindings introduce a new 

6
00:00:21.870 --> 00:00:25.380
type name. 
And that new type is different from every 

7
00:00:25.380 --> 00:00:28.890
other type. 
The only way to make things of that type 

8
00:00:28.890 --> 00:00:33.210
is with the constructors that are part of 
the data type binding. 

9
00:00:33.210 --> 00:00:38.047
A type synonym is a new construct I'm 
showing you now for the first time. 

10
00:00:38.047 --> 00:00:43.017
And all you do is you write type, so 
that's a new keyword, not datatype, just 

11
00:00:43.017 --> 00:00:45.867
type. 
The name for the type, then equals, and 

12
00:00:45.867 --> 00:00:49.680
then another type. 
And what I want to emphasize is that the 

13
00:00:49.680 --> 00:00:55.128
English word synonym is perfect here. 
It just creates another name for the same 

14
00:00:55.128 --> 00:00:59.887
type that was already there. 
And so now, we can use that name wherever 

15
00:00:59.887 --> 00:01:03.680
we were using t. 
And we can use t wherever we might use 

16
00:01:03.680 --> 00:01:06.922
that name. 
They're interchangeable in every way. 

17
00:01:06.922 --> 00:01:11.473
And I even want you to not worry about 
which one the repel prints. 

18
00:01:11.473 --> 00:01:15.956
The two things, the type t and the name, 
a name really can be used 

19
00:01:15.956 --> 00:01:19.453
interchangeably. 
So, let's go over to some ml codes so I 

20
00:01:19.453 --> 00:01:23.566
can show you how this works. 
So first, I have two datatype bindings 

21
00:01:23.566 --> 00:01:28.292
that we've seen before for suit and rank 
and those behave just like they did 

22
00:01:28.292 --> 00:01:30.870
before. 
But now, I also have a type synonym, 

23
00:01:30.870 --> 00:01:36.142
where I kind of remind myself and allow 
myself to use in the program that 

24
00:01:36.142 --> 00:01:41.700
wherever I have a suit paired with a 
rank, I can think of that as a type named 

25
00:01:41.700 --> 00:01:44.978
card. 
So, the type card is a new type name that 

26
00:01:44.978 --> 00:01:49.894
will now be in my environment and it 
means the pair of suit and rank. 

27
00:01:49.894 --> 00:01:54.170
So, I could write suit star rank or card 
and that'll be fine. 

28
00:01:54.170 --> 00:01:58.550
Another common idiom by the way, that I'm 
not going to use in the rest of the file 

29
00:01:58.550 --> 00:02:02.098
but I wanted to show is Is to give a name 
to your record types. 

30
00:02:02.098 --> 00:02:06.257
It's a huge pain to write down this 
record type anywhere or to remember, or 

31
00:02:06.257 --> 00:02:10.027
to even give a name for it. 
So, instead of just having a comment that 

32
00:02:10.027 --> 00:02:14.352
says, this record is for describing the 
names of people in my class along with 

33
00:02:14.352 --> 00:02:17.179
their student numbers, 
I can go ahead in my program. 

34
00:02:17.179 --> 00:02:20.672
give a name to that type, 
and then, use that type name wherever I 

35
00:02:20.672 --> 00:02:21.303
want, 
okay? 

36
00:02:21.303 --> 00:02:25.689
So now, let me really emphasize this 
interchangeability aspect. 

37
00:02:25.689 --> 00:02:28.943
So, here is a short function I wrote 
called is_Queen_of_Spades. 

38
00:02:30.075 --> 00:02:34.957
It takes in a C of type card. 
So notice, I can use that type name that 

39
00:02:34.957 --> 00:02:39.272
I introduced up here. 
And it does the appropriate computation 

40
00:02:39.272 --> 00:02:43.800
of seeing if indeed, the suit is spades 
and the rank is queen, 

41
00:02:43.800 --> 00:02:47.102
okay? 
So now, here are three variable bindings, 

42
00:02:47.102 --> 00:02:51.065
c1, c2, and c3. 
c3 is how we've been writing most of our 

43
00:02:51.065 --> 00:02:55.982
variable bindings where I just create a 
pair of a Spade and an Ace. 

44
00:02:55.982 --> 00:03:01.193
And when you see that you might be asking 
well what's the type of that? 

45
00:03:01.193 --> 00:03:06.844
Is it suit star rank or is it card? 
And the answer is it's both because those 

46
00:03:06.844 --> 00:03:10.000
types are the same. 
So, in fact c1 and c2 

47
00:03:10.000 --> 00:03:12.823
are both perfectly reasonable variable 
declarations, 

48
00:03:12.823 --> 00:03:16.222
variable bindings. 
It turns out you can write the type of a 

49
00:03:16.222 --> 00:03:19.507
variable if you want with a colon and 
then, then, the type. 

50
00:03:19.507 --> 00:03:22.445
And the type checker will make sure 
that's correct, 

51
00:03:22.445 --> 00:03:25.730
that the expression over here really does 
have that type. 

52
00:03:25.730 --> 00:03:30.800
And what we'll see here when we go over 
the REPL is all three of these, 

53
00:03:30.800 --> 00:03:33.048
c1, c2, and c3, 
will type check just fine. 

54
00:03:33.048 --> 00:03:36.000
So,. 
let's just, make sure that's right. 

55
00:03:36.000 --> 00:03:38.736
And they are. 
We see all the bindings here. 

56
00:03:38.736 --> 00:03:42.514
You'll see the REPL printed our datatype 
bindings, 

57
00:03:42.514 --> 00:03:46.357
our type synonyms. 
Then this function is_Queen_of_Spades of 

58
00:03:46.357 --> 00:03:51.373
type card arrow bool and then it happened 
to say that c1 is type card, 

59
00:03:51.373 --> 00:03:55.021
c2 is type suit star rank and c3 is type 
suit star rank. 

60
00:03:55.021 --> 00:04:00.335
But I promise you that this works fine, 
that type checks and runs, this type 

61
00:04:00.335 --> 00:04:03.020
checks and runs, and this type checks and 
runs. 

62
00:04:03.020 --> 00:04:06.931
because anywhere you have card, it is the 
same thing, it suits star rank. 

63
00:04:06.931 --> 00:04:11.250
So, I emphasize this because on your next 
homework, we'll tell you to write 

64
00:04:11.250 --> 00:04:14.694
functions of certain types, like for 
example card arrow bool. 

65
00:04:14.694 --> 00:04:19.306
And if you write a function and it seems 
to work correctly but it prints out a 

66
00:04:19.306 --> 00:04:23.976
different type, like maybe suit star rank 
arrow bool, I want you to recognize that 

67
00:04:23.976 --> 00:04:28.353
that's the same type and it's okay. 
And the reason why that's going to come 

68
00:04:28.353 --> 00:04:33.660
up if I switch back to the code file here 
is a little thing I haven't shown you 

69
00:04:33.660 --> 00:04:37.604
yet, which is soon we're going to write 
functions like is_Queen_of_Spades 

70
00:04:37.604 --> 00:04:40.809
differently. 
We're going to use case expressions for 

71
00:04:40.809 --> 00:04:44.786
that sort of code, too. 
Even though suit star rank is actually a 

72
00:04:44.786 --> 00:04:47.814
pair, and not a datatype, it contains 
datatypes. 

73
00:04:47.814 --> 00:04:52.700
And once we write is_Queen_of_Spades with 
case expressions rather than in hash one 

74
00:04:52.700 --> 00:04:55.723
and hash two, 
then we won't have to write types on our 

75
00:04:55.723 --> 00:04:58.745
arguments anymore. 
We won't have to write c card. 

76
00:04:58.745 --> 00:05:02.775
We'll be able to just write c. 
The only disadvantage of that is then the 

77
00:05:02.775 --> 00:05:06.582
REPL won't know whether we want to see 
cards or suits star rank. 

78
00:05:06.582 --> 00:05:10.892
So, we'll just take whichever one it 
happens to based on its own internal 

79
00:05:10.892 --> 00:05:14.922
procedures and internal algorithms. 
But nonetheless, I find this style of 

80
00:05:14.922 --> 00:05:18.393
coding much more pleasant. 
Just not writing down the types and 

81
00:05:18.393 --> 00:05:22.879
letting the type checker figure them out 
for me for function parameters, the same 

82
00:05:22.879 --> 00:05:25.388
way we've been doing it for variable 
bindings. 

83
00:05:25.388 --> 00:05:29.697
So, that's why this notion of type 
synonyms and this interchangeability will 

84
00:05:29.697 --> 00:05:32.862
be so important. 
it does raise an interesting question 

85
00:05:32.862 --> 00:05:35.490
though which is, why have this is your 
language? 

86
00:05:35.490 --> 00:05:37.973
I mean, if it's really just a 
convenience. 

87
00:05:37.973 --> 00:05:42.152
well, let's be honest, sometimes 
convenient things for programmers are 

88
00:05:42.152 --> 00:05:46.270
worth putting in the language. 
If you want to write CARD rather than 

89
00:05:46.270 --> 00:05:49.904
suit star rank, it's nice to have a 
facility for doing that. 

90
00:05:49.904 --> 00:05:54.568
And the only confusion is that if you 
wanted a function of type card arrow bool 

91
00:05:54.568 --> 00:05:59.292
and the REPL says, suit star rank arrow 
bool, you have to realize that that's an 

92
00:05:59.292 --> 00:06:02.562
equivalent type and it's okay and it's 
the same thing. 

93
00:06:02.562 --> 00:06:05.470
So, it doesn't really let us do anything 
new, yet. 

94
00:06:05.470 --> 00:06:09.456
But in a couple weeks, later in the 
course, we will build on top of these 

95
00:06:09.456 --> 00:06:12.059
type synonyms when we study ml's module 
system. 

96
00:06:12.059 --> 00:06:16.544
And there we'll be able to do something 
pretty special and we'll need these type 

97
00:06:16.544 --> 00:06:18.040
synonyms in order to do it. 