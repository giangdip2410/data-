WEBVTT

1
00:00:04.940 --> 00:00:09.159
Alright, in this section I just want to 
show some more examples of data type 

2
00:00:09.159 --> 00:00:13.600
bindings in particular, because the only 
example I've show you so far was just a 

3
00:00:13.600 --> 00:00:16.598
silly example that didn't actually do 
anything useful. 

4
00:00:16.598 --> 00:00:20.984
So I want to explore the idea of one of 
types and some of the common idioms that 

5
00:00:20.984 --> 00:00:22.627
we see them used for. 
Alright. 

6
00:00:22.627 --> 00:00:26.924
So these example will be small. 
But they'll nonetheless be indicative of 

7
00:00:26.924 --> 00:00:31.818
the sort of things to use data types for. 
So the simplest example is probably just 

8
00:00:31.818 --> 00:00:35.757
for what's e-nums or enumerations are 
used for in other languages. 

9
00:00:35.757 --> 00:00:37.965
If you haven't heard of those, no 
problem. 

10
00:00:37.965 --> 00:00:41.845
So supposed I just want to represent what 
suit a playing card is. 

11
00:00:41.845 --> 00:00:46.201
So in English, every playing card is 
either a club, a diamond, a heart, or a 

12
00:00:46.201 --> 00:00:48.696
spade. 
So it would be a great example to just 

13
00:00:48.696 --> 00:00:52.093
have a datatype binding. 
I have a new type suite, and then if I 

14
00:00:52.093 --> 00:00:56.420
want to do something for each possible 
suite I can just have a case expression 

15
00:00:56.420 --> 00:01:00.693
that has one branch for each pattern. 
If you don't do this with an enumeration 

16
00:01:00.693 --> 00:01:04.966
you end up just encoding something like 
oh, one is for club, two is for diamond, 

17
00:01:04.966 --> 00:01:08.144
three is for heart. 
And that sort of thing is hard to keep 

18
00:01:08.144 --> 00:01:10.664
track of, 
you don't get as much error checking, 

19
00:01:10.664 --> 00:01:14.000
it's harder to read. 
Data types are perfect for this. 

20
00:01:14.000 --> 00:01:18.638
Now what's interesting is this is a very 
simple use of data types because none of 

21
00:01:18.638 --> 00:01:22.937
the constructors, club, diamond, heart, 
spade, carried any data, there were no 

22
00:01:22.937 --> 00:01:27.010
underlying values, and that's fine data 
types just can do more than that. 

23
00:01:27.010 --> 00:01:31.033
So another example is if I wanted the 
rank of a playing card. 

24
00:01:31.033 --> 00:01:36.244
So this is the thing that in America is 
called a Jack, a Queen, a King or an Ace 

25
00:01:36.244 --> 00:01:41.192
or is a number between two and ten. 
So the second data type I have here can 

26
00:01:41.192 --> 00:01:46.205
represent that fairly well, you could 
argue that by doing num of int I'm not 

27
00:01:46.205 --> 00:01:51.284
restricting that int to be between two 
and ten, it could be negative seven, it 

28
00:01:51.284 --> 00:01:54.912
could be a 142. 
But this is still a pretty good concise 

29
00:01:54.912 --> 00:01:59.530
way, a very readable way to read the rank 
part of a playing card. 

30
00:01:59.530 --> 00:02:04.194
You would then, and we'll see how to do 
this in a future segment, create an each 

31
00:02:04.194 --> 00:02:08.150
of type that had a suit and a rank. 
And that would represent a card. 

32
00:02:08.150 --> 00:02:12.474
Alright, so another common pattern, 
another common idiom that we use data 

33
00:02:12.474 --> 00:02:17.159
types for is when we just have alternate 
ways of identifying some object, some 

34
00:02:17.159 --> 00:02:19.862
thing that we're representing in our 
program. 

35
00:02:19.862 --> 00:02:22.805
So suppose I had a bunch of students in 
my class. 

36
00:02:22.805 --> 00:02:26.950
And mostly I wanted to represent them by 
some sort of student number. 

37
00:02:26.950 --> 00:02:31.575
But some of the students were say, just 
taking a pass/fail or just sitting in, 

38
00:02:31.575 --> 00:02:35.900
they were turning in the homework but 
they didn't have a student number. 

39
00:02:35.900 --> 00:02:40.406
So then what I might want, is some type, 
like called ID, for student ID, that was 

40
00:02:40.406 --> 00:02:43.931
either an int, which I'll mark with a 
constructor student num. 

41
00:02:43.931 --> 00:02:48.611
Or a name, which could have a first name, 
a last name, and maybe an optional middle 

42
00:02:48.611 --> 00:02:51.153
name. 
And since for each student I only want 

43
00:02:51.153 --> 00:02:55.024
one of these possibilities. 
I don't want any confusion, I don't want 

44
00:02:55.024 --> 00:02:58.433
all of this stuff. 
this is a perfectly reasonable way to 

45
00:02:58.433 --> 00:03:02.258
represent them. 
So compare it if you will to trying to do 

46
00:03:02.258 --> 00:03:08.035
that same idea with each of types and 
unfortunately students often do this and 

47
00:03:08.035 --> 00:03:13.530
we often even see code and programming 
languages that encourage using each of 

48
00:03:13.530 --> 00:03:16.700
types when you have conceptually one of 
type. 

49
00:03:16.700 --> 00:03:21.758
So here's something that's really bad 
style Let's do the same idea where we 

50
00:03:21.758 --> 00:03:26.531
have a record, with a STUDENTNUM field, a 
FIRST field, a MIDDLE field, and a LAST 

51
00:03:26.531 --> 00:03:30.937
field, but we'll say, even though 
students' IDs have all these, you should 

52
00:03:30.937 --> 00:03:34.241
never use them all. 
And what we'll do is we'll say the 

53
00:03:34.241 --> 00:03:39.014
STUDENTNUM is what you should use, but if 
it's minus one, or some other special 

54
00:03:39.014 --> 00:03:42.660
value, then ignore it and use the first 
middle and last field. 

55
00:03:42.660 --> 00:03:45.410
Alright? 
So what don't I like about this approach? 

56
00:03:45.410 --> 00:03:49.733
You're basically giving up all the 
benefits of using a language concert that 

57
00:03:49.733 --> 00:03:54.000
enforces that you have a 1-0 type. 
You're getting no help that people should 

58
00:03:54.000 --> 00:03:58.491
only use a number or a name, not both. 
You have to read this comment to 

59
00:03:58.491 --> 00:04:02.701
understand that you have to expect a 
minus one value and react accordingly. 

60
00:04:02.701 --> 00:04:06.743
It just makes it a lot less clear, what 
it is that you're actually doing. 

61
00:04:06.743 --> 00:04:10.729
And that's why in any programming 
language, it's worth learning how 1-0 

62
00:04:10.729 --> 00:04:14.996
types should be represented, and then 
using that pattern when it's the right 

63
00:04:14.996 --> 00:04:17.973
thing to do. 
Alright, now that said, this is a bit of 

64
00:04:17.973 --> 00:04:22.580
a strange example because there are 
situations where it makes sense to use an 

65
00:04:22.580 --> 00:04:27.069
each of type to represent students. 
Suppose we just had a slightly different 

66
00:04:27.069 --> 00:04:31.542
thing we were modeling, where every 
person does have a name and optionally 

67
00:04:31.542 --> 00:04:34.904
has a student number. 
And I want to have both of those. 

68
00:04:34.904 --> 00:04:39.698
Well if you want both things then each of 
is exactly the right thing, and you 

69
00:04:39.698 --> 00:04:42.375
should use a record time like you see 
here. 

70
00:04:42.375 --> 00:04:45.239
This student num should just be an int 
option. 

71
00:04:45.239 --> 00:04:49.099
Don't use minus one, it's too hard to 
remember to check for it. 

72
00:04:49.099 --> 00:04:52.399
Use and options, which is the sum of a 
number, or none. 

73
00:04:52.399 --> 00:04:55.392
That's the one of. 
And then the first, middle and last names 

74
00:04:55.392 --> 00:04:58.361
should always be present. 
Since the middle name may not always be 

75
00:04:58.361 --> 00:05:00.280
present, we'll make that an option as 
well. 

76
00:05:00.280 --> 00:05:04.245
So this is a big thing you have to do 
when you're designing your software, is 

77
00:05:04.245 --> 00:05:08.366
understand what kind of data you want, 
how you're going to model those things in 

78
00:05:08.366 --> 00:05:12.434
your program, and then use the right kind 
of compound types, to directly capture 

79
00:05:12.434 --> 00:05:14.470
the idea of what you're doing. 
Alright. 

80
00:05:14.470 --> 00:05:17.965
So that's all good. 
Now, in the rest of the segment, let me 

81
00:05:17.965 --> 00:05:22.625
focus on an example of another kind of 
data type binding that's going to be 

82
00:05:22.625 --> 00:05:26.120
recursive, and is going to be near and 
dear to our hearts. 

83
00:05:26.120 --> 00:05:30.780
Because it's how you represent things 
like programming languages themselves. 

84
00:05:30.780 --> 00:05:35.379
So here's the last data type binding I'm 
going to show you in this segment. 

85
00:05:35.379 --> 00:05:39.610
It's called X for expression. 
And it defines a little language if you 

86
00:05:39.610 --> 00:05:43.902
will of arithmetic expressions. 
So it says, an expression is one of the 

87
00:05:43.902 --> 00:05:47.274
following things. 
It's either a constant, which holds an 

88
00:05:47.274 --> 00:05:50.257
ent. 
Or a negation of a smaller expression; 

89
00:05:50.257 --> 00:05:53.355
not just an INT, but any smaller 
expression. 

90
00:05:53.355 --> 00:05:58.758
An add, an addition of two smaller 
expressions, or a multiply of two smaller 

91
00:05:58.758 --> 00:06:02.576
expressions. 
So notice how we're using self-reference 

92
00:06:02.576 --> 00:06:05.890
here. 
Many of the constructors themselves hold 

93
00:06:05.890 --> 00:06:10.213
other Xs the same way a list in its tail 
holds another list. 

94
00:06:10.213 --> 00:06:14.320
And what we're actually doing is defining 
a set of trees. 

95
00:06:14.320 --> 00:06:19.640
The set of trees that this data type 
binding represents are trees where at the 

96
00:06:19.640 --> 00:06:22.603
leaves are constants, with a number 
attached. 

97
00:06:22.603 --> 00:06:27.722
And at the internal nodes, are either 
negate, which has one child, one smaller 

98
00:06:27.722 --> 00:06:30.753
expression. 
Or, add and multiply, that have two 

99
00:06:30.753 --> 00:06:34.185
smaller expressions. 
So NML, once we have this data type 

100
00:06:34.185 --> 00:06:38.297
binding, we could write an expression 
like you see here in the middle. 

101
00:06:38.297 --> 00:06:43.004
We could just call the add constructor 
with two arguments that each themselves 

102
00:06:43.004 --> 00:06:46.163
have type X. 
The first one could be constant, which we 

103
00:06:46.163 --> 00:06:48.844
just need to call with any thing of type 
int. 

104
00:06:48.844 --> 00:06:51.704
Like the result of the expression ten 
plus nine. 

105
00:06:51.704 --> 00:06:55.220
And then negate, which has to be called 
with one expression. 

106
00:06:55.220 --> 00:06:58.200
And another expression could be the 
constant four. 

107
00:06:58.200 --> 00:07:03.976
So that's how we would write these MML. 
But what I want you to have in your head 

108
00:07:03.976 --> 00:07:09.174
is this tree version of it. 
To think of this expression as evaluating 

109
00:07:09.174 --> 00:07:12.857
to this value. 
It's a tree that has add here at the 

110
00:07:12.857 --> 00:07:18.489
root, two children constant, which holds 
a nineteen, and negate, which itself has 

111
00:07:18.489 --> 00:07:21.666
a child which is a constant that holds 
four. 

112
00:07:21.666 --> 00:07:27.659
And so every value of type X is going to 
look like some sort of tree that has this 

113
00:07:27.659 --> 00:07:31.185
kind of shape. 
So now we very concisely, in just a 

114
00:07:31.185 --> 00:07:36.575
4-line data binding, described a set of 
trees that represent an interesting 

115
00:07:36.575 --> 00:07:41.894
collection of arithmetic expressions. 
And now what we could do is we could 

116
00:07:41.894 --> 00:07:45.560
write functions that operate over things 
of type x. 

117
00:07:45.560 --> 00:07:50.062
And probably the most obvious type of 
functions, to write is something that 

118
00:07:50.062 --> 00:07:53.938
takes an X and returns the integer you 
get if you evaluate it. 

119
00:07:53.938 --> 00:07:56.439
Right. 
So we have a little language here. 

120
00:07:56.439 --> 00:07:59.503
Let's write a function, e-val of type X 
arrow int. 

121
00:07:59.503 --> 00:08:04.756
So we're going to take any X and we're 
going to return the int that arithmetic 

122
00:08:04.756 --> 00:08:08.070
expression should evaluate to if you 
actually ran it. 

123
00:08:08.070 --> 00:08:10.880
So here's what we would do, we would have 
a case expression. 

124
00:08:10.880 --> 00:08:15.071
We would say, well, any X is built with 
constant, negate or multiply. 

125
00:08:15.071 --> 00:08:19.664
What should we do in each case? 
Well, if it's built with constant. 

126
00:08:19.664 --> 00:08:24.278
Let's get the underlying int out. 
That's the result. 

127
00:08:24.278 --> 00:08:27.752
That's the number. 
But what if we have a negate. 

128
00:08:27.752 --> 00:08:31.062
Well then we have some smaller expression 
here. 

129
00:08:31.062 --> 00:08:35.358
We'll bind it to E2. 
So now over here in this right branch, we 

130
00:08:35.358 --> 00:08:38.597
have an expression that is in the 
variable E2. 

131
00:08:38.597 --> 00:08:42.330
And what we could do is recursively call 
e-val on it. 

132
00:08:42.330 --> 00:08:47.541
And that will tell us the result of 
evaluating E2 in this little language. 

133
00:08:47.541 --> 00:08:52.190
And then we could use ML's negation 
operator to negate the result. 

134
00:08:52.190 --> 00:08:57.525
For add, lets bind a two local variables. 
The two sub trees, E1 and E2 recursively 

135
00:08:57.525 --> 00:09:01.860
call eval on both of them. 
Take those two numbers we get back and 

136
00:09:01.860 --> 00:09:05.528
use ML's plus, ML's addition to come up 
with the result. 

137
00:09:05.528 --> 00:09:08.596
And if you like that, multiply is very 
similar. 

138
00:09:08.596 --> 00:09:12.065
Create two variables. 
E1 and E2 for the two parts, 

139
00:09:12.065 --> 00:09:15.800
recursively called Eval, 
and then multiply them together. 

140
00:09:15.800 --> 00:09:21.189
So, it's perhaps not very surprising that 
functions over recursive data types, data 

141
00:09:21.189 --> 00:09:25.921
type bindings that have self reference 
like this, end up being recursive. 

142
00:09:25.921 --> 00:09:29.471
You want to do something useful within 
the X you have. 

143
00:09:29.471 --> 00:09:34.795
Usually you need to consider the smaller 
expressions that are in the subtrees of 

144
00:09:34.795 --> 00:09:37.416
that tree. 
And they way that your going to 

145
00:09:37.416 --> 00:09:41.696
recursively· find those and figure out 
how they're made is with a recursive 

146
00:09:41.696 --> 00:09:45.180
function call that then has it's own case 
expression. 

147
00:09:45.180 --> 00:09:48.392
All right. 
So that's most of the code I wanted to 

148
00:09:48.392 --> 00:09:51.605
show you. 
Everything I've shown you on the slides 

149
00:09:51.605 --> 00:09:55.998
is over here in the file. 
You'll also notice a second function 

150
00:09:55.998 --> 00:09:59.670
here, number of ads, and then I have some 
example codes. 

151
00:09:59.670 --> 00:10:02.883
So for example here's what I had on the 
slide. 

152
00:10:02.883 --> 00:10:06.555
So example X is just a little variable, 
mining of type X. 

153
00:10:06.555 --> 00:10:11.997
And then example ints what I call eval on 
example E, will just be something of type 

154
00:10:11.997 --> 00:10:14.662
int. 
I have one other, this function number of 

155
00:10:14.662 --> 00:10:18.528
ads, also, happens to have the same type 
as eval, X arrow int. 

156
00:10:18.528 --> 00:10:23.098
But what it does, is it doesn't run the 
expression doesn't, compute it's answer. 

157
00:10:23.098 --> 00:10:27.375
Instead, it just counts how many 
additions are anywhere in the expression. 

158
00:10:27.375 --> 00:10:30.129
And it's the same kind of recursive 
processing. 

159
00:10:30.129 --> 00:10:33.879
I'll just do a case on E. 
If it's a constant, there are no ads in 

160
00:10:33.879 --> 00:10:36.456
it. 
If it's in a gate, it has the same number 

161
00:10:36.456 --> 00:10:40.206
of ads that are in E two. 
So just recursively call number of ads 

162
00:10:40.206 --> 00:10:43.073
with E two, and that's our answer. 
If it is an ad, 

163
00:10:43.073 --> 00:10:47.180
well then, there's one ad. 
But we need to also include any ads that 

164
00:10:47.180 --> 00:10:51.350
are in the sub expressions. 
So let's recursively call number of ads, 

165
00:10:51.350 --> 00:10:55.084
E1, number of ads, E2, 
add those together, add one to that, that 

166
00:10:55.084 --> 00:10:58.755
will be our answer. 
And multiply is similar, except we don't 

167
00:10:58.755 --> 00:11:02.427
have the one plus. 
Because the multiply itself is not an ad. 

168
00:11:02.427 --> 00:11:05.850
And there's an example here of trying 
that out as well. 

169
00:11:05.850 --> 00:11:10.550
And so what I want to leave you with, is 
data types are useful for representing 

170
00:11:10.550 --> 00:11:14.894
lots of different kinds of data. 
Particularly, these interesting tree like 

171
00:11:14.894 --> 00:11:19.237
structures, that we can then write 
recursive functions over, to produce 

172
00:11:19.237 --> 00:11:22.213
answers, in terms of the answers for the 
sub trees. 