WEBVTT

1
00:00:00.000 --> 00:00:04.940

2
00:00:04.940 --> 00:00:08.033
Okay. 
In this section, I want to talk about how 

3
00:00:08.033 --> 00:00:11.970
you can define your own data types that 
are polymorphic. 

4
00:00:11.970 --> 00:00:16.785
So the reason why I'm doing this is I've 
previously claimed that the options and 

5
00:00:16.785 --> 00:00:21.540
lists in ML aren't particularly special. 
That they are themselves just data type 

6
00:00:21.540 --> 00:00:24.513
bindings. 
And the only thing that's different that, 

7
00:00:24.513 --> 00:00:29.031
is that lists have slightly special 
syntax where we have the colon, colon as 

8
00:00:29.031 --> 00:00:33.014
s constructor in the middle, and bracket, 
bracket for the empty list. 

9
00:00:33.014 --> 00:00:37.829
But that's not exactly true, compared to 
the data type bindings I've shown you so 

10
00:00:37.829 --> 00:00:40.563
far. 
Because lists and options are things that 

11
00:00:40.563 --> 00:00:43.120
take type parameters. 
So, list is not a type. 

12
00:00:43.120 --> 00:00:48.976
It's int list that is a type or string 
list, or even int list, list which is 

13
00:00:48.976 --> 00:00:53.350
list's who's elements are lists who's 
elements are ints. 

14
00:00:53.350 --> 00:00:57.855
So, list and option are not types, 
they're type constructors, they're 

15
00:00:57.855 --> 00:01:01.420
something that take type parameters to 
produce types. 

16
00:01:01.420 --> 00:01:05.813
And we've also seen functions that may or 
may not be polymorphic. 

17
00:01:05.813 --> 00:01:11.355
So, a function like sum list has to take 
a list of integers and add them all up to 

18
00:01:11.355 --> 00:01:13.653
produce an int. 
But a function, like my favorite, append 

19
00:01:13.653 --> 00:01:18.654
is something that works for any type 
alpha, and it takes a type alpha list, 

20
00:01:18.654 --> 00:01:22.304
and another type alpha list, and returns 
an alpha list. 

21
00:01:22.304 --> 00:01:27.576
And I just say alpha instead of quote A 
because that's the traditional way to 

22
00:01:27.576 --> 00:01:30.937
pronounce that. 
So, it would be good language to design 

23
00:01:30.937 --> 00:01:35.631
to not have built-in things like lists 
and options that can be polymorphic in 

24
00:01:35.631 --> 00:01:40.024
this way, and then have data-type 
bindings that you can define that don't 

25
00:01:40.024 --> 00:01:43.454
have this facility. 
So, it turns out that ML did the right 

26
00:01:43.454 --> 00:01:48.208
thing, it lets you define your own. And 
this segment is going to show you how to 

27
00:01:48.208 --> 00:01:51.000
do that. 
Now, this is optional in the sense of I 

28
00:01:51.000 --> 00:01:55.028
wanted to show this to you for 
completeness, but the homework is not 

29
00:01:55.028 --> 00:01:59.708
going to require you to do this, and I'm 
just doing this to finish the story of 

30
00:01:59.708 --> 00:02:02.730
how lists and options are not 
particularly special. 

31
00:02:02.730 --> 00:02:05.737
Okay. 
So, here's the syntax I haven't shown you 

32
00:02:05.737 --> 00:02:08.744
yet. 
And that is that you can have one or more 

33
00:02:08.744 --> 00:02:14.067
type parameters between the word datatype 
and the new type level binding your 

34
00:02:14.067 --> 00:02:17.790
introducing. 
So this first line here on the slide is 

35
00:02:17.790 --> 00:02:23.231
exactly how options are defined in ML 
before your program starts running. 

36
00:02:23.231 --> 00:02:28.815
And it just says that option is not a 
type, it's something that given one type, 

37
00:02:28.815 --> 00:02:34.112
alpha or quote A, produces a type. 
So int option is a type, string option is 

38
00:02:34.112 --> 00:02:38.256
a type, and so on. 
And then, once we have that quote A, then 

39
00:02:38.256 --> 00:02:43.305
we can use it in the types of data that 
our constructors carry. So, in 

40
00:02:43.305 --> 00:02:48.428
particular, we can have some of alpha, 
some carries what ever type this 

41
00:02:48.428 --> 00:02:52.160
particular kind of option carries as its 
parameter. 

42
00:02:52.160 --> 00:02:57.731
Similarly, larly, if we wanted to define 
our own linked list, ignoring the special 

43
00:02:57.731 --> 00:03:03.025
syntax in ML, we have one type parameter, 
alpha, and the cons case carries two 

44
00:03:03.025 --> 00:03:06.229
pieces of data, an alpha and then another 
list. 

45
00:03:06.229 --> 00:03:10.268
But you can't just write My List here, 
that's never a type. 

46
00:03:10.268 --> 00:03:13.960
We say that the rest has to be another 
alpha My List, 

47
00:03:13.960 --> 00:03:17.016
alright? 
So, you can even do things with multiple 

48
00:03:17.016 --> 00:03:20.391
type parameters, so this last example 
here shows that. 

49
00:03:20.391 --> 00:03:25.231
It defines a particular kind of tree 
where I have two constructors, internal 

50
00:03:25.231 --> 00:03:28.924
nodes and leaves. 
And the leaves always carry something of 

51
00:03:28.924 --> 00:03:31.790
type quote B or beta, the second Greek 
letter. 

52
00:03:31.790 --> 00:03:36.803
And the internal nodes always carry 
something of type alpha and then two 

53
00:03:36.803 --> 00:03:42.091
other alpha beta trees. So, this is going 
to be a binary tree where all of the 

54
00:03:42.091 --> 00:03:47.241
internal nodes can carry data of one type 
and all the leaves can carry data of a 

55
00:03:47.241 --> 00:03:51.502
possibly different type. 
Those two type parameters, alpha and 

56
00:03:51.502 --> 00:03:54.840
beta, can be the same or they can be 
different. 

57
00:03:54.840 --> 00:03:58.672
Alright, so that's how you do it. 
I have a bunch of code associated here 

58
00:03:58.672 --> 00:04:03.044
that you can mostly look at on your own. 
So, I started by showing you some list in 

59
00:04:03.044 --> 00:04:06.931
append over ML's built in lists. 
So some list here is going to have type 

60
00:04:06.931 --> 00:04:09.954
int list arrow int. 
And the type checker will be able to 

61
00:04:09.954 --> 00:04:14.056
figure that out because it sees that 
right here, you're taking an element of 

62
00:04:14.056 --> 00:04:16.755
the list x, and you're adding it to 
something else. 

63
00:04:16.755 --> 00:04:21.020
And so the elements must have type int. 
The result type must have type int both 

64
00:04:21.020 --> 00:04:25.284
because we have an addition here and 
because we have a zero here in this other 

65
00:04:25.284 --> 00:04:28.900
branch, and zero has type int. 
Append, on the other hand, 

66
00:04:28.900 --> 00:04:33.795
the type checker can see that we don't 
need are list arguments, x's and y's, to 

67
00:04:33.795 --> 00:04:37.928
have any particular type. 
They have to have the same type because 

68
00:04:37.928 --> 00:04:43.269
if you take an element of one and cons it 
on to something that has to have the same 

69
00:04:43.269 --> 00:04:46.194
type, because we return something that is 
wise, 

70
00:04:46.194 --> 00:04:51.471
these two lists better have the same type 
because you can't mix and match elements 

71
00:04:51.471 --> 00:04:54.968
of different types. 
And so, the type ends up being alpha 

72
00:04:54.968 --> 00:04:59.927
list, arrow alpha list, arrow alpha list, 
which says that callers can use append 

73
00:04:59.927 --> 00:05:03.946
with lists of any type. 
But the two types, the two arguments, x's 

74
00:05:03.946 --> 00:05:07.290
and y's, have to be lists with the same 
element type. 

75
00:05:07.290 --> 00:05:09.919
Alright. 
Then, I have the data type bindings I 

76
00:05:09.919 --> 00:05:13.892
just showed you here on this slide. 
And then, down here using our own 

77
00:05:13.892 --> 00:05:18.450
polymorphic data type, this alpha beta 
tree I showed you where the leaves have 

78
00:05:18.450 --> 00:05:23.066
one type and the internal nodes have data 
of possibly a different type, I wrote 

79
00:05:23.066 --> 00:05:26.805
three different functions. 
This first one, sum tree runs over the 

80
00:05:26.805 --> 00:05:29.785
entire tree adding up everything at every 
position. 

81
00:05:29.785 --> 00:05:34.460
So, if you have a leaf, we pattern match 
on that here and we just return the data 

82
00:05:34.460 --> 00:05:37.718
there, this i. 
If we have an internal node we add i to 

83
00:05:37.718 --> 00:05:42.528
the result of recursively summing the 
left child and recursively summing the 

84
00:05:42.528 --> 00:05:45.776
right child, these left and right fields 
of the data. 

85
00:05:45.776 --> 00:05:50.460
And so, everything has to have type int. 
And so, the type checker will indeed 

86
00:05:50.460 --> 00:05:55.270
figure out, if you run this code, that 
the argument has to be an int comma int 

87
00:05:55.270 --> 00:05:58.205
tree. 
That only trees where both alpha and beta 

88
00:05:58.205 --> 00:06:03.202
are int can be legal to pass through the 
sum tree function and get a reasonable 

89
00:06:03.202 --> 00:06:06.407
answer. 
This is a much more interesting function 

90
00:06:06.407 --> 00:06:10.525
from the type perspective, although it's 
probably less useful. 

91
00:06:10.525 --> 00:06:15.925
What it does is it also takes a tree, but 
it only adds up all of the integers at 

92
00:06:15.925 --> 00:06:19.165
the leaves. 
So, if you look in the node case here, 

93
00:06:19.165 --> 00:06:24.767
what the right hand side does is it just 
calls some leaves on left and some leaves 

94
00:06:24.767 --> 00:06:28.142
of right. 
It doesn't actually use the data at that 

95
00:06:28.142 --> 00:06:31.573
node. 
And so indeed, the type checker will 

96
00:06:31.573 --> 00:06:38.189
notice that the legal types of trees you 
can pass the sum leaves are anything 

97
00:06:38.189 --> 00:06:41.963
where the beta is int and the alpha can 
be anything. 

98
00:06:41.963 --> 00:06:46.673
So, some leaves can be polymorphic. 
It works for any kind of tree where beta 

99
00:06:46.673 --> 00:06:48.807
is int, 
and then it returns an int. 

100
00:06:48.807 --> 00:06:53.768
And finally, if you did it something even 
more general like just count how many 

101
00:06:53.768 --> 00:06:57.033
leaves a tree has. 
So now, we're not using any of the 

102
00:06:57.033 --> 00:07:00.235
internal data. 
We're not using this i I and we're not 

103
00:07:00.235 --> 00:07:03.187
using this i. 
We just count by in the base case 

104
00:07:03.187 --> 00:07:07.951
returning one, and in the internal node 
case summing the number of leaves on the 

105
00:07:07.951 --> 00:07:12.119
left and the number of leaves on the 
right. Now, any kind of tree is a legal 

106
00:07:12.119 --> 00:07:16.400
argument, and indeed the type of num 
leaves will be alpha beta tree arrow int. 

107
00:07:16.400 --> 00:07:18.891
Okay. 
So that's fairly fancy type system. 

108
00:07:18.891 --> 00:07:23.688
As I mentioned, we're not going to get 
into our own polymorphic data types in 

109
00:07:23.688 --> 00:07:28.547
homework two. But, it's interesting to 
notice that the way we used constructors 

110
00:07:28.547 --> 00:07:31.164
and case expressions was exactly as 
usual. 

111
00:07:31.164 --> 00:07:36.085
Nothing about the code we wrote was any 
different, nothing about the evaluation 

112
00:07:36.085 --> 00:07:40.259
rules were any different. 
The only differences in the type checking 

113
00:07:40.259 --> 00:07:45.492
were now the type checker has a much more 
interesting job of making sure that types 

114
00:07:45.492 --> 00:07:50.040
are used consistently. So, even though a 
list or a tree may be polymorphic, 

115
00:07:50.040 --> 00:07:54.728
you still have to, you can't mix element 
types in a particular data structure. 

116
00:07:54.728 --> 00:07:59.295
And then, how polymorphic your functions 
are, how many of those quote A's as and 

117
00:07:59.295 --> 00:08:04.027
quote B's appear in the type depend on 
how the data is used. And that's why we 

118
00:08:04.027 --> 00:08:08.723
see things like summing the elements of a 
list requiring a list of ints, but 

119
00:08:08.723 --> 00:08:11.937
something like append working for lists 
of any type. 