WEBVTT

1
00:00:00.000 --> 00:00:04.940

2
00:00:04.940 --> 00:00:09.266
This is an optional segment, where I'm 
going to show you one more way that you 

3
00:00:09.266 --> 00:00:12.266
can write down patterns, particularly 
with functions. 

4
00:00:12.266 --> 00:00:15.209
This is a style that I've never 
particularly liked. 

5
00:00:15.209 --> 00:00:18.786
But there's nothing wrong with it and 
other people do like it. 

6
00:00:18.786 --> 00:00:22.940
So, if you want to use this, you can. 
And if not, like I said, it's optional. 

7
00:00:22.940 --> 00:00:26.757
So, let me just shoe a couple examples by 
showing you some code. 

8
00:00:26.757 --> 00:00:30.756
Remember this data type binding we had 
for arithmetic expressions. 

9
00:00:30.756 --> 00:00:35.422
So, these are trees where the leaves are 
constants and the internal nodes are 

10
00:00:35.422 --> 00:00:40.208
negations, additions or multiplications. 
And the most natural function you would 

11
00:00:40.208 --> 00:00:44.268
want to write over such a data type is 
something that evaluates it. 

12
00:00:44.268 --> 00:00:48.994
So, something of type x aero int where we 
produce the result of evaluating the 

13
00:00:48.994 --> 00:00:53.418
arithmetic expression and we had this 
great recursive function that uses 

14
00:00:53.418 --> 00:00:56.690
pattern matching with a case expression 
to do that. 

15
00:00:56.690 --> 00:01:01.606
So it turns out there's another way you 
can write functions where the function 

16
00:01:01.606 --> 00:01:06.086
body is just a case expression. 
So if the entire function body is a case 

17
00:01:06.086 --> 00:01:11.127
expression, you can get rid of the case 
expression by moving the patterns up into 

18
00:01:11.127 --> 00:01:14.985
the function binding. 
So we already know that in fact, when you 

19
00:01:14.985 --> 00:01:19.652
write a function named F, you can follow 
that with a P, any pattern you want 

20
00:01:19.652 --> 00:01:22.763
equals E. 
But so far, we've only done that for each 

21
00:01:22.763 --> 00:01:27.804
O patterns, because you want that pattern 
to match any value that might be passed 

22
00:01:27.804 --> 00:01:31.637
to the function. 
But as you can see here with this other 

23
00:01:31.637 --> 00:01:34.900
version of eval you can in fact have 
multiple. 

24
00:01:34.900 --> 00:01:40.480
Fun f p equal e. 
But you don't for the subsequent ones 

25
00:01:40.480 --> 00:01:44.360
repeat the fun keyword instead you re you 
write a pipe. 

26
00:01:44.360 --> 00:01:49.263
And then repeat the function name, 
and then put a second pattern and a 

27
00:01:49.263 --> 00:01:53.045
second body. 
So when you put all that together you end 

28
00:01:53.045 --> 00:01:56.967
up with fun eval first pattern, this. 
Second pattern this. 

29
00:01:56.967 --> 00:01:59.209
Third pattern this. 
It's shorter. 

30
00:01:59.209 --> 00:02:02.991
People also like that it's a little more 
mathematical. 

31
00:02:02.991 --> 00:02:07.054
We're defining the function eval and it 
has several cases. 

32
00:02:07.054 --> 00:02:11.957
Eval applied to a constant is this. 
Eval applied to a negation is that. 

33
00:02:11.957 --> 00:02:15.529
And so on. 
But it's just syntactic sugar for a case 

34
00:02:15.529 --> 00:02:18.829
expression. 
So just to show you one more example, you 

35
00:02:18.829 --> 00:02:21.789
see down here at the bottom my favorite 
example, 

36
00:02:21.789 --> 00:02:24.983
append. 
And append is itself something whose body 

37
00:02:24.983 --> 00:02:30.495
was just a case expression, and now we 
can use nested patterns to be able to do 

38
00:02:30.495 --> 00:02:34.260
this all at once. 
We can say, append, if the two arguments 

39
00:02:34.260 --> 00:02:39.503
match this pattern, so the first list is 
empty and the second list is any list 

40
00:02:39.503 --> 00:02:44.545
because anything matches the variable 
pattern wise, then the result is wise. 

41
00:02:44.545 --> 00:02:49.721
Otherwise, if the two lists match these, 
this pattern, then return X cons on to 

42
00:02:49.721 --> 00:02:53.149
append of X's prime, wise. 
So that's another example. 

43
00:02:53.149 --> 00:02:58.871
This is another way to write append. 
So just to generalize this and show you 

44
00:02:58.871 --> 00:03:05.561
what's going on over here in the slides. 
In general, if you had a function 

45
00:03:05.561 --> 00:03:09.940
binding, where you had fun fx equals case 
x of. 

46
00:03:09.940 --> 00:03:12.894
Patterns. 
You can rewrite that as I've shown you by 

47
00:03:12.894 --> 00:03:17.470
writing multiple patterns repeating the 
function name and putting pipes, so the 

48
00:03:17.470 --> 00:03:20.946
pipe character, between the different 
versions if you prefer. 

49
00:03:20.946 --> 00:03:24.537
one little detail here. 
This is, of course, assuming that you 

50
00:03:24.537 --> 00:03:27.491
don't need that variable X in any of your 
branches. 

51
00:03:27.491 --> 00:03:30.909
You usually don't. 
You usually pattern match it off in your 

52
00:03:30.909 --> 00:03:35.427
case expression and then just use the 
variables that you bind in the variable 

53
00:03:35.427 --> 00:03:39.135
branches, various branches. 
So that's your optional syntax if you 

54
00:03:39.135 --> 00:03:40.120
choose to use it. 