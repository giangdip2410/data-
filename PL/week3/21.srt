WEBVTT

1
00:00:00.000 --> 00:00:04.940

2
00:00:04.940 --> 00:00:10.559
In this segment, I want to continue our 
discussion of tail-recursion and show you 

3
00:00:10.559 --> 00:00:15.693
the common pattern of how we create 
tail-recursive functions and the role 

4
00:00:15.693 --> 00:00:21.174
that accumulators play in that process. 
So, what I'm trying to emphasize is that 

5
00:00:21.174 --> 00:00:26.586
when we have tail recursion, we do have 
significantly more efficient functions. 

6
00:00:26.586 --> 00:00:31.997
So, if it's reasonably eloquent, if it's 
simple, and if performance is important, 

7
00:00:31.997 --> 00:00:36.230
it can be worth rewriting your function 
to be tail-recursive. 

8
00:00:36.230 --> 00:00:41.294
So a tail-recursive function is just one 
where all the recursive calls are 

9
00:00:41.294 --> 00:00:45.480
themselves tail calls. 
So we have this situation where when we 

10
00:00:45.480 --> 00:00:50.882
do the recursion, there is no more work 
for the caller to do after the recursive 

11
00:00:50.882 --> 00:00:54.526
call is done. 
And it turns out there is a methodology 

12
00:00:54.526 --> 00:01:00.196
that can often guide this transformation, 
a way for you to take your code and make 

13
00:01:00.196 --> 00:01:04.207
it tail-recursive. 
And that is to create a helper function 

14
00:01:04.207 --> 00:01:09.877
that takes an accumulator, something that 
combines answers as you go along to hold 

15
00:01:09.877 --> 00:01:13.819
the answers so far. 
And what typically happens, is the old 

16
00:01:13.819 --> 00:01:17.830
base case from your recursion is your 
initial accumulator. 

17
00:01:17.830 --> 00:01:21.379
And, 
in the recursive accumulator style 

18
00:01:21.379 --> 00:01:26.590
function, your final result is just your 
accumulator and it turns out that this 

19
00:01:26.590 --> 00:01:31.604
works anytime that you can combine your 
results in essentially any order, in 

20
00:01:31.604 --> 00:01:36.157
order to get the same result. 
So, in our previous example where we had 

21
00:01:36.157 --> 00:01:40.841
factorial, that's indeed the case. 
It doesn't matter to us what order we 

22
00:01:40.841 --> 00:01:44.799
multiply all these numbers, three times 
two times one or one times two times 

23
00:01:44.799 --> 00:01:47.900
three, 
and therefore, this transformation worked 

24
00:01:47.900 --> 00:01:51.826
just fine. 
So indeed, if you think of factorial in 

25
00:01:51.826 --> 00:01:57.815
your head as multiply n by the recursive 
factorial of n minus one, that's the 

26
00:01:57.815 --> 00:02:02.482
traditional version. 
But the tail-recursive version, which we 

27
00:02:02.482 --> 00:02:04.763
have here, 
uses our methodology. 

28
00:02:04.763 --> 00:02:10.492
We have a local helper function aux that 
takes an extra argument, the accumulator. 

29
00:02:10.492 --> 00:02:16.494
The initial accumulator in this call here 
between the in and the n passes in one 

30
00:02:16.494 --> 00:02:21.719
which used to be our base case. 
And then, in the tail-recursive helper 

31
00:02:21.719 --> 00:02:26.839
function, our base case when n equals 
zero is to just return the accumulator. 

32
00:02:26.839 --> 00:02:32.228
And so, we are still recursively aux ox 
each time with n minus one, but we're 

33
00:02:32.228 --> 00:02:37.280
multiplying numbers as we go so when we 
get to zero, the accumulator is our 

34
00:02:37.280 --> 00:02:41.860
answer and that's why this worked out. 
So let me show you two more examples, 

35
00:02:41.860 --> 00:02:44.536
the second one will actually be more 
interesting. 

36
00:02:44.536 --> 00:02:47.977
The first example is just summing all the 
elements in the list. 

37
00:02:47.977 --> 00:02:52.018
It turns out that at the top, we've 
written functions like this many times, 

38
00:02:52.018 --> 00:02:56.593
this not a tail-recursive function. 
In the recursive call here, where we call 

39
00:02:56.593 --> 00:03:00.296
sum with xs' prime, 
the caller still has work to do after 

40
00:03:00.296 --> 00:03:03.610
this call finishes. 
We need to add x, to that result. 

41
00:03:03.610 --> 00:03:07.953
But our methodology will work here, 
because we don't care what order we sum 

42
00:03:07.953 --> 00:03:11.115
numbers up, 
and so, we can create a helper function 

43
00:03:11.115 --> 00:03:14.418
aux. 
It can take an additional argument and 

44
00:03:14.418 --> 00:03:17.462
accumulator. 
Its base case can just return that 

45
00:03:17.462 --> 00:03:20.765
accumulator. 
When we have our recursive call now, we 

46
00:03:20.765 --> 00:03:25.298
make sure it's tail-recursive. 
There will be no more work to do by the 

47
00:03:25.298 --> 00:03:30.090
caller after we complete this call. 
And we pass in, for our new accumulator, 

48
00:03:30.090 --> 00:03:32.551
xiii, + acc, so that we're adding thing 
as we go. 

49
00:03:32.551 --> 00:03:37.862
And then, our initial accumulator, 0, is 
what our base case was above when we had 

50
00:03:37.862 --> 00:03:42.481
our traditional version of sum. 
So that was also a fairly easy example, 

51
00:03:42.481 --> 00:03:47.369
factorial and sum are fairly similar. 
let's do a more interesting example. 

52
00:03:47.369 --> 00:03:50.450
This is something I haven't shown you 
before. 

53
00:03:50.450 --> 00:03:54.475
Let's take a list and reverse it. 
Okay? So if we get, had the list one, 

54
00:03:54.475 --> 00:03:58.210
two, three, we want to come up with a 
list three, two, one. And it turns out, 

55
00:03:58.210 --> 00:04:02.412
in this case, the traditional version is 
not very good and we're going to look at 

56
00:04:02.412 --> 00:04:04.160
why. 
So I'd taken a list, xs'. 

57
00:04:04.160 --> 00:04:09.360
The way you reverse the empty list is you 
return the empty list. No problem there. 

58
00:04:09.360 --> 00:04:14.293
Otherwise a-ha, we do want to recursively 
reverse xs' prime. 

59
00:04:14.293 --> 00:04:17.911
Sorry, 
that should be xs' prime right there. 

60
00:04:17.911 --> 00:04:23.420
and that's fine, but then what we need to 
do is put x at the end. 

61
00:04:23.420 --> 00:04:26.257
Alright? 
And it won't work to write cons X because 

62
00:04:26.257 --> 00:04:30.455
cons can't have a list in the first 
position and an element in the second 

63
00:04:30.455 --> 00:04:33.349
position. 
Now what we need to do is we need to make 

64
00:04:33.349 --> 00:04:36.810
a list holding x and then append to those 
two lists together. 

65
00:04:36.810 --> 00:04:41.066
And it turns out that's remarkably 
inefficient as what we'll talk about on 

66
00:04:41.066 --> 00:04:45.378
the next slide, but if we just do our 
tail-recursive version, everything will 

67
00:04:45.378 --> 00:04:48.870
work out normally. 
So here's the tail-recursive version. 

68
00:04:48.870 --> 00:04:52.944
Create a local helper function that takes 
in the accumulator. 

69
00:04:52.944 --> 00:04:58.020
Let's start that accumulator with the 
empty list. Let's pass in xs' for the 

70
00:04:58.020 --> 00:05:02.561
argument. nd here, if xs' is empty, then 
just return the accumulator. 

71
00:05:02.561 --> 00:05:07.502
But now what we should do in the 
recursive case, is yes, pass in xs' prime 

72
00:05:07.502 --> 00:05:12.778
for X is, and then this accumulator which 
is the reversal of the list so far, we 

73
00:05:12.778 --> 00:05:15.785
just want to put x on the front of that. 
Okay? 

74
00:05:15.785 --> 00:05:21.014
So if we were to reverse one, two, three, 
the initial accumulator would be empty, 

75
00:05:21.014 --> 00:05:26.243
then the next accumulator would be one 
cons on empty, then two cons on the one 

76
00:05:26.243 --> 00:05:29.461
on the empty. 
And indeed, our natural accumulator 

77
00:05:29.461 --> 00:05:34.287
pattern is reversing the list quite 
simply with a simple tail recursive 

78
00:05:34.287 --> 00:05:39.449
function and as we, as efficient as a 
loop, it takes a list and produces a new 

79
00:05:39.449 --> 00:05:43.070
list that is the reverse of the list you 
started with. 

80
00:05:43.070 --> 00:05:47.871
Okay. 
So as promised dig a little deeper here 

81
00:05:47.871 --> 00:05:52.052
on what's so bad, so inefficient about 
the traditional version. 

82
00:05:52.052 --> 00:05:55.086
Okay? 
So it turns out that it's not just that 

83
00:05:55.086 --> 00:05:58.458
we're going to build up a call stack 
every time here. 

84
00:05:58.458 --> 00:06:03.111
It's actually that this append operator 
always copies the first list. 

85
00:06:03.111 --> 00:06:08.169
It has to that's how append works. 
The same thing happens in the version of 

86
00:06:08.169 --> 00:06:12.350
append we would write whether append is 
tail recursive or not. 

87
00:06:12.350 --> 00:06:17.642
So it turns out that this code, if you 
were reversing a list of length 

88
00:06:17.642 --> 00:06:20.970
proportional to some number, let's call 
it k. 

89
00:06:20.970 --> 00:06:25.771
The amount of work this is doing is 
proportional to k squared. 

90
00:06:25.771 --> 00:06:30.031
It's growing quadratically with the 
length of the list. 

91
00:06:30.031 --> 00:06:34.291
That was not true for factorial. 
It is not true for sum. 

92
00:06:34.291 --> 00:06:40.022
It's because, when we have these k 
recursive calls, one of them is going to 

93
00:06:40.022 --> 00:06:46.063
copy a list of length one, one a length 
of list two, one a length of list three, 

94
00:06:46.063 --> 00:06:51.330
all the way up to one of list of length k 
minus one, or maybe even k. 

95
00:06:51.330 --> 00:06:56.398
And the sum of the numbers from one to k? 
Is approximately k squared over two. 

96
00:06:56.398 --> 00:06:59.952
It is only about, it is about half as big 
as K squared. 

97
00:06:59.952 --> 00:07:03.968
And that is a lot more work then our 
tail-recursive function. 

98
00:07:03.968 --> 00:07:07.786
Our tail recursive function did not use 
this append, right? 

99
00:07:07.786 --> 00:07:11.406
It only used cons. 
The total amount of work this bottom 

100
00:07:11.406 --> 00:07:15.290
version is doing is proportional to the 
length of the list, 

101
00:07:15.290 --> 00:07:20.753
whereas the top version is doing a total 
amount of work proportional to the length 

102
00:07:20.753 --> 00:07:24.023
of the list squared. 
So this is an interesting point. 

103
00:07:24.023 --> 00:07:28.845
The moral here is don't just obsess about 
whether you're tail-recursive or not. 

104
00:07:28.845 --> 00:07:31.470
You should also beware of appending 
things, 

105
00:07:31.470 --> 00:07:35.743
that if you are recursively appending at 
every step, your algorithm is sometimes 

106
00:07:35.743 --> 00:07:40.016
is significantly less efficient than you 
might expect it to be. 