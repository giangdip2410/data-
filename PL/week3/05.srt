WEBVTT

1
00:00:00.000 --> 00:00:04.940
. 

2
00:00:04.940 --> 00:00:07.632
Alright. 
In this segment, we're going to start 

3
00:00:07.632 --> 00:00:11.521
studying case expressions, 
which is the ML language concept we're 

4
00:00:11.521 --> 00:00:16.307
going to use to access values made up 
from the types we introduced with data 

5
00:00:16.307 --> 00:00:19.598
type bindings. 
So, what we're going to do is we're going 

6
00:00:19.598 --> 00:00:22.889
to take these two ideas we learned in the 
last segment. 

7
00:00:22.889 --> 00:00:27.196
Then we need a way to figure out which 
variant of a one of type we have. 

8
00:00:27.196 --> 00:00:31.826
And we need a way to get the pieces out. 
We're going to see that ML combines these 

9
00:00:31.826 --> 00:00:36.012
into a single language construct. 
In future segments we'll see its actually 

10
00:00:36.012 --> 00:00:38.477
much more powerful than we're showing 
here. 

11
00:00:38.477 --> 00:00:41.746
But we'll introduce the basics to see how 
you can use it. 

12
00:00:41.746 --> 00:00:45.760
So you see the example here on the slide. 
I also have it here in ML. 

13
00:00:45.760 --> 00:00:47.193
So in the, 
in a, file here. 

14
00:00:47.193 --> 00:00:50.347
So you see the same datatype binding we 
studied before. 

15
00:00:50.347 --> 00:00:54.762
So this is a new type, MI type, its built 
from one of these three constructors, 

16
00:00:54.762 --> 00:00:58.990
either two ints, str, or pizza. 
Okay And now what I have is a function 

17
00:00:58.990 --> 00:01:02.696
that's actually going to take in 
something of type MI type. 

18
00:01:02.696 --> 00:01:07.597
We could have written this here, but as 
we'll see this is not op, this is 

19
00:01:07.597 --> 00:01:10.863
optional. 
It's fine, to let ML figure this out for 

20
00:01:10.863 --> 00:01:13.502
us. 
And this is going to take in a MI type, 

21
00:01:13.502 --> 00:01:15.884
and in this case, return an int. 
Alright? 

22
00:01:15.884 --> 00:01:20.067
So the way we're going to do this is 
we're going to have this case expression. 

23
00:01:20.067 --> 00:01:24.305
What we're going to do is between the 
case and the of, which are both keywords, 

24
00:01:24.305 --> 00:01:27.782
we're going to have a value that was 
built out of the data type. 

25
00:01:27.782 --> 00:01:31.856
In this case, MI type, if we had a 
different data type binding with use case 

26
00:01:31.856 --> 00:01:35.224
expressions on that too. 
We use case expressions to access the 

27
00:01:35.224 --> 00:01:38.941
pieces of a data type. 
Then what we have, as indicated by the 

28
00:01:38.941 --> 00:01:43.918
english word case, is several cases. 
And each of these cases is separated by 

29
00:01:43.918 --> 00:01:48.762
this pipe character, and what this 
basically says is if it's a pizza, then 

30
00:01:48.762 --> 00:01:52.810
take this branch, so like an 
if-then-else, it's something with 

31
00:01:52.810 --> 00:01:55.862
branches, and evaluate this thing on the 
right. 

32
00:01:55.862 --> 00:02:00.604
So you'll get three. 
If it's a string, then I take this branch 

33
00:02:00.604 --> 00:02:03.573
and get an eight. 
Well, what is this s for? 

34
00:02:03.573 --> 00:02:08.750
This s is a variable that we will bind to 
the data under the string constructor. 

35
00:02:08.750 --> 00:02:13.799
Now, we're not using that here because we 
didn't want to use the string, but we 

36
00:02:13.799 --> 00:02:16.970
could have. 
And this variable s would be in scope in 

37
00:02:16.970 --> 00:02:20.012
this branch. 
And finally in this last branch, we 

38
00:02:20.012 --> 00:02:24.995
actually are going to use this idea. 
We're going to say, take this branch if x 

39
00:02:24.995 --> 00:02:30.223
was made from the two ints constructor. 
And when evaluating this corresponding 

40
00:02:30.223 --> 00:02:35.700
expression, let i1 be the first int made 
from the two ints and i2 be the second 

41
00:02:35.700 --> 00:02:39.028
int that was provided when we made the 
two ints. 

42
00:02:39.028 --> 00:02:42.910
And so in this case we'll add the two 
branches together. 

43
00:02:42.910 --> 00:02:50.240
Alright? So let's try that out. 
Let's go over and use this file. 

44
00:02:50.240 --> 00:02:56.012
And sure enough f is just a function from 
type MI Type to int and now we can try 

45
00:02:56.012 --> 00:02:58.829
calling f with pizza, 
and we'll get three. 

46
00:02:58.829 --> 00:03:02.471
Or we can call f with str of hi, and 
we'll get eight. 

47
00:03:02.471 --> 00:03:05.701
Notice by the way we can't call f with 
just hi. 

48
00:03:05.701 --> 00:03:08.587
Right. 
Hi is type string, right, not type MI 

49
00:03:08.587 --> 00:03:11.679
Type. 
So if we do this we'll get a type error 

50
00:03:11.679 --> 00:03:15.046
message that this is not the type that f 
expects. 

51
00:03:15.046 --> 00:03:20.131
F's argument x has to be a MI Type and 
you can tell that because of these 

52
00:03:20.131 --> 00:03:23.430
patterns that we use to match against the 
value. 

53
00:03:23.430 --> 00:03:29.235
And now probably the most interesting 
case if we call f with two ints of some 

54
00:03:29.235 --> 00:03:34.450
pair of ints like maybe (7,9), 
we will get sixteen. 

55
00:03:34.450 --> 00:03:36.701
Alright? 
So, that's how you use it. 

56
00:03:36.701 --> 00:03:42.227
Of course, if we had, had some val x that 
equals a str of hi, then we could have 

57
00:03:42.227 --> 00:03:45.570
called f with x and this would all work 
as usual. 

58
00:03:45.570 --> 00:03:50.134
Okay so now let's go back and look at 
that case expression a little more 

59
00:03:50.134 --> 00:03:55.386
carefully, to make sure we understand its 
syntax and evaluation rules and typing 

60
00:03:55.386 --> 00:03:58.200
rules. 
And I think the slides will help us do 

61
00:03:58.200 --> 00:04:00.888
that. 
Okay so here's the same code, so we're 

62
00:04:00.888 --> 00:04:05.015
really focusing in on this case 
expression and in one sense its a 

63
00:04:05.015 --> 00:04:08.954
multi-branch conditional. 
Its like an if-then-else, if-then-else 

64
00:04:08.954 --> 00:04:12.268
that's nested. 
What we do is we evaluate this expression 

65
00:04:12.268 --> 00:04:15.777
between case and of. 
That's going to give us some value And 

66
00:04:15.777 --> 00:04:18.477
then we're going to see which branch 
matches. 

67
00:04:18.477 --> 00:04:23.170
So this is called pattern matching, 
because to the left of this arrow, the 

68
00:04:23.170 --> 00:04:25.934
equal angle bracket, are different 
patterns. 

69
00:04:25.934 --> 00:04:29.277
Alright? And we take the first branch 
that matches. 

70
00:04:29.277 --> 00:04:33.520
And the definition of matching is built 
from the same constructor. 

71
00:04:33.520 --> 00:04:38.520
Alright? Once we build the same, match 
the constructor we then use these 

72
00:04:38.520 --> 00:04:43.238
variables that are part of the pattern to 
introduce local bindings. 

73
00:04:43.238 --> 00:04:46.689
So in this case, its like a little let 
expression. 

74
00:04:46.689 --> 00:04:52.112
Alright? So this is letting i1 being the 
first int and i2 being the second int in 

75
00:04:52.112 --> 00:04:57.957
the pair that was made with the two ints. 
And in this branch we're letting s be the 

76
00:04:57.957 --> 00:05:01.831
underlying string. 
And we can choose whatever variable names 

77
00:05:01.831 --> 00:05:06.550
we want and the scope of the variables is 
just that branch alright. 

78
00:05:06.550 --> 00:05:08.967
Okay. 
So the pattern match [INAUDIBLE], is 

79
00:05:08.967 --> 00:05:13.213
first, find what branch matches and bind 
the variables appropriately, 

80
00:05:13.213 --> 00:05:17.636
then in that extended environment, 
evaluate the expression on the right and 

81
00:05:17.636 --> 00:05:22.118
that's the answer for the whole thing. 
So this example is slightly different 

82
00:05:22.118 --> 00:05:26.599
than what I showed you in the code, but 
in each case, we have some expression 

83
00:05:26.599 --> 00:05:29.607
over here. 
They all have to have the same type, just 

84
00:05:29.607 --> 00:05:34.147
like a then branch, and an else branch 
have to have the same type, because the 

85
00:05:34.147 --> 00:05:38.570
result of the entire case expression is 
going to be the result of whatever 

86
00:05:38.570 --> 00:05:43.803
branch's expression we evaluate. And so 
the type of the entire case expression 

87
00:05:43.803 --> 00:05:47.540
has to be the type of those branches. 
Okay? 

88
00:05:47.540 --> 00:05:52.434
So that is a case expression. 
In general, let's now generalize it past 

89
00:05:52.434 --> 00:05:57.297
our example, we're going to have some 
expression between the case and the of. 

90
00:05:57.297 --> 00:06:00.361
And then we're going to have a bunch of 
branches. 

91
00:06:00.361 --> 00:06:05.357
Each branch is a pattern, which I'm 
writing with p here, and then this equal 

92
00:06:05.357 --> 00:06:10.286
angle bracket and then an expression. 
And we separate them with these pipe 

93
00:06:10.286 --> 00:06:13.417
characters. 
So a pattern is a new kind of thing. 

94
00:06:13.417 --> 00:06:18.613
I know that they look like expressions. 
If I go back here two ints i1 comma i2, 

95
00:06:18.613 --> 00:06:22.410
kind of looks like an expression. 
It is not an expression. 

96
00:06:22.410 --> 00:06:27.803
Okay, it is something we're going to use 
to intro, to do the matching and then to 

97
00:06:27.803 --> 00:06:31.983
introduce variable bindings. 
Okay for the corresponding branch. 

98
00:06:31.983 --> 00:06:35.000
So for today, 
in this segment, each pattern is just a 

99
00:06:35.000 --> 00:06:38.183
constructor name, and then the correct 
number of variables. 

100
00:06:38.183 --> 00:06:40.707
So for pizza, it was just the constructor 
name. 

101
00:06:40.707 --> 00:06:43.670
For str, it was the constructor name and 
one variable. 

102
00:06:43.670 --> 00:06:48.006
For two ints, it was the constructor name 
and then two variables in parenthesis 

103
00:06:48.006 --> 00:06:51.243
separated by commas. 
If you had three arguments, it would be 

104
00:06:51.243 --> 00:06:53.987
similar and so on. 
So syntactically, they look like 

105
00:06:53.987 --> 00:06:57.444
expressions, but we don't evaluate them. 
They're not expressions. 

106
00:06:57.444 --> 00:07:01.231
We use them for pattern matching. 
And then what we do is, we match the 

107
00:07:01.231 --> 00:07:04.140
result of evaluating the zero against 
those patterns, 

108
00:07:04.140 --> 00:07:08.319
get the variables bound to the 
corresponding pieces, and evaluate the 

109
00:07:08.319 --> 00:07:13.203
same branch on the right-hand side. 
So, why is this better than a different 

110
00:07:13.203 --> 00:07:18.534
model where we just provided functions 
like istr and getstr data like I said ML 

111
00:07:18.534 --> 00:07:22.153
could have done? 
Well first of all, if you really wanted 

112
00:07:22.153 --> 00:07:25.180
such functions you could define them 
yourself. 

113
00:07:25.180 --> 00:07:30.708
You could use pattern matching to write a 
function of type MI type arrow bool that 

114
00:07:30.708 --> 00:07:35.840
for str return true and for any two ints 
or pizza would return false. Do not do 

115
00:07:35.840 --> 00:07:37.129
that. 
It's poor style. 

116
00:07:37.129 --> 00:07:40.426
You're giving up most the benefits of 
pattern matching. 

117
00:07:40.426 --> 00:07:45.222
But certainly, case expressions are just 
as powerful as that approach because we 

118
00:07:45.222 --> 00:07:47.920
can use case expressions to do that 
approach. 

119
00:07:47.920 --> 00:07:50.486
Okay. 
But these next two reasons, one and two, 

120
00:07:50.486 --> 00:07:55.211
are probably the most important ones. 
Which is that thanks to writing all your 

121
00:07:55.211 --> 00:07:58.360
different possibilities together in a 
case expression. 

122
00:07:58.360 --> 00:08:02.910
The compiler can check that you don't 
forget any cases and you don't have any 

123
00:08:02.910 --> 00:08:06.002
redundant cases. 
So let me show that by flipping back 

124
00:08:06.002 --> 00:08:08.568
here. 
You might of seen, I had some commented 

125
00:08:08.568 --> 00:08:11.601
out things here. 
Suppose I un-comment this last case. 

126
00:08:11.601 --> 00:08:16.429
So now I have two branches for pizza. 
Alright? Could be an error that you make. 

127
00:08:16.429 --> 00:08:21.701
If you come over here to SML, always 
restart by the way, otherwise you end up 

128
00:08:21.701 --> 00:08:24.838
shadowing the constructors, it's very 
confusing. 

129
00:08:24.838 --> 00:08:28.580
case expressions.SML. 
oh look at that. 

130
00:08:28.580 --> 00:08:32.885
It no longer compiles, and in fact, it 
actually says that we have a redundant 

131
00:08:32.885 --> 00:08:35.377
notch. 
It's a compiled time error because it 

132
00:08:35.377 --> 00:08:38.833
knows that the fourth branch in my code 
could never be taken. 

133
00:08:38.833 --> 00:08:41.155
Oops, that's a different file. 
There we go. 

134
00:08:41.155 --> 00:08:45.744
That this fourth branch could never be 
taken, and so it's a compile time error 

135
00:08:45.744 --> 00:08:48.860
since you know, there'd be no reason to 
write such code. 

136
00:08:48.860 --> 00:08:53.429
And so that's very helpful. 
suppose conversely that we forgot our two 

137
00:08:53.429 --> 00:08:58.380
ints case, or rather than showing you 
that how about I leave that in and I show 

138
00:08:58.380 --> 00:09:01.871
you this other function that forgets a 
couple cases. 

139
00:09:01.871 --> 00:09:05.362
It forgets both the str'd case and the 
two ints case. 

140
00:09:05.362 --> 00:09:10.503
Well in this case I believe we will just 
get a warning if I recall correctly, but 

141
00:09:10.503 --> 00:09:13.360
a warning that we would be very wise to 
heed. 

142
00:09:13.360 --> 00:09:17.279
and it says, warning match non 
exhaustive. 

143
00:09:17.279 --> 00:09:24.260
And indeed, if you take that function G, 
and you call it with a str of hi, 

144
00:09:24.260 --> 00:09:28.809
you now get a run time exception saying, 
I tried to find a matching pattern, and I 

145
00:09:28.809 --> 00:09:31.111
didn't. 
And, if we don't have any of those 

146
00:09:31.111 --> 00:09:34.537
warnings when we compile, then we know 
that will never happen. 

147
00:09:34.537 --> 00:09:38.637
So, this is a nice guarantee we're 
getting, from the type checker, which is 

148
00:09:38.637 --> 00:09:43.130
looking at all our patterns and making 
sure we've covered all the possibilities. 

149
00:09:43.130 --> 00:09:48.748
Okay, so that's the first two reasons. 
The third reason is that we'll never, if 

150
00:09:48.748 --> 00:09:52.324
we use case expressions the way they're 
intended, 

151
00:09:52.324 --> 00:09:56.556
do things that lead to errors, like head 
of the empty list. 

152
00:09:56.556 --> 00:10:02.028
That instead, we always have one case and 
in that case, the patterns already 

153
00:10:02.028 --> 00:10:07.080
extracted the values. 
So when we had, in our program over here, 

154
00:10:07.080 --> 00:10:13.015
str of s, we already know, in this case, 
that s is going to be down to the 

155
00:10:13.015 --> 00:10:18.310
underlying string. And we'll never make 
the mistake that over here in this branch 

156
00:10:18.310 --> 00:10:22.560
of trying to get, one of the int values 
under a two ints, right? 

157
00:10:22.560 --> 00:10:26.090
Because, we just use the pattern to get 
the values out. 

158
00:10:26.090 --> 00:10:28.783
Okay. 
And finally we're not done showing you 

159
00:10:28.783 --> 00:10:32.565
case expressions, alright? 
This is the simple use of them but we're 

160
00:10:32.565 --> 00:10:36.347
going to generalize them. 
It turns out patterns can be much richer 

161
00:10:36.347 --> 00:10:38.753
and more powerful than we've shown so 
far. 

162
00:10:38.753 --> 00:10:43.280
And we'll be able to use those patterns 
to write very elegant and very concise 

163
00:10:43.280 --> 00:10:45.916
code. 
Much more elegant and concise than if we 

164
00:10:45.916 --> 00:10:50.100
had to use functions for checking 
variants and extracting pieces of data. 