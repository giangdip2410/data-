WEBVTT

1
00:00:00.000 --> 00:00:04.940

2
00:00:04.940 --> 00:00:10.004
In this segment we're going to talk about 
exceptions, which are what you use when 

3
00:00:10.004 --> 00:00:13.380
you have a run time condition that should 
be an error. 

4
00:00:13.380 --> 00:00:17.134
We'll talk about how to create 
exceptions, how to raise them, which is 

5
00:00:17.134 --> 00:00:21.105
called throwing in many languages, and 
how to handle them, which is called 

6
00:00:21.105 --> 00:00:24.642
catching in many languages. 
And this is a reasonable place in the 

7
00:00:24.642 --> 00:00:28.994
course to put this, because the way ML 
does exceptions is very similar to how it 

8
00:00:28.994 --> 00:00:32.640
does data type bindings although 
exceptions are a separate concept. 

9
00:00:32.640 --> 00:00:37.071
So let's explain most of this with the 
code and then we'll summarize what we see 

10
00:00:37.071 --> 00:00:40.189
with a couple of slides. 
So first, let me show you how the 

11
00:00:40.189 --> 00:00:44.347
function head, is actually implemented. 
So remember what head does, it takes a 

12
00:00:44.347 --> 00:00:46.644
list. 
The list is not empty, it returns the 

13
00:00:46.644 --> 00:00:49.434
first element. 
If it is empty, it ends up raising an 

14
00:00:49.434 --> 00:00:53.100
exception that happens to already be 
defined and called list.empty. 

15
00:00:53.100 --> 00:00:57.744
So here is exactly how I expect the code 
in out ML standard library to be 

16
00:00:57.744 --> 00:01:00.128
implemented. 
Just as a case expression. 

17
00:01:00.128 --> 00:01:02.953
In the case of a non empty list, it 
returns x. 

18
00:01:02.953 --> 00:01:07.157
But for the empty list, it uses this 
raise key word, followed by the 

19
00:01:07.157 --> 00:01:10.358
exception. 
And indeed, if we had a call of head with 

20
00:01:10.358 --> 00:01:15.065
the empty list, head would never return. 
Because what raise does is cause an 

21
00:01:15.065 --> 00:01:17.245
exception to occur instead, 
alright? 

22
00:01:17.245 --> 00:01:21.679
So list.empty was just defined by whoever 
wrote ML standard library. 

23
00:01:21.679 --> 00:01:25.262
Not surprisingly, we can define our own 
kinds of exceptions. 

24
00:01:25.262 --> 00:01:28.238
And what you do is you use the exception 
keyword. 

25
00:01:28.238 --> 00:01:32.064
And then any name you want, 
it's traditional to capitalize them. 

26
00:01:32.064 --> 00:01:36.072
So here, I've created an exception called 
my undesirable condition. 

27
00:01:36.072 --> 00:01:40.809
You can see here a little bit lower that 
having introduced that new exception 

28
00:01:40.809 --> 00:01:43.542
binding. 
I'll be able to raise my undesirable 

29
00:01:43.542 --> 00:01:46.231
condition. 
You can also create exceptions. 

30
00:01:46.231 --> 00:01:50.326
It carry values, the syntax is exactly 
like with constructors. 

31
00:01:50.326 --> 00:01:55.362
So here's another exception, where my 
another exception is not an exception. 

32
00:01:55.362 --> 00:02:00.397
It carrying a pair of ends would be. 
So you would be able to ride something 

33
00:02:00.397 --> 00:02:03.553
like rays, might other exceptions of 
three, four. 

34
00:02:03.553 --> 00:02:08.790
And that's a way to pass data out to 
whoever might be handling your exception, 

35
00:02:08.790 --> 00:02:11.651
alright? 
So at this point we've seen our first 

36
00:02:11.651 --> 00:02:15.632
piece of raise up here in head, we've 
defined our own exceptions. 

37
00:02:15.632 --> 00:02:20.982
Now here's a function called my div, that 
takes two integers and if the denominator 

38
00:02:20.982 --> 00:02:25.585
is zero, instead of raising whatever 
normal exception ML raises in this 

39
00:02:25.585 --> 00:02:28.820
situation, we raise my undesirable 
condition instead. 

40
00:02:28.820 --> 00:02:34.398
So that's really all there is to it. 
Now there is one other distinction I'd 

41
00:02:34.398 --> 00:02:38.850
like to make. 
There's a difference between making an 

42
00:02:38.850 --> 00:02:44.587
exception value, which is just something 
of type exn, and raising it. 

43
00:02:44.587 --> 00:02:50.580
So here is a function max list which 
takes in a list and an exception. 

44
00:02:50.580 --> 00:02:56.530
And, if the list is empty, it raises 
whatever exception was passed in. 

45
00:02:56.530 --> 00:03:00.455
Otherwise, if the list has one element, 
it just returns it. 

46
00:03:00.455 --> 00:03:05.758
Otherwise, it returns the max of the 
first element, and the max of the rest of 

47
00:03:05.758 --> 00:03:09.132
the list. 
So it's another nested pattern matching 

48
00:03:09.132 --> 00:03:12.369
example. 
But the interesting thing here is that 

49
00:03:12.369 --> 00:03:15.606
the caller to max list passes in the 
exception. 

50
00:03:15.606 --> 00:03:20.874
So max list, in fact, has type int list. 
Star E X N, which is the type of all 

51
00:03:20.874 --> 00:03:25.762
exceptions, arrow int. because if it 
doesn't return, it will return in int. 

52
00:03:25.762 --> 00:03:30.040
if it raises an exception who cares what 
the return type is. 

53
00:03:30.040 --> 00:03:35.607
So, here I have a call to max list, where 
I pass in the list three comma four comma 

54
00:03:35.607 --> 00:03:40.368
five and pass in this exception. 
Now this is not going to cause an 

55
00:03:40.368 --> 00:03:44.328
exception to be raised, it's just an 
exception value. 

56
00:03:44.328 --> 00:03:50.343
And since in this case max list won't 
call use arrays with the exception no 

57
00:03:50.343 --> 00:03:54.912
exception occurs. 
So if I run this code w will simply end 

58
00:03:54.912 --> 00:03:59.100
up being bound to five, the maximum 
element in the list. 

59
00:03:59.100 --> 00:04:02.157
Alright? 
So the last thing I want to show you with 

60
00:04:02.157 --> 00:04:06.616
exceptions, is how to handle them. 
This is what a lot of languages call 

61
00:04:06.616 --> 00:04:10.501
catching an exception. 
So anywhere you have, and there's a new 

62
00:04:10.501 --> 00:04:13.750
form of expression I just haven't shown 
you before. 

63
00:04:13.750 --> 00:04:18.591
Anywhere you have an expression e1, you 
can then write handle, some exception 

64
00:04:18.591 --> 00:04:20.438
name. 
It's actually a pattern. 

65
00:04:20.438 --> 00:04:23.050
Some, exception thing. 
And then some e2. 

66
00:04:23.050 --> 00:04:28.825
And what this is going to do is if E1 
evaluates normally, then the rest is 

67
00:04:28.825 --> 00:04:32.649
irrelevant. 
But if E1 raises the exception, listed 

68
00:04:32.649 --> 00:04:35.288
here. 
Then we'll evaluate, we'll catch that 

69
00:04:35.288 --> 00:04:37.476
exception. 
We'll evaluate E2 instead. 

70
00:04:37.476 --> 00:04:42.155
If this is not the same exception that E1 
throws then we are not handling it. 

71
00:04:42.155 --> 00:04:46.895
And it continues, the result of the 
entire thing is that the same exception 

72
00:04:46.895 --> 00:04:50.055
is raised. 
So here is a perfectly reasonable example 

73
00:04:50.055 --> 00:04:53.762
of a handle expression. 
But since the thing before the handle 

74
00:04:53.762 --> 00:04:57.226
does not raise an exception, this just 
evaluates the five. 

75
00:04:57.226 --> 00:05:00.690
The result of this entire thing is just 
going to be five. 

76
00:05:00.690 --> 00:05:03.110
Alright. 
On the other hand. 

77
00:05:03.110 --> 00:05:09.491
If we had this code here, where we pass 
max list, the empty list, then indeed max 

78
00:05:09.491 --> 00:05:15.469
list is going to end up evaluating, 
raising, my undesirable condition, so we 

79
00:05:15.469 --> 00:05:21.690
will handle that exception, and the 
result z, will end up being bound to 42. 

80
00:05:21.690 --> 00:05:26.591
This final example which is commented out 
here, this, if we evaluate it, will in 

81
00:05:26.591 --> 00:05:31.555
fact raise the exception, so why we'll 
never end up being pound to anything and 

82
00:05:31.555 --> 00:05:36.645
since we don't have a handle expression 
here, the evaluation of our program would 

83
00:05:36.645 --> 00:05:41.232
stop and so that is why I have it 
commented out, and so we can see all 

84
00:05:41.232 --> 00:05:45.720
these quickly, if we come over here and 
just use this file . 

85
00:05:45.720 --> 00:05:50.480
We will see that I am right. 
That w and x are both bound to five, and 

86
00:05:50.480 --> 00:05:53.770
z is bound to 42. 
And no exceptions were raised. 

87
00:05:53.770 --> 00:05:59.440
Because the only one that happened, which 
was up when we evaluated the expression 

88
00:05:59.440 --> 00:06:04.340
for x, we handled and decided to evaluate 
the expression to 42 instead. 

89
00:06:04.340 --> 00:06:08.684
Okay so, let's switch back to the slides 
and see whats going on in general. 

90
00:06:08.684 --> 00:06:12.031
We have a new kind of binding I had not 
shown you before. 

91
00:06:12.031 --> 00:06:16.846
This is an exception binding, this is how 
you introduce a new kind of an exception. 

92
00:06:16.846 --> 00:06:21.484
We have a new keyword I hadn't shown you 
before, raise, this is how you raise or 

93
00:06:21.484 --> 00:06:25.160
throw an exception. 
And we have another new expression form 

94
00:06:25.160 --> 00:06:30.025
for handling or catching exceptions. 
Where we evaluate the expression to the 

95
00:06:30.025 --> 00:06:35.082
left of the keyword handle, if that does 
not raise an exception then that's our 

96
00:06:35.082 --> 00:06:38.026
answer. 
If it does raise an exception and that 

97
00:06:38.026 --> 00:06:42.891
exception matches the one we have there, 
then we evaluate E2, otherwise we 

98
00:06:42.891 --> 00:06:47.752
continue to raise the exception. 
So, it turns out that exceptions are a 

99
00:06:47.752 --> 00:06:52.859
lot like data type constructors, that 
there is this built in type EXN. 

100
00:06:52.859 --> 00:06:58.706
Over here in the code you'll notice that 
max list does have type int list star 

101
00:06:58.706 --> 00:07:00.334
EXN, error int, 
alright? 

102
00:07:00.334 --> 00:07:05.663
So when you add a new kind of exception, 
you're really just adding a new 

103
00:07:05.663 --> 00:07:09.720
constructor of type EXN. 
So EXN is just a normal type, which is 

104
00:07:09.720 --> 00:07:13.320
why we can pass values of type EXN, like 
we did, into Maxlist. 

105
00:07:13.320 --> 00:07:16.140
It's not too common to do this. 
But it's useful. 

106
00:07:16.140 --> 00:07:19.500
It does let your caller choose what 
exception you raise. 

107
00:07:19.500 --> 00:07:22.500
Which seems like a potentially useful 
thing to do. 

108
00:07:22.500 --> 00:07:27.360
And it turns out that handle expressions 
are more general than I've been showing 

109
00:07:27.360 --> 00:07:30.300
you here. 
You, in fact, can use pattern matching as 

110
00:07:30.300 --> 00:07:33.000
deep as you want on those things of type 
EXN. 

111
00:07:33.000 --> 00:07:37.500
And you can even have multiple branches 
separated, by the pipe character. 

112
00:07:37.500 --> 00:07:39.840
Okay, but nonetheless I've shown you 
enough basics. 

113
00:07:39.840 --> 00:07:43.303
You'll use exceptions just a little bit 
on your homework to make sure you 

114
00:07:43.303 --> 00:07:45.644
understand how they work and how they can 
be used. 

115
00:07:45.644 --> 00:07:47.095
And now you know how they work. 