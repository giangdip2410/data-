WEBVTT

1
00:00:00.000 --> 00:00:07.211
I'd like to finish up our discussion of 
tail recursion by giving a little bit of 

2
00:00:07.211 --> 00:00:13.774
perspective on how important it is, and 
then talk about a more precise definition 

3
00:00:13.774 --> 00:00:17.340
of what it actually means to be a tail 
call. 

4
00:00:17.340 --> 00:00:21.503
So, first of all, a lot of times when 
people learn about tail recursion, 

5
00:00:21.503 --> 00:00:26.187
they're in a big hurry to make everything 
tail-recursive and it's worth pointing 

6
00:00:26.187 --> 00:00:29.483
out that there are cases where you really 
cannot do that. 

7
00:00:29.483 --> 00:00:33.936
Now technically speaking, you could make 
every function call a tail-recursive 

8
00:00:33.936 --> 00:00:37.059
call, a tail call. 
But you can't do it without building 

9
00:00:37.059 --> 00:00:41.338
other lists and data structures and 
things that are going to take up just as 

10
00:00:41.338 --> 00:00:45.884
much space as your call stack would. 
The most obvious examples are functions 

11
00:00:45.884 --> 00:00:49.518
that process trees. 
When you're doing a recursive traversal 

12
00:00:49.518 --> 00:00:54.385
over the tree, you need to keep track of 
what part of the tree you have visited 

13
00:00:54.385 --> 00:00:58.574
and you haven't so far and the call stack 
is a great way to do that. 

14
00:00:58.574 --> 00:01:03.317
And you were generally not going to end 
up with tail-recursive functions that 

15
00:01:03.317 --> 00:01:06.472
process trees. 
You can usually use an auxiliary helper 

16
00:01:06.472 --> 00:01:11.286
function to make one of your recursive 
calls, maybe the one over the left child 

17
00:01:11.286 --> 00:01:14.152
tail-recursive. 
But then you somehow need to keep track 

18
00:01:14.152 --> 00:01:16.617
of what you need to do for the right 
child. 

19
00:01:16.617 --> 00:01:21.087
So, you're welcome to try it and I think 
you'll end up seeing that one of your 

20
00:01:21.087 --> 00:01:25.976
recursive calls will not be a tail call. 
I would also make the more general point 

21
00:01:25.976 --> 00:01:31.297
that programmers are often in far too big 
of a hurry to optimize their code. 

22
00:01:31.297 --> 00:01:36.111
a lot of programs we write, it's more 
important that they be straightforward, 

23
00:01:36.111 --> 00:01:39.975
and readable, and easy to verify that 
they do the right thing. 

24
00:01:39.975 --> 00:01:45.106
And oftentimes, a shorter, more natural 
recursive function is perfectly good and 

25
00:01:45.106 --> 00:01:49.666
you can always go back and make a 
tailrecursive function if it becomes 

26
00:01:49.666 --> 00:01:54.662
important. 
The other thing I want to talk about is, 

27
00:01:54.662 --> 00:01:59.518
what exactly is a tail call? 
So, so far, we have a perfectly good 

28
00:01:59.518 --> 00:02:04.605
informal definition. Alright? 
This intuition that it's a call, where 

29
00:02:04.605 --> 00:02:08.612
after you make it, the caller has no more 
work to do. 

30
00:02:08.612 --> 00:02:13.236
In other words, you have some call. 
like F is going to call X, 

31
00:02:13.236 --> 00:02:17.630
and that result is the result for the 
enclosing function. 

32
00:02:17.630 --> 00:02:21.264
Alright? But, that works, that's how I 
think about it, 

33
00:02:21.264 --> 00:02:24.898
but how do you know if that's the 
immediate result? 

34
00:02:24.898 --> 00:02:29.601
It turns out, like many things in 
programming languages, there is an 

35
00:02:29.601 --> 00:02:35.302
elegant recursive definition of what it 
means for a position in a function body 

36
00:02:35.302 --> 00:02:39.132
to be a tail position. 
And then, a tail call is just any 

37
00:02:39.132 --> 00:02:44.478
function call that is in a tail position. 
So a tail position is, there won't be 

38
00:02:44.478 --> 00:02:46.946
anything more to do afterwards. 
Okay? 

39
00:02:46.946 --> 00:02:51.539
So I thought I would show you some of the 
cases of this definition. 

40
00:02:51.539 --> 00:02:56.611
It's kind of a top-down recursive 
definition about what it means to be in 

41
00:02:56.611 --> 00:02:58.120
tail position. 
Alright? 

42
00:02:58.120 --> 00:03:02.857
So first of all, if an expression is not 
in tail position, then neither will any 

43
00:03:02.857 --> 00:03:05.436
of its subexpressions be in tail 
position. 

44
00:03:05.436 --> 00:03:09.873
Once something is not in tail position, 
there's more work to do afterwards, 

45
00:03:09.873 --> 00:03:14.491
so none of the subexpressions are going 
to be the last thing either, because 

46
00:03:14.491 --> 00:03:19.613
there will be even more work to do. 
On a more positive note, if you have a 

47
00:03:19.613 --> 00:03:25.661
function definition, like fun f p = e, 
the body itself is in tail position. 

48
00:03:25.661 --> 00:03:29.401
Okay? 
So we start with the entire function body 

49
00:03:29.401 --> 00:03:33.638
and that is a tail position. 
Now here's a recursive case. 

50
00:03:33.638 --> 00:03:38.945
If you have a conditional, like if e then 
e2 else e3 or similarly for case 

51
00:03:38.945 --> 00:03:41.957
expressions, case e of a bunch of 
branches. 

52
00:03:41.957 --> 00:03:47.695
The test that e1 between the if and the 
then is not in tail position, because we 

53
00:03:47.695 --> 00:03:52.118
have more work to do afterwards. 
But if the conditional is in tail 

54
00:03:52.118 --> 00:03:56.563
position, then, so are e2 and e3. 
If there's nothing more to do after the 

55
00:03:56.563 --> 00:04:01.133
conditional, then there will be nothing 
more to do after e2 and there'll be 

56
00:04:01.133 --> 00:04:05.515
nothing more to do after e3. 
We'll do one of them and that will be the 

57
00:04:05.515 --> 00:04:08.669
last thing we do. 
Let's do a local let expression. 

58
00:04:08.669 --> 00:04:13.698
If you have a let expression that is 
itself in tail position, then the body e 

59
00:04:13.698 --> 00:04:18.922
is in tail position, because that also 
will be something after which there is no 

60
00:04:18.922 --> 00:04:23.885
more work to do. So a call, if, if this e 
were a function call, that would be a 

61
00:04:23.885 --> 00:04:29.109
tail call, but none of the expressions in 
the bindings would be in tail position, 

62
00:04:29.109 --> 00:04:33.420
because we still have to do all the other 
bindings and the body e. 

63
00:04:33.420 --> 00:04:39.235
Alright? And just as a final case, if you 
have the parts of a function call, those 

64
00:04:39.235 --> 00:04:43.888
are not end tail position. 
We have to evaluate e1, and afterwards, 

65
00:04:43.888 --> 00:04:48.977
we still have to evaluate e2. 
We have to evaluate e2 and afterwards, we 

66
00:04:48.977 --> 00:04:53.775
still have to do the call. 
So even if this call overall is in tail 

67
00:04:53.775 --> 00:04:59.009
position and is a tail call, any 
subexpressions, any extra work we do in 

68
00:04:59.009 --> 00:05:01.990
e1 and e2, those are not in tail 
position. 

69
00:05:01.990 --> 00:05:07.015
What this means is, if you ever have a 
nested function call, like f of g of x, 

70
00:05:07.015 --> 00:05:12.306
f might be a tail call but g of x never 
will be because the caller still has to 

71
00:05:12.306 --> 00:05:16.538
do the call to f afterwards. 
So, as is often the case, we have our 

72
00:05:16.538 --> 00:05:21.960
intuition of no more work to do and then 
we can make that definition more precise 

73
00:05:21.960 --> 00:05:26.193
in terms of the recursive structure of 
our programming language. 

74
00:05:26.193 --> 00:05:31.285
And that is really enough to precisely 
understand this idea of tail position, 

75
00:05:31.285 --> 00:05:33.269
tail calls, and tail-recursion. 