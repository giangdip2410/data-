WEBVTT

1
00:00:00.000 --> 00:00:04.940
[MUSIC] 

2
00:00:04.940 --> 00:00:08.945
In this segment, I want to talk a little 
bit about type inference and then, we'll 

3
00:00:08.945 --> 00:00:13.104
continue this discussion the next segment 
about one type being more general than 

4
00:00:13.104 --> 00:00:15.466
another. 
We're going to study type inference a 

5
00:00:15.466 --> 00:00:19.573
little later in the course and understand 
how ML actually does it, but I need to 

6
00:00:19.573 --> 00:00:23.527
tell you a little bit about it now so 
that you're not concerned on your next 

7
00:00:23.527 --> 00:00:27.532
homework if you're getting some types 
back from ML that might surprise you in 

8
00:00:27.532 --> 00:00:30.608
certain ways. 
So, as I mentioned, once we learned how 

9
00:00:30.608 --> 00:00:35.363
to pattern match on each of types, 
in the second homework, we don't want you 

10
00:00:35.363 --> 00:00:39.673
to use the hash character. 
We don't want you to say hash two or hash 

11
00:00:39.673 --> 00:00:44.617
foo to get the foo field out of a record. 
And conversely, now in ML, once we stop 

12
00:00:44.617 --> 00:00:49.245
using the hash character, we don't have 
to write down types on any of our 

13
00:00:49.245 --> 00:00:54.253
function arguments anymore or on any of 
our variable bindings or anything else. 

14
00:00:54.253 --> 00:00:56.915
And it turns out these things are 
related. 

15
00:00:56.915 --> 00:01:01.606
That once you use pattern matching for 
getting the pieces of a tuple or a 

16
00:01:01.606 --> 00:01:04.310
record, 
the type checker can always figure out 

17
00:01:04.310 --> 00:01:07.033
what the type of a function argument 
should be. 

18
00:01:07.033 --> 00:01:10.568
So, let me show you how that works mostly 
by showing you code. 

19
00:01:10.568 --> 00:01:15.088
Here are two functions we've seen before. 
Our old friends for summing a triple. 

20
00:01:15.088 --> 00:01:19.202
Take in a single triple x, y, z to 
pattern-matching against the three parts 

21
00:01:19.202 --> 00:01:22.645
and sum them up. 
Or take in a record here, with first, 

22
00:01:22.645 --> 00:01:27.676
middle, and last fields, bind those 
fields x, y, and z and then concatenate 

23
00:01:27.676 --> 00:01:31.240
them together with some blank spaces in 
between. 

24
00:01:31.240 --> 00:01:36.668
So, if I just run this and, load this up 
we will see, as we've seen before, that 

25
00:01:36.668 --> 00:01:42.096
the type checker can figure out that 
sum_triple1 needs to have type int * int 

26
00:01:42.096 --> 00:01:45.820
* int arrow int. 
You can tell it's a triple, because it's 

27
00:01:45.820 --> 00:01:48.850
x, y, z. 
You can tell they have to be ints because 

28
00:01:48.850 --> 00:01:53.142
x, y, and z are added together. 
Similarly, full name has to be a record 

29
00:01:53.142 --> 00:01:57.497
with first, last, and middle fields. 
And those contents have to be strings 

30
00:01:57.497 --> 00:02:02.421
because in the body, we concatenate them. 
And then, the result type of full name 

31
00:02:02.421 --> 00:02:06.439
one is of type string. 
So, these patterns told the type checker 

32
00:02:06.439 --> 00:02:10.908
most of what it needed to know. 
And then how the variables were used 

33
00:02:10.908 --> 00:02:14.506
showed the rest. 
So, let me show you that if you use 

34
00:02:14.506 --> 00:02:20.181
instead hash characters, the type checker 
does not have as much information. 

35
00:02:20.181 --> 00:02:26.146
Now, these versions, sum_triple2 and 
full_name2, which use hash characters the 

36
00:02:26.146 --> 00:02:30.293
old fashioned way, will work, and they 
will work just fine. 

37
00:02:30.293 --> 00:02:36.129
So, let me quickly go over here, and just 
show you that, that if I reuse them, they 

38
00:02:36.129 --> 00:02:41.468
work just fine and we get the correct 
types for sum_triple2 and full_name2 but 

39
00:02:41.468 --> 00:02:46.248
if I took out these types, and let me 
just do this for the first one here and 

40
00:02:46.248 --> 00:02:50.217
try that again, 
I now get a compilation error message, 

41
00:02:50.217 --> 00:02:55.354
unresolved flex record, need to know the 
names of all the fields, blah, blah, 

42
00:02:55.354 --> 00:02:58.456
blah. 
And the reason why the ML type checker is 

43
00:02:58.456 --> 00:03:02.780
complaining is it looks at this 
sum_triple, and it can tell the triple 

44
00:03:02.780 --> 00:03:07.501
here needs to be a tupple with at least 
three fields where the contents are type 

45
00:03:07.501 --> 00:03:10.065
int. 
But how does it know that there isn't a 

46
00:03:10.065 --> 00:03:13.328
fourth position, or a fifth position, or 
a sixth position? 

47
00:03:13.328 --> 00:03:15.950
It doesn't. 
And every type system has certain 

48
00:03:15.950 --> 00:03:18.864
limitations. 
And in ML, one of those limitations, is 

49
00:03:18.864 --> 00:03:23.351
you can't write a function that takes on 
both three tupples and four tupples. 

50
00:03:23.351 --> 00:03:27.779
And so, since the type checker can't 
figure out how wide the tupple supposed 

51
00:03:27.779 --> 00:03:31.742
be, you get an error message. 
And that's why this simply doesn't type 

52
00:03:31.742 --> 00:03:35.530
check and why, in homework 1, we made you 
write those types down. 

53
00:03:35.530 --> 00:03:37.015
Alright. 
So, that's fine. 

54
00:03:37.015 --> 00:03:41.986
That's an advantage of not using hash. 
But now, let me show you something that 

55
00:03:41.986 --> 00:03:47.345
you may trip across in homework 2 and so 
its important that we tell you about it, 

56
00:03:47.345 --> 00:03:50.186
okay? 
So, here are a couple of functions that 

57
00:03:50.186 --> 00:03:54.190
don't use all the pieces that were 
pattern-matching against. 

58
00:03:54.190 --> 00:03:59.072
So this function partial sum adds 
together x and z and doesn't use y. 

59
00:03:59.072 --> 00:04:04.091
And, similarly, this name function 
concatenates the first and last name but 

60
00:04:04.091 --> 00:04:06.668
doesn't use the middle name, 
alright? 

61
00:04:06.668 --> 00:04:12.500
So, if told you on your homework, say, to 
write a function of type int * int * int 

62
00:04:12.500 --> 00:04:17.993
arrow int, that indeed had the behavior 
of adding the first position in the third 

63
00:04:17.993 --> 00:04:21.520
position, you would probably write 
exactly this code. 

64
00:04:21.520 --> 00:04:26.093
And then, you would save it. 
And then, you would come over here and 

65
00:04:26.093 --> 00:04:29.892
you would run this. 
And you would see that the type of 

66
00:04:29.892 --> 00:04:33.340
partial sum is int * alpha * int arrow 
int. 

67
00:04:33.340 --> 00:04:39.461
And you would say, oh no, I wanted an int 
* int * int arrow int, and what I got was 

68
00:04:39.461 --> 00:04:44.738
an int * alpha * int arrow int. 
And what I want to tell you is, that's 

69
00:04:44.738 --> 00:04:47.598
okay. 
That sometimes, the type checker is 

70
00:04:47.598 --> 00:04:52.974
perhaps a little bit smarter than you 
are, and in looking at your functions, 

71
00:04:52.974 --> 00:04:57.418
decides they are more general, more 
reusable than you expected. 

72
00:04:57.418 --> 00:05:02.865
And indeed, if you look at this, it 
worked just fine to call partial sum with 

73
00:05:02.865 --> 00:05:06.735
three integers. 
It's a polymorphic function that works 

74
00:05:06.735 --> 00:05:12.613
for a tuple where the middle position has 
any type, and indeed, we can call partial 

75
00:05:12.613 --> 00:05:19.775
sum with 3, 4, 5 and get eight, but we 
could also call it with a string in 

76
00:05:19.775 --> 00:05:25.276
there, and that will also type check. 
It would not work to put that string in 

77
00:05:25.276 --> 00:05:27.228
the last position, 
alright? 

78
00:05:27.228 --> 00:05:32.153
That doesn't type check, and that's 
because if you look at the code, the last 

79
00:05:32.153 --> 00:05:35.070
part does have to be an int, because we 
add it. 

80
00:05:35.070 --> 00:05:40.417
So, whenever this happens, and it often 
happens when you're not using part of 

81
00:05:40.417 --> 00:05:45.694
your argument, you'll end up with a more 
general type than you might expect. 

82
00:05:45.694 --> 00:05:47.453
And that is okay, 
alright? 

83
00:05:47.453 --> 00:05:50.690
I sometimes call this unexpected 
polymorphism, 

84
00:05:50.690 --> 00:05:53.392
alright? 
If your function is correct, and you 

85
00:05:53.392 --> 00:05:58.428
still need to test it, you still need to 
make sure that it does work for the types 

86
00:05:58.428 --> 00:06:02.605
that it is required to work for. 
Then, if it also works for values of 

87
00:06:02.605 --> 00:06:05.308
other types, 
well, that's just a useful thing. 

88
00:06:05.308 --> 00:06:10.160
And we don't need to worry about the type 
that ML gave us as long as it's more 

89
00:06:10.160 --> 00:06:14.648
general than what we needed. 
Now, hopefully this idea of more general 

90
00:06:14.648 --> 00:06:19.838
is intriguing to you, and you'd like to 
learn, hey, given two types, how can I 

91
00:06:19.838 --> 00:06:25.236
tell if one is more general than another? 
And I can give you precise rules for 

92
00:06:25.236 --> 00:06:28.420
doing that and I'll do it in the next 
segment. 