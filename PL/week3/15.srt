WEBVTT

1
00:00:00.000 --> 00:00:04.940
In this segment, I want to start talking 
about nested patterns. 

2
00:00:04.940 --> 00:00:10.092
This is going to generalize everything 
we've been learning about pattern 

3
00:00:10.092 --> 00:00:15.597
matching, by doing a very simple thing 
which is letting us put patterns inside 

4
00:00:15.597 --> 00:00:21.454
of other patterns, and then extending our 
definition of pattern matching to account 

5
00:00:21.454 --> 00:00:24.534
for that. 
So it turns out that we can nest patterns 

6
00:00:24.534 --> 00:00:28.084
as deep as we want. 
Everywhere we have been putting variables 

7
00:00:28.084 --> 00:00:30.820
in patterns we can actually put other 
patterns. 

8
00:00:30.820 --> 00:00:35.415
This corresponds to the idea that when 
we're making expressions, we can always 

9
00:00:35.415 --> 00:00:39.658
put nested expressions anywhere we want. 
We don't have to write x plus y. 

10
00:00:39.658 --> 00:00:42.250
We can write expressions in those 
positions. 

11
00:00:42.250 --> 00:00:46.787
We're going to be able to do the same 
thing with patterns, and what this will 

12
00:00:46.787 --> 00:00:51.088
let us do is avoid hard to read case 
expressions that have other case 

13
00:00:51.088 --> 00:00:55.743
expressions inside of them, and instead, 
let us write something very elegant and 

14
00:00:55.743 --> 00:00:59.166
easy to read programs. 
So it turns out the full meaning of 

15
00:00:59.166 --> 00:01:03.359
pattern matching, is going to be a 
recursive definition, that's going to 

16
00:01:03.359 --> 00:01:07.848
take the idea of a pattern that can 
contain other patterns, and a value that 

17
00:01:07.848 --> 00:01:12.692
can contain other values, and see if the 
value has the same shape described by the 

18
00:01:12.692 --> 00:01:15.763
pattern, and if so, bind variables to the 
right parts. 

19
00:01:15.763 --> 00:01:20.193
But I think it will be easier to see 
several examples over the next couple 

20
00:01:20.193 --> 00:01:24.930
segments, before we get to that precise 
elegant recursive definition. 

21
00:01:24.930 --> 00:01:30.328
So what I want to do in this segment is 
show one nice example which relates to 

22
00:01:30.328 --> 00:01:34.633
zipping and unzipping. 
So to explain what zipping and unzipping 

23
00:01:34.633 --> 00:01:40.031
is I have written a function zip3 and its 
reverse, its inverse, unzip3 that work 

24
00:01:40.031 --> 00:01:43.643
like the following. 
If I call zip three with a triple of 

25
00:01:43.643 --> 00:01:48.395
lists, so three arguments, each of which 
was a list, say an a list of integers, 

26
00:01:48.395 --> 00:01:53.459
although this function it turns out this 
function is polymorphic, what I get back 

27
00:01:53.459 --> 00:01:58.313
is one list containing triples. 
So it went from three lists to one list 

28
00:01:58.313 --> 00:02:02.973
of triples and what it did is it put 
corresponding pieces together. 

29
00:02:02.973 --> 00:02:08.397
So in the arguments the first elements 
here are one, four, and seven, and in the 

30
00:02:08.397 --> 00:02:12.501
result the first element is a triple of 
one, four, and seven. 

31
00:02:12.501 --> 00:02:17.300
Similarly we then see two, five, and 
eight, and then three, six, and nine. 

32
00:02:17.300 --> 00:02:23.163
And unzip does the reverse, 
it takes a list of triples and returns 

33
00:02:23.163 --> 00:02:26.632
three lists. 
Where each list contains first all the 

34
00:02:26.632 --> 00:02:31.685
first positions from the tuples, then all 
the second positions from the tuples, and 

35
00:02:31.685 --> 00:02:34.457
then all the third positions from the 
tuples. 

36
00:02:34.457 --> 00:02:39.140
So by the way the reason why this is 
called zip and unzip is that it acts a 

37
00:02:39.140 --> 00:02:44.130
little bit like a zipper, like on your 
shirt or you know, on a bag or something, 

38
00:02:44.130 --> 00:02:48.875
because zip, takes these separate things 
and puts them next to each other and 

39
00:02:48.875 --> 00:02:52.880
unzip, takes something that was all 
together and separates it out. 

40
00:02:52.880 --> 00:02:55.488
I wouldn't look at your zipper too 
closely though. 

41
00:02:55.488 --> 00:02:59.296
Because when you actually zip, the teeth 
do not end up next to each other. 

42
00:02:59.296 --> 00:03:01.800
They end up adjacent, but the intuition 
is right. 

43
00:03:01.800 --> 00:03:04.663
Okay, 
so that's what I want these functions to 

44
00:03:04.663 --> 00:03:07.322
do. 
Let's see how we might implement them. 

45
00:03:07.322 --> 00:03:12.659
And to give you some contrast here let me 
start by showing you how we would do it 

46
00:03:12.659 --> 00:03:17.605
if we didn't have pattern matching. 
So here is one way to zip together three 

47
00:03:17.605 --> 00:03:21.639
lists, so it's a function using our old 
features, old zip three. 

48
00:03:21.639 --> 00:03:26.000
It takes in three arguments, L1, L2, and 
L3, and if they are all empty. 

49
00:03:26.000 --> 00:03:31.140
L1 is null, L2 is null, L3 is null. 
Then let's return the empty list. 

50
00:03:31.140 --> 00:03:35.678
L's if any of them are empty our lists 
don't have the same length and I'm going 

51
00:03:35.678 --> 00:03:39.848
to call that an error and I'll raise a 
run time exception I will show you in a 

52
00:03:39.848 --> 00:03:44.070
few segments how to raise exceptions but 
this is how you do it I've declared an 

53
00:03:44.070 --> 00:03:48.558
exception up here and I'll raise it. 
Otherwise I have three non-empty lists. 

54
00:03:48.558 --> 00:03:53.603
If I have three non-empty lists, let's 
create a couple out of the head of L1, 

55
00:03:53.603 --> 00:03:58.780
head of L2 and head of L3 and cons that 
onto the result of zipping tail of L1, 

56
00:03:58.780 --> 00:04:02.033
tail of L2 and tail of L3. 
Okay, so that's zipping. 

57
00:04:02.033 --> 00:04:06.347
I prefer pattern matching. 
this is pretty easy to get wrong. 

58
00:04:06.347 --> 00:04:11.923
you could easily miss some cases, you're 
getting no help from the type checker. 

59
00:04:11.923 --> 00:04:17.166
But if you go to use pattern matching the 
way you've been using it so far, it's 

60
00:04:17.166 --> 00:04:21.741
frankly a bit of a mess. 
So, here is a version that uses pattern 

61
00:04:21.741 --> 00:04:25.068
matching. 
And let's see, so let's first deal with 

62
00:04:25.068 --> 00:04:30.093
the case that all three lists are empty. 
Well I'd have to prod a match on L1 and 

63
00:04:30.093 --> 00:04:34.993
then if its empty see if L2 is empty and 
then if its empty see if L3 is empty. 

64
00:04:34.993 --> 00:04:39.767
And aha if I get here then all three 
lists are empty and so I should return 

65
00:04:39.767 --> 00:04:43.347
the empty list. 
In, in otherwise L3 is not empty but L1 

66
00:04:43.347 --> 00:04:46.188
and L2 are, so I should raise an 
exception. 

67
00:04:46.188 --> 00:04:50.854
Otherwise, L1 is empty but L2 is not, and 
I need to raise an exception. 

68
00:04:50.854 --> 00:04:55.927
Otherwise, L1 is not empty, so it 
patterns match head1 and tail1 and then 

69
00:04:55.927 --> 00:05:01.135
if L2 is empty then raise an exception. 
And you see where this is going, I, I'm 

70
00:05:01.135 --> 00:05:06.681
exploring all possibilities of empty and 
non-empty rather than the convenience up 

71
00:05:06.681 --> 00:05:11.165
above of and, also and or, else. 
So it turns out the fix for this is not 

72
00:05:11.165 --> 00:05:16.075
to abandon pattern matching but to use 
the fact that patterns can appear inside 

73
00:05:16.075 --> 00:05:19.696
of other patterns. 
So now let's look at how I like to write 

74
00:05:19.696 --> 00:05:22.933
zip three. 
Here is a nice concise function zip 

75
00:05:22.933 --> 00:05:26.140
three. 
It takes one argument, just like every 

76
00:05:26.140 --> 00:05:30.076
function in ml. 
Let's call it list triple, you can call 

77
00:05:30.076 --> 00:05:34.668
it anything you like. 
And let's pattern match on this triple of 

78
00:05:34.668 --> 00:05:37.583
lists. 
And let's consider three patterns. 

79
00:05:37.583 --> 00:05:43.009
The first pattern is this one. 
This is a pattern where I have a pattern 

80
00:05:43.009 --> 00:05:47.830
for a tupple with three patterns for 
lists inside of it. 

81
00:05:47.830 --> 00:05:53.914
And what this is going to match is any 
value that is a triple of three empty 

82
00:05:53.914 --> 00:05:57.233
lists. 
So if list triple, is all empty, then 

83
00:05:57.233 --> 00:06:01.580
this pattern will match, and I'll return 
the empty list. 

84
00:06:01.580 --> 00:06:06.362
Now let's look at the next pattern. 
This pattern also matches triples. 

85
00:06:06.362 --> 00:06:10.878
Here's before the first comma. 
Here's, after the, before the second 

86
00:06:10.878 --> 00:06:13.380
comma. 
Here's after the second comma. 

87
00:06:13.380 --> 00:06:16.802
Each thing in it has to be a non-empty 
list. 

88
00:06:16.802 --> 00:06:20.070
Why? 
Because this is a nested pattern that 

89
00:06:20.070 --> 00:06:25.515
matches against non-empty lists. 
Just like this one is, and this one is. 

90
00:06:25.515 --> 00:06:30.650
So the overall pattern will only match 
list triple if list triple, 

91
00:06:30.650 --> 00:06:35.224
is something that is a triple containing 
three non empty lists. 

92
00:06:35.224 --> 00:06:40.741
And if it matches I will bind six 
variables head one tail one head two tail 

93
00:06:40.741 --> 00:06:45.358
two head three and tail three. 
Head one, head two, and head three will 

94
00:06:45.358 --> 00:06:48.823
be bound to the beginning elements of the 
three lists. 

95
00:06:48.823 --> 00:06:53.251
And tail one, tail two, and tail three to 
the tails of the three lists. 

96
00:06:53.251 --> 00:06:58.257
And what I want to do over here, is the 
very elegant call cons with the triple 

97
00:06:58.257 --> 00:07:03.070
made from head one, head two, and head 
three, recursively call zip three with 

98
00:07:03.070 --> 00:07:06.600
tail one, tail two, and tail three. 
So here is my pattern. 

99
00:07:06.600 --> 00:07:11.761
If it matches, here is my expression. 
And it actually looks like I'm zipping it 

100
00:07:11.761 --> 00:07:14.606
up. 
Create a tuple out of head one, head two, 

101
00:07:14.606 --> 00:07:19.570
and head three, recursively zip three 
with tail one, tail two, and tail three. 

102
00:07:19.570 --> 00:07:23.668
Now that does not cover all the cases. 
I've covered the cases where everything 

103
00:07:23.668 --> 00:07:26.400
is empty and where the three elements are 
non-empty. 

104
00:07:26.400 --> 00:07:31.002
Here's a new kind of pattern: underscore. 
Underscore matches everything and doesn't 

105
00:07:31.002 --> 00:07:34.370
bind any variables. 
And it turns out for zipping and all the 

106
00:07:34.370 --> 00:07:36.952
other cases, I just want to raise an 
exception. 

107
00:07:36.952 --> 00:07:41.555
So if the first pattern doesn't match and 
the second pattern doesn't match, then I 

108
00:07:41.555 --> 00:07:44.866
want this third case. 
The typechecker warned me that I want 

109
00:07:44.866 --> 00:07:49.020
this case because my first two patterns 
don't cover all the possibilities. 

110
00:07:49.020 --> 00:07:51.490
So I really like writing programs like 
this. 

111
00:07:51.490 --> 00:07:56.151
zipping is one great example, there are 
other examples that work as well. 

112
00:07:56.151 --> 00:08:01.124
And for this segment let's finish up with 
unzipping and then I'll show you some 

113
00:08:01.124 --> 00:08:05.165
other examples in the next one. 
So in unzipping I want to take an 

114
00:08:05.165 --> 00:08:07.900
argument which is already a list of 
triples. 

115
00:08:07.900 --> 00:08:14.080
And I want to return three lists. 
So now my pattern matching is going to be 

116
00:08:14.080 --> 00:08:18.635
a little bit simpler. 
If this argument list is empty, then I 

117
00:08:18.635 --> 00:08:24.038
want to return three empty lists. 
That is how you unzip the empty list. 

118
00:08:24.038 --> 00:08:27.590
You return three lists all of which are 
empty. 

119
00:08:27.590 --> 00:08:33.262
Otherwise, I want to pattern match 
against a non empty list now we use to 

120
00:08:33.262 --> 00:08:38.780
just do this as something like head colon 
tail or x colon exes, alright.? 

121
00:08:38.780 --> 00:08:43.007
But what you can do is you can nest these 
patterns as well. 

122
00:08:43.007 --> 00:08:46.160
You can say, sure, I want to pattern 
match 

123
00:08:46.160 --> 00:08:50.598
the rest of the list against this tl 
variable, it has nothing to do with this 

124
00:08:50.598 --> 00:08:53.768
tail function. 
I'm just shadowing it with a tl variable. 

125
00:08:53.768 --> 00:08:58.494
But I want to match the head of the list 
against this eachof pattern, against this 

126
00:08:58.494 --> 00:09:01.549
tuple pattern. 
So, if this pattern matches, then a will 

127
00:09:01.549 --> 00:09:06.217
be the first component of the head of the 
list, b will be the second component of 

128
00:09:06.217 --> 00:09:10.771
the head of the list, and c will be the 
third component of the head of the list, 

129
00:09:10.771 --> 00:09:13.480
and tail will be bound to the rest of the 
list, 

130
00:09:13.480 --> 00:09:16.883
okay? 
These are the only two possibilities I 

131
00:09:16.883 --> 00:09:20.887
have to account for. 
Because any list of triples will either 

132
00:09:20.887 --> 00:09:23.956
match this pattern, or will match this 
pattern. 

133
00:09:23.956 --> 00:09:29.095
And the type of unzip three is going to 
require list to be a list of triples. 

134
00:09:29.095 --> 00:09:32.098
Okay, 
so once I've bound these four variables. 

135
00:09:32.098 --> 00:09:37.104
Let's look at this expression. 
Let us recursively call upzip three on 

136
00:09:37.104 --> 00:09:40.955
the tail that's going to give me back 
three lists. 

137
00:09:40.955 --> 00:09:46.809
Let's use ordinary each of pattern 
matching to bind those three lists to L1, 

138
00:09:46.809 --> 00:09:49.580
L2, and L3. 
And now I'm basically done, because I 

139
00:09:49.580 --> 00:09:51.960
have the three lists for unzipping the 
tail. 

140
00:09:51.960 --> 00:09:57.331
I have A, B, and C for the three 
components of the head of the list and 

141
00:09:57.331 --> 00:10:03.010
now I just want to return the triple 
expression that A cons on to L1, B cons 

142
00:10:03.010 --> 00:10:07.798
on to L2, C cons on the L3 and now. 
Using the idea of nested pattern 

143
00:10:07.798 --> 00:10:12.420
matching, I've in what, less than ten 
lines of code, written elegant and 

144
00:10:12.420 --> 00:10:16.316
concise, easy to read, zipping and 
unzipping for three lists. 

145
00:10:16.316 --> 00:10:21.664
This is a bit of an advanced example for 
nested pattern matching, but it uses all 

146
00:10:21.664 --> 00:10:26.814
the features that I want to show you. 
Then in the next segment I'll show you a 

147
00:10:26.814 --> 00:10:31.700
couple other situations, common idioms, 
where nested patterns are extremely 

148
00:10:31.700 --> 00:10:32.163
useful. 